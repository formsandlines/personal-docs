#+title: Docs/Janet

* General information

- https://janet-lang.org
- [[https://github.com/ahungry/awesome-janet][Awesome Janet]]
- [[https://janetdocs.com/][JanetDocs]]

Features:
- implemented mostly in standard *C99*
  - direct interop with C via /abstract types/ and C functions
  - dynamically load C libraries
- runs on /Windows/, /Linux/, /macOS/
- easily /portable/ and /embeddable/
- built-in /Parsing Expression Grammars/ (PEGs)
- exports standalone executables with companion build tool *jpm*

Use-cases:
- system scripting
- embedding into other programs
- rapid prototyping
- dynamic systems
- text-wrangling (PEGs, etc.)

* Installation & Usage

Installation:
: $ brew install janet

Start REPL:
: $ janet

Load/run a Janet script:
: $ janet myscript.janet
- this will run the ~main~ function of the script, if there is any
- ~main~ must be defined with variadic args, like ~[&]~


** Images

To create an image from a script:
: $ janet -c myscript.janet myscript.jimage

To create an image from the REPL:
: > (def image (make-image (curenv)))
: > (spit "repl.jimage" image)

This will create an image, which consists of a single marshalled value (in
the form of a Janet table ~@{‚Ä¶}~), which is the input program‚Äôs environment.
This env contains all top-level definitions with their symbols as keys and
the corresponding marshalled values as well as some metadata.
- [[https://janet.guide/compilation-and-imagination/][Source]]

To inspect the contents of the image from the REPL:
: > (load-image (slurp "myscript.jimage"))

Load an image file into Janet:
: $ janet -i myimage.jimage
- deserializes the env table in the image, looks up a symbol ~main~ there and
  (if found), executes that function

* jpm
** Projects

Create a new Janet (+ C) project interactively in a directory =name=:
: $ jpm new-project [name]
: $ jpm new-c-project [name]
Create a new project for an executable in a directory =name=:
: $ jpm new-exe-project [name]

To install dependencies of a project:
: $ sudo jpm deps
- installs them globally to =/opt/homebrew/Cellar/janet/<version>/lib=

** Executables

#+begin_src janet
(declare-executable
  :name "myexec"
  :entry "main.janet"
  :install true)
#+end_src
- ~:install true~ not needed for building

Compilation to native code:
: $ jpm build

* Packages

To install a package:
: $ sudo jpm install [pkg-name ‚Ä¶]
To uninstall a package:
: $ sudo jpm uninstall [pkg-name ‚Ä¶]

Installation directory: =/opt/homebrew/Cellar/janet/<version>/lib=

To list installed packages:
: $ jpm list-installed
To list available packages:
: $ jpm list-pkgs [name]

To update the package listing:
: $ sudo jpm update-pkgs
- same as ~sudo jpm install pkgs~
To update all installed packages to latest version:
: $ sudo jpm update-installed
To update jpm itself:
: $ sudo jpm install jpm

* Editor support

** (Neo)Vim

Syntax support:
- https://github.com/janet-lang/janet.vim

Interactive evaluation with Conjure:
- https://github.com/Olical/conjure/wiki/Quick-start:-Janet-(netrepl)

Needs [[https://github.com/janet-lang/spork/#networked-repl][spork/netrepl]]:
: $ jpm install spork
To start the netrepl:
: $ janet -e "(import spork/netrepl) (netrepl/server)"
Then start Vim, it will automatically connect to Conjure.

** Emacs

~janet-mode~ Janet mode
- https://github.com/ALSchwalm/janet-mode

~ijanet-mode~ Interactive Janet mode
- https://github.com/SerialDev/ijanet-mode

~inf-janet~ Inferior lisp Janet mode
- https://github.com/velkyel/inf-janet

* Data types

Janet has separate mutable and immutable data structures
- no structural sharing in immutables like in Clojure
- all are passed by reference internally (C pointer)

| data type          | immutable                             | mutable  |
|--------------------+---------------------------------------+----------|
| atom               | number, keyword, symbol, nil, boolean |          |
| closure            |                                       | function |
| coroutine          |                                       | fiber    |
| byte array         | string                                | buffer   |
| random-access list | tuple                                 | array    |
| hash table         | struct                                | table    |

- [[https://janet.guide/values-and-references/][Source]]

** Built-in types:
#+begin_src C
typedef enum JanetType {
  JANET_NUMBER,
  JANET_NIL,
  JANET_BOOLEAN,
  JANET_FIBER,
  JANET_STRING,
  JANET_SYMBOL,
  JANET_KEYWORD,
  JANET_ARRAY,
  JANET_TUPLE,
  JANET_TABLE,
  JANET_STRUCT,
  JANET_BUFFER,
  JANET_FUNCTION,
  JANET_CFUNCTION,
  JANET_ABSTRACT,
  JANET_POINTER
} JanetType;
#+end_src

#+begin_src janet
(type <expr>)  # to check the type of an expression

(struct <item ‚Ä¶>) = {‚Ä¶}
(table <item ‚Ä¶>) = @{‚Ä¶}

(tuple <item ‚Ä¶>) = [‚Ä¶]
(array <item ‚Ä¶>) = @[‚Ä¶]

(string <string ‚Ä¶>) = "‚Ä¶"
(buffer <string ‚Ä¶>) = @"‚Ä¶"

(keyword <string ‚Ä¶>) = :‚Ä¶
(symbol <string ‚Ä¶>) = '‚Ä¶

(fiber/new <fn>) = <fiber ‚Ä¶>
#+end_src
- ~nil~ is not allowed as a key in tables or structs

Numeric literals:
#+begin_src janet
0
+0.0
-10_000
16r1234abcd 2r101 # hexadecimal, binary, etc.
0x23.23
1e10
1.6e-4
7r343_111_266.6&+10 # a base 7 number in scientific notation.
# evaluates to 1.72625e+13 in base 10
#+end_src

String literals:
#+begin_src janet
"Hello, this is a string."

# Add escape characters for newlines, double quotes, backslash, tabs, etc.
"Hello\nThis is on line two\n\tThis is indented\n"

# If a double-quoted string spans multiple lines, newline characters will
# be removed but other whitespace is preserved.
"Hello, this
    is al
l one line
here."   # -> "Hello, this    is all one linehere."

# To avoid escape characters in long strings, use 1 or more backticks (`):
``
This is a string.
Line 2
    Indented
"We can just type quotes here", and backslashes \ no problem.
``

# If printable, embed UTF-8 literally in strings rather than escaping:
"Hello, üëç"
#+end_src

** Extended abstract types:
- ~core/rng~ -> pseudorandom number generator
- ~core/socket-address~
- ~core/process~
- ~core/parser~ -> parser used by Janet to parse Janet code
- ~core/peg~ -> parsing expression grammar
- ~core/stream~ and
- ~core/channel~ -> concurrent communication primitives
- ~core/lock~ and
- ~core/rwlock~ -> multithreading stuff
- ~core/ffi-signature~,
- ~core/ffi-struct~ and
- ~core/ffi-native~ -> parts of an experimental FFI module
- ~core/s64~ and
- ~core/u64~ -> boxed 64-bit integer types

* Object-like tables

Similar to objects in OOP, Tables can be ‚Äúinstantiated‚Äù from a *prototype*,
invoke ‚Äúmethods‚Äù defined as entries on the prototype that may operate on
‚Äúfields‚Äù which are (stateful) entries in the instantiated table.

** Methods

‚Äúmethods‚Äù are just functions
- they can have a ~self~ parameter, which is not special in any way
- in invocation, ~self~ must be passed the table/struct itself
#+begin_src janet
# defining an ‚Äúobject‚Äù:
(def obj @{:get-foo (fn [self] (self :_foo))
           :_foo 123})

# invocing its ‚Äúmethod‚Äù:
((obj :get-foo) obj) # 123
# shortcut (equivalent):
(:get-foo obj) # 123
#+end_src

** Prototypes

*tables* and *structs* can have prototypes by inheriting entries from another
table/struct.
- only /single-inheritance/
- unlike in JS, tables/struct have no /default prototype/

To get the prototype of a table or struct:
: (table/getproto <table>)
: (struct/getproto <struct>)
- returns ~nil~ if no prototype available

*** Using prototypes for class-like constructs:
#+begin_src janet
# ‚Äúclass‚Äù
(def my-prototype
  @{:my-getter (fn [self] (self :_x))
    :my-setter (fn [self new-x] (set (self :_x) new-x))})

# ‚Äúconstructor‚Äù
(defn construct-object [init]
  (table/setproto @{:_x init} my-prototype))

# ‚Äúinstantiate‚Äù
(def my-object (construct-object "foo"))
#+end_src

More compact approach:
#+begin_src janet
(def My-class
  (let [proto @{:my-getter (fn ‚Ä¶)
                :my-setter (fn ‚Ä¶)}]
    (fn [init] (table/setproto @{:_x init} proto))))

(def my-object (My-class "foo"))
#+end_src

Explicit ‚Äúfirst-class‚Äù class approach:
#+begin_src janet
(def My-class
  {:proto @{:my-getter (fn ‚Ä¶)
            :my-setter (fn ‚Ä¶)}
   :new   (fn [self init]
            (table/setproto @{:_x init} (self :proto)))})

(def my-object (:new My-class "foo"))
#+end_src

* Polymorphism

Tables and abstract types are the /only/ polymorphic values in Janet. [[Methods]]
can be defined on tables to enable polymorphism.

Some abstract types in Janet share the same methods and can therefore be
processed (at runtime) in a polymorphic way by a function or macro.
- e.g. ~core/file~ and ~core/stream~ are abstract types that both implement a
  ~:close~ method, so they both work with the ~with~ macro

Only a few functions in Janets standard library call methods. /Math/ and
/bitwise operator/ functions as well as /polymorphic compare/ are the only
built-in functions that can be overloaded with a method.
- /abstract types/ can override the standard comparison functions, tables need
  to use /polymorphic compare/ (see [[Comparators]])

Overloading examples:
#+begin_src janet
# math & bitwise operators:
(def addable @{:+ (fn [a b] (printf "adding %q %q" a b) 10)})
(+ addable "foo") # adding @{:+ <function ‚Ä¶>} "foo" => 10
(bxor @{:^ (fn [a b] a)} nil) #=> @{:^ <function ‚Ä¶>}

# polymorphic compare:
(def compare-on-value (fn [a b] (compare (a :_value) (b :_value))))
(def box-value (fn [value] @{:_value value
                             :compare compare-on-value}))

(compare (box-value 1) (box-value 2)) #=> -1
(compare (box-value 2) (box-value 2)) #=> 0
(compare (box-value 3) (box-value 2)) #=> 1
(compare= (box-value 2) (box-value 2)) #=> true

# no polymorphic compare by default in `sort`, needs a comparator fn:
(sort @[(box-value 1) (box-value 2)] compare<)
#=> @[@{:_value 1 :compare <function ‚Ä¶>}
#     @{:_value 2 :compare <function ‚Ä¶>}]
#+end_src


* Equality

Reference semantics on mutable data structures.

Value semantics on immutable data structures.

* Syntax / Special Forms
- https://janet-lang.org/docs/specials.html
- https://janet-lang.org/docs/syntax.html

** Bindings
#+begin_src janet
# Constant/immutable:
(def <name> <?meta ‚Ä¶> <?docstring> <value>)

# Variable:
(var <name> <?meta ‚Ä¶> <?docstring> <value>)

# update value (like an assignment):
(set <var/ds+key> <value>)
# can be used to set key-value pairs in mutables:
(def tab @{})  # tab is @{}
(set (tab :foo) "bar")  # tab is now @{:foo "bar"}
(def arr @[])  # arr is @[]
(set (arr 2) :foo)  # arr is now @[nil nil :foo]

# set value in a mutable indexed collection
(put <arr|table|buff> <key> <value>)
(put @[1 2 3] 1 :a) #=> @[1 :a 3]
# update value in a mutable indexed collection
(update <arr|table|buff> <key> <fn> <?arg ‚Ä¶>)
(update @[1 2 3] 2 |(* $ 2)) #=> @[1 2 6]

# update a numeric value
(++ <var>)
(-- <var>)

# Let macro:
(let [<<binding> <value> ‚Ä¶>]
  <form ‚Ä¶>)
# - equivalent to using `do` and (multiple) `def`s
#+end_src

** Functions
#+begin_src janet
# Anonymous function:
(fn <?name> [<param ‚Ä¶>] <body ‚Ä¶>)

# Function definition:
(defn <name> <?docstring>
  [<params ‚Ä¶>]
  <body ‚Ä¶>)
# just a macro that expands to:
(def <name> (fn [<param ‚Ä¶>] <body ‚Ä¶>))

# optional parameters:
(defn ‚Ä¶ [‚Ä¶ &opt <param>]
  # can have a default value:
  (default <param> <default-val>)
  ‚Ä¶)

# early return from a function:
(break <?value>)

(short-fn <body>)
|<body>  # shorthand
# same as:
(fn [$] (<form ‚Ä¶>))
# use `$` for arguments:
(|(* $ $) 3) #=> 9
(|(* $0 $1) 3 4) #=> 12
(|(apply * $&) 3 4 5) #=> 17

# For structs and tables, keys act as accessors (same as `in`):
({:a 1 :b 2} :b) #=> 2
(in {:a 1 :b 2} :b) #=> 2
# For vectors and arrays, indices can be used:
([:a :b :c] 2) #=> :c
(in [:a :b :c] 2) #=> :c
# `get` is like `in` but returns `nil` instead of throwing for out-of-range
(get <seq> <idx>)
#+end_src

** Control structures
#+begin_src janet
# like in Clojure:
(do
  <form ‚Ä¶>)
# to prevent creating a new local scope in a do block:
(upscope
  <form ‚Ä¶>)

# like in Clojure:
(if <condition>
  <when-true>
  <?when-false>)  # returns `nil` if false & else case is missing

(if-let ‚Ä¶)
(if-with ‚Ä¶)

# like in Clojure:
(when <condition>
  <when-true ‚Ä¶>)  # returns `nil` if false & else case is missing

(when-let ‚Ä¶)
(when-with ‚Ä¶)

# inversion of `when`:
(unless <condition>
  <when-false ‚Ä¶>)  # returns `nil` if false & else case is missing

# like in Clojure:
(cond
  <condition> <when-true>
  ‚Ä¶
  <? default>)  # returns `nil` if false & no default is provided

# Simple equality match:
(case <expr>
  <value> <when-expr=val>
  ‚Ä¶
  <? default>)  # returns `nil` if false & no default is provided
#+end_src

*** Pattern matching
#+begin_src janet
(match <expr>
  <pattern> <when-matched>
  ‚Ä¶
  <? default>)  # returns `nil` if false & no default is provided
#+end_src

*features:*
- simple values are matched by equality
- identifiers match anything and bind their name to the matched value
- the pattern ~_~ matches anything but /doesn‚Äôt/ create a binding of this name
- use ~& rest~ to bind all remaining items to ~rest~
- dynamic runtime values can be matched with ~(@ <identifier>)~
- arbitrary conditions can be included with the pattern ~(<ptn> <cond>)~

*gotchas:*
- tuple patterns actually match /prefixes/ of sequential structures
  - e.g. ~[_ _]~ matches a tuple length >= 2
  - stack tuple/array patterns by descending length to avoid matching on
    patterns with fewer elements
  - use e.g. ~([_ _ & r] (empty? r))~ to fix tuple length
- there is no distinction between tuples and arrays in patterns
- the value ~nil~ in associative data structures (key or value) causes the
  whole kv-pair to be removed and so matches depending on a particular
  table/struct pattern will fail
  - one solution is to use a different sentinel like ~@{}~ for an empty value
    (needs to be a globally unique value)

More infos:
- https://janet.guide/control-flow/

** Loops
#+begin_src janet
(while <condition>
  <form ‚Ä¶>
  ?(break))  # early exit (only innermost loop, avoid outside of macros)

# alias for (while true ‚Ä¶):
(forever <form ‚Ä¶>)

(for i <n-start> <n-end>
  <form ‚Ä¶>
  ?(break))
# variant where iteration variable `i` can be mutated in the loop:
(forv i <n-start> <n-end>
  <form ‚Ä¶>)

# loop over each item
(each x <coll>
  <form ‚Ä¶>)
# loop over each key
(eachk k <indexed coll>
  <form ‚Ä¶>)
# loop over key-value pairs
(eachp [k v] <indexed coll>
  <form ‚Ä¶>)

# repeatedly evaluate a form
(repeat <n> <form ‚Ä¶>)

(next <indexed coll>)  # returns the next index
(in <indexed coll> <index>)  # returns the value, given an index
#+end_src

Flexible general purpose loop macros:
#+begin_src janet
# for side-effects
# - (similar to Common Lisp loop macro)
(loop <head> & <body>)

# for data
# - like loop, but accumulates the loop body into an array
# - (similar to Clojure‚Äôs `for`)
(seq <head> & <body>)
#+end_src
- see https://janetdocs.com/loop / https://janetdocs.com/seq

Iterable data structures are e.g. *tuples*, *arrays*, *structs*, *tables*, *strings*,
*buffers*, *fibers*, *keywords* and *symbols*
- fibers (generators) iterate over their generated values
- strings iterate over the bytes of each character
- keywords and symbols behave identically to strings

Iteration is based on the function ~next~.
- ~each~ uses ~next~ to compute the keys and then calls ~in~ to look up the values
- ~eachk~ just iterates over the keys from ~next~
- ~map~, ~reduce~, ~filter~, etc. also use ~next~ under the hood
- custom ~JANET_ABSTRACT~ types can receive a custom implementation of ~next~

** Macros
#+begin_src janet
# Macro definition
(defmacro <name> [<param ‚Ä¶>]
  <form ‚Ä¶>)

# Macro expansion:
# once
(macex1 '(my-macro ‚Ä¶)
# fully
(macex '(my-macro ‚Ä¶)
#+end_src

AST transformation:
#+begin_src janet
(quote <form>)
'<form>  # shorthand

(quasiquote <form>)
~<form>  # shorthand

(unquote <form>)  # must be used in quasiquote
,<form>  # shorthand

(splice <coll>)
;<coll>  # shorthand
,;<coll>  # unquote-splicing

# can be used like a spreading operator in JS:
[;(range 100)]  # returns a tuple instead of an array
(+ ;(range 100))  # sums the first 100 nat. numbers
#+end_src

** Threading macros
#+begin_src janet
(->> <form ‚Ä¶>) # thread last
(-> <form ‚Ä¶>)  # thread first

# short-circuit threading
# - will return `nil` if an intermediate value is `nil`
(-?>> <form ‚Ä¶>)
(-?> <form ‚Ä¶>)

# threading with symbol position
# - use the symbol in a `form` to indicate threading position
(as-> <arg> <as-symbol>
      <form ‚Ä¶>)
(as?-> <arg> <as-symbol>
       <form ‚Ä¶>)
#+end_src

** Arithmetic
#+begin_src janet
# Basic arithmetic operators:
(+ <n ‚Ä¶>)  (* <n ‚Ä¶>)  (/ <n ‚Ä¶>)  (- <n ‚Ä¶>)
# Remainder operator:
(% <n> <m>)
#+end_src
- https://janet-lang.org/docs/numbers.html

** Comparators
#+begin_src janet
# Comparators:
(< <expr ‚Ä¶>) (<= <expr ‚Ä¶>) (= <expr ‚Ä¶>) (>= <expr ‚Ä¶>) (> <expr ‚Ä¶>)

# deep equality
(deep= <expr ‚Ä¶>)

# Polymorphic comparison:
(compare< ‚Ä¶) (compare<= ‚Ä¶) (compare= ‚Ä¶) (compare>= ‚Ä¶) (compare> ‚Ä¶)
#+end_src
- see also [[Polymorphism]]
- built-in functions that use polymorphic compare:
  ~zero?~, ~pos?~, ~neg?~, ~one?~, ~even?~, ~odd?~
- https://janet-lang.org/docs/comparison.html


* PEG (parsing expression grammar)

- https://janet-lang.org/docs/peg.html
- PEGs operate on /bytes/, not characters
- PEGs can be compiled /ahead of time/ using ~peg/compile~

** Grammars

Multiple patterns can be wrapped in a grammar (a Janet /struct/) and named
with keywords. The keywords can be referenced in all sub-patterns.
- each grammar *must* have a ~:main~ rule, the pattern that defines it
- PEG grammars can be mutually recursive
  - very recursive grammars can lead to stack overflow
  - some patterns may result in very slow loops if written poorly
  - the compiler can turn some recursion into iteration (tail-call opt.)
- nested grammars can access keys from outside

Example grammar:
#+begin_src janet
(def my-grammar
 '{:a (* "a" :b "a")
   :b (* "b" (+ :a 0) "b")
   :main (* "(" :b ")")})

(peg/match my-grammar "(bb)") # -> @[]
(peg/match my-grammar "(babbab)") # -> @[]
(peg/match my-grammar "(baab)") # -> nil
(peg/match my-grammar "(babaabab)") # -> nil
#+end_src

** API functions

To compile a PEG ahead of time (for reuse):
: (peg/compile <peg>)
- https://janetdocs.com/peg%2fcompile
- returns a compiled PEG object, which can also be used with ~peg/match~
- throws an error on invalid PEG code
- *call at the top level* to ensure execution during compilation

To match a PEG on a string:
: (peg/match <peg> <text>  <?start> <?args ‚Ä¶>)
- https://janetdocs.com/peg%2fmatch
- on match, returns an array of captured data, else returns ~nil~
- starts at first char unless an optional ~start~ index is provided

To find (the first index / all indexes) where the PEG matches:
: (peg/find <peg> <text>  <?start> <?args ‚Ä¶>)
: (peg/find-all ‚Ä¶)
- [[https://janetdocs.com/peg%2ffind]]
- returns an integer of the index or ~nil~ if not found

To replace (the first match / all matches) of a PEG:
: (peg/replace <peg> <repl.> <text>  <?start> <?args ‚Ä¶>)
: (peg/replace-all ‚Ä¶)
- [[https://janetdocs.com/peg%2freplace]]
- returns a new /buffer/ with the replaced match
- if no matches found, returns the input ~text~ in a new buffer
- the PEG does not need to make captures


** Patterns

- PEGs are always anchored to the beginning of the input (like ~^‚Ä¶~ in regex)
- all pattern repetition is implicitly [[https://www.regular-expressions.info/possessive.html][possessive]]
  - e.g. ~(any 1)~ is equivalent to ~^.*+~ in regex
  - however, some combinators like ~choice~ do backtrack

*Primitive patterns:*

| PEG          | Matches                             | Advances |
|--------------+-------------------------------------+----------|
| ~"str"~        | a literal string                    | ?        |
| ~n~            | an integer number n of chars        | n chars  |
| ~-n~           | matches if not that many chars      | not      |
| ~(range "AZ")~ | matches chars in a range            | 1 char   |
| ~(range "09")~ |                                     |          |
| ~(set "abcd")~ | matches any char in the arg. string | 1 char   |

- ~n~ matches /n/ bytes
- ~-n~ fails, if the match could be advanced /n/ characters
  - e.g. ~-1~ asserts that there is no more input left (like ~‚Ä¶$~ in regex to
    mark the end of a line)

*Combining patterns:*

| PEG                   | Meaning                                | RegEx   |
|-----------------------+----------------------------------------+---------|
| ~(sequence <ptn ‚Ä¶>)~    | match all in this order                | ~x y~     |
| / ~(* ‚Ä¶)~               |                                        |         |
| ~(choice <ptn ‚Ä¶>)~      | match one of (in order)                | ~x \vbar y~   |
| / ~(+ ‚Ä¶)~               |                                        |         |
|-----------------------+----------------------------------------+---------|
| ~(any <ptn>)~           | match 0 or more rep. of                | ~x*~      |
| ~(some <ptn>)~          | match 1 or more rep. of                | ~x+~      |
| ~(between n m <ptn>)~   | match n ~ m rep. of (both incl.)       | ~x{n, m}~ |
| ~(opt <ptn>)~           | match 0 or 1 rep. of                   | ~x?~      |
| / ~(? ‚Ä¶)~               |                                        |         |
| ~(at-least n <ptn>)~    | match at least n rep. of               | ~{n,}~    |
| ~(at-most n <ptn>)~     | match at most n rep. of                | ~{,m}~    |
| ~(repeat n <ptn>)~      | match exactly n rep. of                | ~{n}~     |
| / ~(n ‚Ä¶)~               |                                        |         |
|-----------------------+----------------------------------------+---------|
| ~(not <ptn>)~           | match if not matches                   | ~[^x]~    |
| / ~(! ‚Ä¶)~               |                                        |         |
| ~(if <cond> <ptn>)~     | match only if cond. matches            |         |
| ~(if-not <cond> <ptn>)~ | match only if cond. not matches        |         |
|-----------------------+----------------------------------------+---------|
| ~(look <offset> <ptn>)~ |                                        |         |
| / ~(> ‚Ä¶)~               |                                        |         |
| ~(to <ptn>)~            | match up to pattern (not including it) |         |
| ~(thru <ptn>)~          |                                        |         |
| ~(backmatch <?tag>)~    | if tag: match against tagged capture   |         |
|                       | / else: match against last capture     |         |
|                       | / (only if it is untagged)             |         |

*Built-in patterns*

See Docs:
- https://janet-lang.org/docs/peg.html#Built-in-patterns

: :d[+/*]  # ASCII digit
: :a[+/*]  # ASCII letter
: :s[+/*]  # ASCII whitespace char
: :w[+/*]  # ASCII digit or letter (word char)
: :h[+/*]  # hex char
: :D | :A | :S | :W | :H  # negated ASCII/hex patterns
- whitespace includes newlines ~"\n"~

** Captures

| PEG                            | Meaning                                 |
|--------------------------------+-----------------------------------------|
| ~(capture <ptn> <?tag>)~         | capture all text if pattern matches     |
| / ~(<- ‚Ä¶)~                       |                                         |
| ~(replace <ptn> <subst> <?tag>~) | replaces a capture from pattern         |
| / ~(/ ‚Ä¶)~                        | / with (f capture(s)) or a new value    |
| ~(accumulate <ptn> <?tag>)~      | captures a string as the concatenation  |
| / ~(% ‚Ä¶)~                        | / of all captures in pattern            |
| ~(constant <const> <?tag>)~      | captures/returns a Janet constant       |
|                                | / useful for parsing                    |
| ~(group <ptn> <?tag>)~           | puts captures into an array             |
| ~(position <?tag>)~              | capture the current index               |
| / ~($ ‚Ä¶)~                        |                                         |
| ~(unref <ptn> <?tag>)~           | scope tagged captures                   |
|                                | / e.g.to backmatch in nested patterns   |
| ~(cmt <ptn> <fun> <?tag>)~       | invoke (fun capture(s)), expr fails     |
|                                | / if fun returns false or nil           |
| ~(backref <tag> <?tag>)~         | duplicate last capture with given tag   |
| ~(-> ‚Ä¶)~                         | / match fails if no capture exists      |
| ~(argument <n> <?tag>)~          |                                         |
| ~(number <ptn> <?base> <?tag>)~  | capture a number parsed from match      |
| ~(uint <num-bytes> <?tag>)~      |                                         |
| ~(uint-be <num-bytes> <?tag>)~   |                                         |
| ~(int <num-bytes> <?tag>)~       |                                         |
| ~(int-be <num-bytes> <?tag>)~    |                                         |
| ~(lenprefix <n> <ptn> <?tag>)~   |                                         |
| ~(drop <ptn>)~                   | ignores (drops) all captures from patt. |
| ~(error <?ptn>)~                 | throws a Janet error                    |

- ~(quote ‚Ä¶) / '‚Ä¶~ can be used instead of ~(capture ‚Ä¶)~
- ~cmt~ stands for ‚Äúmatch-time capture‚Äù (see [[http://www.inf.puc-rio.br/~roberto/lpeg/][LPEG]] (Lua))
- ~backref~ is especially useful when combined with ~cmt~ to re-capture a
  capture from a tag to use as an argument for its function
  - e.g. ~(cmt (* (-> :tag-name) ‚Ä¶) ,my-fun)~ ‚Äì the capture from ~:tag-name~ as
    well as all other captures from ~*~ will be passed as args to ~my-fun~

* Fibers

/Fibers/ are *lightweight cooperatively scheduled threads* for *single-core
*asynchronous* programming. They allow to stop (through ~yield~) and ~resume~
execution of a process, enabling multiple returns.
- fibers are *iterable* (like generators in JavaScript)
- a fiber has its own environment and its own call stack

Fibers can be used to implement /schedules/, /generators/, /iterators/,
/live-debugging/ and /error handling/.

Janets [[Event Loop]] and [[Error handling]] is built on top of fibers. Every Janet
program has a default fiber which contains the programs environment (see
[[Dynamic Bindings]]).

The status signals of a fiber are ~:alive~, ~:dead~, ~:debug~, ~:new~, ~:pending~ and
~:user0~ ‚Äì ~:user9~.

When ~resume~ is called on a fiber, it will only return when that fiber either
/returns/, ~yield~'s, /throws/ an error, or otherwise emits a /signal/.
- ~resume~ throws an error if the fiber is ~:dead~

More infos:
- https://janet-lang.org/docs/fibers/index.html

** API

Create a fiber:
: (fiber/new <function> <?signalmask>)
- the ~function~ argument must have zero arity
- the optional ~signalmask~ is a collection of flags for checking what kinds of
  signals to trap and return via ~resume~
  - any un-trapped signals are propagated to the previous calling fiber
  - use ~:e~ to ‚Äúcatch‚Äù exceptions from an ~error~

Yield a value to the parent fiber:
: (yield <?x>)

Yield the next value of a fiber, optionally passing a value back to the
~yield~ call:
: (resume <fiber> <?x>)

Inspect the status of a fiber:
: (fiber/status <fiber>)

Get the last value returned or signaled from a fiber:
: (fiber/last-value <fiber>)

Create a fiber to yield multiple values:
: (coro <body ‚Ä¶>)
- this is the same as calling ~(fiber/new (fn [] <body ‚Ä¶>) :yi)~
- ‚Äúcoro‚Äù is short for [[*Coroutines][‚Äúcoroutine‚Äù]]

Get the current environment table:
: (curenv <?n>)
- same as ~(fiber/getenv (fiber/current))~

Propagate a signal (? ~x~) from a ~fiber~ to the current fiber:
: (propagate <x> <fiber>)
- if ~fiber~ is in a state that can be resumed, resuming the current fiber
  will first resume ~fiber~
- can be used to re-raise an error without losing the original stack trace

** Signals

/Signals/ are used in fibers to differentiate different kinds of returns. They
can be intercepted by parent fibers.

To raise a /signal/ with payload ~x~:
: (signal <what> <x>)

Named signals:

| Signal      | Description              |
|-------------+--------------------------|
| ~:yield~ / ~:y~ | For yielded values       |
| ~:error~ / ~:e~ | For exceptions           |
| ~:debug~ / ~:d~ | For interactive debugger |

User signals:

| Signal           | Description                            | resumable? |
|------------------+----------------------------------------+------------|
| ~:0~               | From ‚Äúearly return‚Äù macro              | no         |
| ~:1~               |                                        | no         |
| ~:2~               |                                        | no         |
| ~:3~               |                                        | no         |
| ~:4~               |                                        | no         |
| ~:5~               |                                        | yes        |
| ~:6~               |                                        | yes        |
| ~:7~               |                                        | yes        |
| ~:8~ -> ~:interrupt~ | interrupt one fiber from another fiber | yes        |
| ~:9~ -> ~:await~     | Something with async and event loop    | yes        |


** Error handling

Fibers are used internally by Janet for error handling
- when an ~error~ is thrown, control is returned to the parent fiber
- the ~try~ macro wraps its body in a new fiber, ~resume~'s the fiber and checks
  if it results in an error, in which case the error clause is evaluated

#+begin_src janet
# evaluates to nil and prints "got error: 1"
(try
  (error 1)
  ([err] (print "got error: " err)))

# Evaluates to 6 - no error thrown
(try
  (+ 1 2 3)
  ([err] (print "oops")))
#+end_src

** Generators
A fiber can be used to make a generator by /yielding/ from it.

Janet generators are similar to JS generators, but they don‚Äôt need a special
~function*~ keyword and can ~yield~ from a call to any other normal function.
- ~yield~ returns control from a /fiber/ instead of a /function/ (like in JS)

Janet generators will throw an error if the resumed fiber has already returned
(unlike JS generators, which return ~undefined~ on the ~.next()~ call).

#+begin_src janet
# generators can be normal (0-arity) functions that `yield` intermediate values
(defn my-generator []
  (yield <expr>))

# creating a fiber from a generator
(def my-fiber (fiber/new my-generator) <options>)

# fibers are iterable
(each value my-fiber
  (print value))  # ignores the final return value

#+end_src

** Coroutines

Use ~coro~ to create a /coroutine/, which is like a [[*Generators][generator]], but can receive a
value back when ~yield~'ing.

** Early return

Use the ~prompt~ or the ~label~ macro for early return in functions.

To set up a checkpoint that can be returned to:
: (prompt <tag> <?body ‚Ä¶>)
- ~tag~ should be a value used in ~return~, like a keyword
- can be returned to in called functions

To set a label point that is lexically scoped:
: (label <name> <?body ‚Ä¶>)
- ~name~ should be a symbol that will be bound to the label
- cannot be returned to in called functions

Usage:
#+begin_src janet
(defn my-function []
  (prompt :a
          (print "before return")
          (return :a 42)
          (print "will not execute")))

(defn my-function []
  (label result
         (print "before return")
         (return result 42)
         (print "will not execute")))
#+end_src

** Dynamic Bindings

/Dynamic bindings/ are /fiber-local/ and available to all functions. They are
set by pushing to a /stack of values/ corresponding to the stack of fibers
that each have their own view of the current dynamic variables and pop off
the stack when the fiber completes.

| Binding | Description                                        |
|---------+----------------------------------------------------|
| ~*out*~   | default destination for functions like ~print~ & co. |
| ~*args*~  | arguments passed to the program (e.g. via shell)   |

To set some dynamic bindings to run in a new fiber:
: (with-dyns [<dynvar> <new-value>] <?body ‚Ä¶>)
- the fiber will not mask errors or signals

To set a dynamic binding:
: (setdyn <dynvar> <value>)
- returns the ~value~

To get a dynamic binding:
: (dyn <key> <?default>)
- conventionally named by keyword (e.g. ~:out~ for ~*out*~)
- if no binding found, returns the ~default~ value (or ~nil~)

* Environment

Environments in Janet are local to each fiber.

Different flags can be provided to specify what kind of environment a new
fiber should have:
- none (default): no/empty environment
- ~:i~ (inherit): the exact same environment as the code creating it
- ~:p~ (prototype): a new environment table whose prototype is equal to the
  parent environment

During [[Images][compilation]], Janet produces an environment as a result of executing all
the /top-level statements/ the a source file. It is a table of bindings and
metadata to values.

* Event Loop

The /event loop/ is a powerful /concurrency model/ for Janet. It is a little
*scheduler* in the background of the Janet runtime. All programs are wrapped in
an implicit loop that will run until all tasks are complete.
- most event loop functionality can be found in the [[https://janet-lang.org/api/ev.html][Event Module]] (~ev/~), but
  other functions may also interact with the event loop
- it is especially useful where there are many concurrent IO-bound tasks

Functions that may take a long time to complete will ‚Äúyield to the event
loop‚Äù, meaning they‚Äôll raise a /user signal 9/. Janet catches that signal at
the top-level of its runtime where it performs the desired effect and
resumes the fiber once it completes.

More infos:
- https://janet-lang.org/docs/event_loop.html
- https://janet.guide/concurrency-and-coroutines/

** API

Use ~ev/call~ or ~ev/go~ (more general way) to create new tasks.

To call a function asynchronously:
: (ev/call <fn> <?args ‚Ä¶>)
- returns a fiber that is scheduled to run the function
- the fiber will be resumed as soon as the main fiber yields to the event loop
- implemented in terms of ~ev/go~

To put a fiber on the event loop to be resumed later:
: (ev/go <fib> <?val> <?supervisor>)
- returns the fiber
- functions are wrapped with ~fiber/new~ first
- an optional ~val~ can be provided to resume with (default: ~nil~)
- an optional ~core/channel~ can be provided as a ~supervisor~ (defaults to
  inherit the current supervisor)

To concisely run a series of forms in a new task:
: (ev/spawn <?body ‚Ä¶>)
- macro for ~(ev/go (fn [] ;body))~

To cancel a suspended fiber in the event loop:
: (ev/cancel <fib> <err>)

To get the currently executing task:
: (fiber/root)

To suspends the current fiber (without blocking the event loop):
: (ev/sleep <sec>)

[[Channels]]:

To create a new channel:
: (ev/chan <?capacity>)

To read from a channel:
: (ev/take <channel>)
- suspends the current fiber if no value is available

To write a value to a channel:
: (ev/give <channel> <value>)
- suspends the current fiber if the ~channel~ is full
- returns the ~channel~ if write succeeds, ~nil~ otherwise

[[Streams]]:

To create a stream from a file:
: (os/open <path> <?flags> <?mode>)
- returns a new stream
- creates new file if it doesn‚Äôt exist
- see [[https://janetdocs.com/os%2fopen][docs]] for optional ~flags~ and ~mode~
  - ~:r~ to open for reading
  - ~:w~ to open for writing

To read up to ~n~ bytes into a /buffer/ asynchronously from a ~stream~:
: (ev/read <stream> <n> <?buffer> <?timeout>)
- use ~:all~ for ~n~ to read until the end of stream

To close a ~stream~:
: (ev/close <stream>)

** Tasks / root fibers

Fibers on the event loop are called /root fibers/ or *tasks* in Janet. A root
fiber will be automatically ~resume~'d when an event (or sequence of events)
that it is waiting for occurs.
- root fibers should generally not be resumed manually (which is only possible
  with ~ev/go~)
- a default Janet program has a single task that will run until complete

[[*Channels][Channels]] and [[*Streams][Streams]] are Janets abstractions to /communicate/ between tasks.
- both work as queues (FIFO), but operate on different kinds of data

** Channels

/Channels/ allow for communication between tasks by sending any Janet value as
*messages*. They only work inside a /thread/, not between threads.
- most useful for things like /internal queues/ and /between-task communication/
  (prefer /streams/ for everything else)

A channel is a /bounded queue/, that can be *read from* and *written to*
/asynchronously/. Reads suspend execution until a value is available, and
writes suspend execution if the queue is full, resuming once another fiber
~take~'s a value off the queue.

**** Supervisor channel
See https://janet.guide/concurrency-and-coroutines/


** Streams

/Streams/ are wrappers around file descriptors and operate on *streams of
bytes*. They can communicate *across threads*, processes and across the
network.

The /Stream API/ is an abstraction over *byte buffers* that can be read from or
written to without blocking the program.
- e.g. to asynchronously read and write to files or TCP sockets

* Modules
Importing a module actually means importing the [[Environment][environment]] which is the
result of executing all the top-level statements of the source file and
contains names for all the bindings with corresponding values.
- *private bindings* that are not exposed in the env. can be specified with ~def-~
  , ~var-~ , ~defn-~ and ~defmacro-~ , similar to Clojure.
- by default, modules will not re-import the imports of the modules they
  import (because those bindings are automatically set to ~:private true~ in the
  imported env) ‚Äì this can be changed by setting ~:export~ to ~true~

Modules are imported by providing a *path* argument without the ~.janet~
extension.
- if the file doesn‚Äôt exist, Janet will look for =<path>/init.janet=
- ~.jimage~ files (for precompiled [[Images][images]]) and ~.so~ / ~.dll~ files (for precompiled
  native libraries) will also be recognized from a path

If a path is not provided, Janet will try to load from the *module load path*,
which defaults to =/usr/local/lib/janet= and can be overridden with the
~JANET_PATH~ environment variable.

** API

To import a source file (can use all public bindings):
: (use <path>)

To import a library (can use all public bindings with a prefix):
: (import <path>)
: (import <path> :as <alias>)
: (import <path> :prefix <custom-prefix>)
- e.g. for ~:as x~ , bindings look like: ~x/foo~
- e.g. for ~:prefix "x--"~ , bindings look like: ~x--foo~

Function versions to import at runtime:
: (import* ‚Ä¶)
: (import* ‚Ä¶ :prefix "")  # like (use ‚Ä¶)
- pass ~:fresh true~ to bypass module cache (better for interactive dev.)

To compute the module‚Äôs environment without creating names in the current env:
: (require <path>)

* Stdlib
** Environment
To inspect documentation on a symbol:
: (doc <symbol>)
- type e.g. ~(doc "string/")~ to find all functions related to a module

** IO
*** Print/Logs
Print:
: (print <form>)
: (prin <form>)  # without trailing newline
: (print)        # just a newline

Print formatted:
: (printf "‚Ä¶ %q ‚Ä¶" <form>)

Pretty-print:
: (pp <form>)

*** Files/resources
To load a file:
: (slurp "<path>")

To write to a file:
: (spit "<path>")
- may or may not exist

*Explicit file handling* (blocking)
- see [[Streams]] for non-blocking/asynchronous file handling

: (file/open "<path>" <?mode>)
- returns a ~core/file~ abstract type
- creates new file if it doesn‚Äôt exist
- see [[https://janetdocs.com/os%2fopen][docs]] for optional ~flags~ and ~mode~
  - ~:r~ to open for reading
  - ~:w~ to open for writing

: (file/read <file> <what> <?buffer>)

: (file/close <file>)

*** Network

Open a connection to communicate with a server
: (net/connect <host> <port>  <?type> <?bindhost> <?bindport>)
- returns a ~core/stream~ abstract type

** System
Suspend program for /n/ seconds
: (os/sleep <seconds>)

Exit from a Janet app with optional ~exit-code~:
: (os/exit <?exit-code>)
- can use bash exit codes like ~0~ and ~1~

Get or append ~n~ bytes of good quality random data provided by the OS:
: (os/cryptorand <n> <?buff>)
- returns a new buffer or ~buff~.

** Functions
Like in Clojure:
: (partial <f> <args ‚Ä¶>)
: (comp <f ‚Ä¶>)

** Primitive DS
*** Numbers
To parse a number from a string:
: (scan-number <string> <?base>)

*** Booleans
Checks for truthyness:
: (truthy? <expr>)

** Indexed/sequential DS
*** Common

Select elements:
: (first <xs>)
: (last <xs>)

Get the number of elements:
: (length <xs>)

Extract a sub-range:
: (slice <xs> <?start> <?end>)
- see also: ~tuple/slice~

Higher-order sequence functions (no mutation):
: (map <fn> <xs ‚Ä¶>)
: (filter <pred> <xs>)
: (reduce <fn> <init> <xs>) (reduce2 <fn> <xs>)
: (partition <n> <xs>)

Map & concat:
: (mapcat <fn> <xs>)
- uses ~array/concat~ to concatenate
- returns a new array (mutable)

Create a table from two arrays/tuples:
: (zipcoll <keys> <vals>)
- returns a new table (mutable)

Create an array of numbers from ~start~ (incl.) to ~end~ (excl.):
: (range <end>)
: (range <start> <end> <?step>)

Interleave collections (like in Clojure):
: (interleave <coll ‚Ä¶>)
- returns a new array

Interpose a ~sep~ element between elements of the indexed sequence:
: (interpose <sep> <xs>)
- returns a new array

Reverse the elements:
: (reverse <xs>)
- returns a new array

*** Tuple

To take a sub-seq of an array/tuple from ~start~ (incl.) to ~end~ (excl.) index:
: (tuple/slice <seq> <?start> <?end>)
: (tuple/slice @[1 2 3])  # creates an immutable copy
- https://janetdocs.com/tuple%2fslice

*** Array

To insert an element to the end of an array (mutation):
: (array/push <arr> <elem>)
- https://janetdocs.com/array%2fpush
- returns ~arr~

Remove the last value from array and return it:
: (array/pop <arr>)
- returns ~nil~ if ~arr~ is empty

Concatenate a variable number of elements/arrays/tuples into the first array:
: (array/concat <arr> <x ‚Ä¶>)
- mutates ~arr~!

Create a new array of ~count~ elements, all set to ~value~ (default: ~nil~)
: (array/new-filled <count> <?val>)
- returns a new array

*** Buffer

Append bytes to a buffer:
: (buffer/push-byte <buff> <byte ‚Ä¶>)

Remove last ~n~ bytes from a buffer:
: (buffer/popn <buff> <n>)

*** String

Trim leading and trailing whitespace:
: (string/trim <string> <?set>)
- optionally consider only chars in ~set~ to be whitespace

Check for a prefix in a string:
: (string/has-prefix? <prefix-str> <string>)

To create a formatted string:
: (string/format <string> <value ‚Ä¶>)
- https://janetdocs.com/string%2fformat
- use ~"%q"~ for data structures

To upper-case:
: (string/ascii-upper <string>)

To convert bytes (e.g. from string iteration) to a string:
: (string/from-bytes <byte-vals ‚Ä¶>)

Join an array of strings with optional separator string:
: (string/join <str-array> <?sep>)

To reverse (the /bytes/ of) a string/buffer:
: (string/reverse <string>)
- will reverse all bytes from UTF-8 encoding ‚Üí *breaks unicode chars!*

Examples:
#+begin_src janet
(string/format "Hello %s, you are %02d years old." "Peter" 35)
#=> "Hello Peter, you are 35 years old."
(string/format "This %q is an expression." [1 2 3])
#=> "This (1 2 3) is an expression."
(map string/from-bytes "hello")
#=> @["h" "e" "l" "l" "o"]
#+end_src

** Associative DS
*** Common

Return an array of key-value pairs from a table/struct:
: (kvs <dict>)

Merge multiple tables/structs into one new table:
: (merge <coll ‚Ä¶>)
- similar to Clojure: later values with equal keys replace earlier ones
- returns a new table

*** Table

Associate a key with a value:
: (put <table/‚Ä¶> <key> <val>)

Convert to struct:
: (table/to-struct <tbl>)

*** Struct

** Exceptions
To throw an exception
: (error <string>)

To catch an exception
: (try
:   <body>
:   ([<error-binding> <?fiber-binding>]
:     <catch-expr>))
- ~fiber-binding~ is an optional binding for the fiber wrapping the ~body~

#+begin_src janet
(try ‚Ä¶
  ([e] (print e)))
#+end_src

** Math/Arithmetic
- https://janet-lang.org/api/math.html
- from the C library ~<math.h>~

Constants:
: math/int-min
: math/int-max
: math/int32-min
: math/int32-max
: math/nan  # not a number
: math/inf  # positive infinity
: math/-inf # negative infinity
: math/pi   # œÄ
: math/e    # Eulers number (base of natural log)

Return the next representable floating point value after ~x~ in the direction
of ~y~:
: (math/next <x> <y>)
- returned number may appear the same as ~x~ but this is due to printing
  truncation (see examples: https://janetdocs.com/math/next)

*** Random numbers

*Note:* to get a new and different number on each run of the program, set
the /seed/ to e.g. ~(os/cryptorand 8)~.

Return a uniformly distributed random number between 0 and 1:
: (math/random)
- sequence will repeat after restart of Janet (same seed)

Set the seed for the RNG:
: (math/seedrandom <seed>)
- ~seed~: integer or buffer
- e.g. for ~math/random~

Create a pseudo-random number generator (RNG) with optional ~seed~:
: (math/rng <?seed>)
- default seed is ~0~
- do *not* use for cryptography

Extract a random number in range ~[0, 1)~ from a RNG:
: (math/rng-uniform <rng>)

Extract an integer in range ~[0, max)~ from a RNG:
: (math/rng-int <rng> <?max>)

Get ~n~ bytes from a RNG and put them in a buffer:
: (math/rng-buffer <rng> <n> <?buff>)
- creates a new buffer if none provided, otherwise appends to ~buff~
- returns the buffer

*** Bit-wise operaors
- like in C or Java
- all inputs have to be integers

: (bnot x)

: (band & xs)
: (bor & xs)
: (bxor & xs)

Return value of ~x~ bit shifted left/right by the sum of all ~shifts~:
: (blshift x & shifts)
: (brshift x & shifts)
: (brushift x & shifts)
- in ~brushift~, the sign of ~x~ is not preserved
  -> always positive for positive shifts

Examples:
#+begin_src janet
(bnot 0) #=> -1
(bnot 1) #=> -2

(band 2r101 2r110) #=> 4  (100)
(bor 2r1 2r10) #=> 3  (11)
(bxor 2r101 2r11) #=> 6  (110)

(blshift 2r11 1) #=> 6  (11 -> 110)
(blshift 2r11 2) #=> 12  (11 -> 1100)

(brshift 2r110 1) #=> 3  (110 -> 11)
(brshift 2r1100 2) #=> 3  (1100 -> 11)
#+end_src

** Compilation
To compile an /abstract syntax tree/ into a function (with no args):
: (compile <ast> ‚Ä¶)
- https://janetdocs.com/compile
- https://janet.guide/macros-and-metaprogramming/
* Janet C API
- https://janet-lang.org/capi/index.html
- https://janet-lang.org/capi/writing-c-functions.html
- https://janet.guide/xenofunctions/

** Native Janet modules in C

Build and install native modules:
: $ jpm install --local --verbose

This will generate the files in =jpm_tree/lib/=:
- =set.a= ‚Üí *static library* file /(archive)/
  - contains object files that can be linked directly at compile time
  - self-contained and independent of external deps
  - will be linked in if a native executable gets compiled via ~jpm~
- =set.so= ‚Üí *dynamic library* file /(shared objects)/
  - can be compiled, linked and loaded at runtime
  - will be linked in if the lib is imported in a REPL session or if a
    script that depends on it is executed with the ~janet~ interpreter
- =set.meta.janet=
  - contains metadata ~jpm~ uses in order to statically link =set.a=

In =project.janet=:
#+begin_src janet
# ‚Ä¶
(declare-native
  :name "mylib"
  :source ["mylib.c"])
#+end_src

In =mylib.c=:
#+begin_src C
#include <janet.h>

static Janet cfun_foo(int32_t argc, Janet *argv) {
  // Assert how many arguments should be passed in:
  // Exactly two arguments:
  janet_fixarity(argc, 2);
  // One, two, or three arguments:
  janet_arity(argc, 1, 3);
  // At least two arguments:
  janet_arity(argc, 2, -1);

  // ‚Ä¶

  // Return a Janet value, e.g. `nil`:
  return janet_wrap_nil();
}

static JanetReg cfuns[] = {
  {"foo", cfun_foo, "some docstring"},
  {NULL, NULL, NULL}
};

JANET_MODULE_ENTRY(JanetTable *env) {
  janet_cfuns(env, "foo", cfuns);
}
#+end_src

~JANET_MODULE_ENTRY~ is a macro that expands to something like this:
#+begin_src C
JanetBuildConfig _janet_mod_config(void) {
  // returns the current version of Janet
  // - Janet will check if that version matches when it dynamically
  //   loads the native module
  return ((JanetBuildConfig){ 1, 27, 0, (0 | 0) });
}

void _janet_init(JanetTable *env) {
  // takes a freshly allocated env table as input and
  // mutates the table, installing all env entries for the module
  janet_cfuns(env, "foo", cfuns);
}
#+end_src


*** Example

In =project.janet=:
#+begin_src janet
(declare-project :name "set")

(declare-native
  :name "set"
  :source ["set.c"])
#+end_src

In =set.c=:
#+begin_src C
#include <janet.h>

static Janet cfun_hello(int32_t argc, Janet *argv) {
  janet_fixarity(argc, 0);
  printf("hello world\n");
  return janet_wrap_nil();
}

static JanetReg cfuns[] = {
  {"hello", cfun_hello, "(hello)\n\nprints hello"},
  {NULL, NULL, NULL}
};

JANET_MODULE_ENTRY(JanetTable *env) {
  janet_cfuns(env, "set", cfuns);
}
#+end_src

In =main.janet=:
#+begin_src janet
(import set)

(set/hello)
#+end_src

Build and install the native module:
: $ jpm install --local --verbose

To use the *dynamic library*:

Run the application:
: $ jpm -l janet main.janet

Load the module in Janet REPL:
: $ jpm -l repl
: repl:1:> (use set)
: @{_ @{:value <cycle 0>} hello @{:private true} :macro-lints @[]}
: repl:2:> hello
: <cfunction set/hello>



* Code Examples

- [[https://github.com/saikyun/freja][freja]] (text editor)

* Libraries

Data structures
- [[https://github.com/andrewchambers/janet-utf8/][janet-utf8]] (Unicode representation for strings)
- [[https://github.com/ianthehenry/jimmy][jimmy]] (bindings for [[https://github.com/arximboldi/immer][immer]], a library for immutable data structures)
  - enables *sets* in Janet
- [[https://github.com/MikeBeller/janet-set][janet-set]] (another implementation for set types)

Web
- [[https://joy.swlkr.com][Joy]] (web framework)

UI
- [[https://github.com/kamisori/jaylib/][jaylib]] (Raylib bindings)
- [[https://github.com/janet-lang/janetui][janetui]] (libui bindings)

Parser
- [[https://github.com/pyrmont/remarkable][remarkable]] (CommonMark parser written in Janet)
- [[https://github.com/pyrmont/markable][Markable]] (bindings for GitHubs fork of the CommonMark lib)
