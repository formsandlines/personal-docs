#+title: Docs/Janet

* General information

- https://janet-lang.org
- [[https://github.com/ahungry/awesome-janet][Awesome Janet]]
- [[https://janetdocs.com/][JanetDocs]]

Features:
- implemented mostly in standard *C99*
  - direct interop with C via /abstract types/ and C functions
  - dynamically load C libraries
- runs on /Windows/, /Linux/, /macOS/
- easily /portable/ and /embeddable/
- built-in /Parsing Expression Grammars/ (PEGs)
- exports standalone executables with companion build tool *jpm*

Use-cases:
- system scripting
- embedding into other programs
- rapid prototyping
- dynamic systems
- text-wrangling (PEGs, etc.)

* Installation & Usage

Installation:
: $ brew install janet

Start REPL:
: $ janet

Load/run a Janet script:
: $ janet myscript.janet
- this will run the ~main~ function of the script, if there is any
- ~main~ must be defined with variadic args, like ~[&]~

Compilation to native code, using ~jpm~:
: ?


** Images

To create an image from a script:
: $ janet -c myscript.janet myscript.jimage

To create an image from the REPL:
: > (def image (make-image (curenv)))
: > (spit "repl.jimage" image)

This will create an image, which consists of a single marshalled value (in
the form of a Janet table ~@{…}~), which is the input program’s environment.
This env contains all top-level definitions with their symbols as keys and
the corresponding marshalled values as well as some metadata.
- [[https://janet.guide/compilation-and-imagination/][Source]]

To inspect the contents of the image from the REPL:
: > (load-image (slurp "myscript.jimage"))

Load an image file into Janet:
: $ janet -i myimage.jimage
- deserializes the env table in the image, looks up a symbol ~main~ there and
  (if found), executes that function

* Packages

To install a package:
: $ sudo jpm install pkg-name

Installation directory: =/opt/homebrew/Cellar/janet/<version>/lib=

To list installed packages:
: $ jpm list-installed

To list available packages:
: $ jpm list-pkgs [name]

To update jpm:
: $ sudo jpm install jpm

* Editor support

** (Neo)Vim

Syntax support:
- https://github.com/janet-lang/janet.vim

Interactive evaluation with Conjure:
- https://github.com/Olical/conjure/wiki/Quick-start:-Janet-(netrepl)

Needs [[https://github.com/janet-lang/spork/#networked-repl][spork/netrepl]]:
: $ jpm install spork
To start the netrepl:
: $ janet -e "(import spork/netrepl) (netrepl/server)"
Then start Vim, it will automatically connect to Conjure.

** Emacs

~janet-mode~ Janet mode
- https://github.com/ALSchwalm/janet-mode

~ijanet-mode~ Interactive Janet mode
- https://github.com/SerialDev/ijanet-mode

~inf-janet~ Inferior lisp Janet mode
- https://github.com/velkyel/inf-janet

* Data types

Janet has separate mutable and immutable data structures
- no structural sharing in immutables like in Clojure
- all are passed by reference internally (C pointer)

| data type          | immutable                             | mutable  |
|--------------------+---------------------------------------+----------|
| atom               | number, keyword, symbol, nil, boolean |          |
| closure            |                                       | function |
| coroutine          |                                       | fiber    |
| byte array         | string                                | buffer   |
| random-access list | tuple                                 | array    |
| hash table         | struct                                | table    |

- [[https://janet.guide/values-and-references/][Source]]

** Built-in types:
#+begin_src C
typedef enum JanetType {
  JANET_NUMBER,
  JANET_NIL,
  JANET_BOOLEAN,
  JANET_FIBER,
  JANET_STRING,
  JANET_SYMBOL,
  JANET_KEYWORD,
  JANET_ARRAY,
  JANET_TUPLE,
  JANET_TABLE,
  JANET_STRUCT,
  JANET_BUFFER,
  JANET_FUNCTION,
  JANET_CFUNCTION,
  JANET_ABSTRACT,
  JANET_POINTER
} JanetType;
#+end_src

#+begin_src janet
(type <expr>)  # to check the type of an expression

(struct <item …>) = {…}
(table <item …>) = @{…}

(tuple <item …>) = […]
(array <item …>) = @[…]

(string <string …>) = "…"
(buffer <string …>) = @"…"

(keyword <string …>) = :…
(symbol <string …>) = '…

(fiber/new <fn>) = <fiber …>
#+end_src
- ~nil~ is not allowed as a key in tables or structs

Numeric literals:
#+begin_src janet
0
+0.0
-10_000
16r1234abcd
0x23.23
1e10
1.6e-4
7r343_111_266.6&+10 # a base 7 number in scientific notation.
# evaluates to 1.72625e+13 in base 10
#+end_src

** Extended abstract types:
- ~core/rng~ -> pseudorandom number generator
- ~core/socket-address~
- ~core/process~
- ~core/parser~ -> parser used by Janet to parse Janet code
- ~core/peg~ -> parsing expression grammar
- ~core/stream~ and
- ~core/channel~ -> concurrent communication primitives
- ~core/lock~ and
- ~core/rwlock~ -> multithreading stuff
- ~core/ffi-signature~,
- ~core/ffi-struct~ and
- ~core/ffi-native~ -> parts of an experimental FFI module
- ~core/s64~ and
- ~core/u64~ -> boxed 64-bit integer types

* Equality

Reference semantics on mutable data structures.

Value semantics on immutable data structures.

* Syntax / Special Forms
- https://janet-lang.org/docs/specials.html
- https://janet-lang.org/docs/syntax.html

** Bindings
#+begin_src janet
# Constant/immutable:
(def <name> <?meta …> <?docstring> <value>)

# Variable:
(var <name> <?meta …> <?docstring> <value>)

# update value (like an assignment):
(set <var/ds+key> <value>)
# can be used to set key-value pairs in mutables:
(def tab @{})  # tab is @{}
(set (tab :foo) "bar")  # tab is now @{:foo "bar"}
(def arr @[])  # arr is @[]
(set (arr 2) :foo)  # arr is now @[nil nil :foo]

# set value in a mutable indexed collection
(put <arr|table|buff> <key> <value>)
(put @[1 2 3] 1 :a) #=> @[1 :a 3]
# update value in a mutable indexed collection
(update <arr|table|buff> <key> <fn> <?arg …>)
(update @[1 2 3] 2 |(* $ 2)) #=> @[1 2 6]

# update a numeric value
(++ <var>)
(-- <var>)

# Let macro:
(let [<<binding> <value> …>]
  <form …>)
# - equivalent to using `do` and (multiple) `def`s
#+end_src

** Functions
#+begin_src janet
# Anonymous function:
(fn <?name> [<param …>] <body …>)

# Function definition:
(defn <name> <?docstring>
  [<params …>]
  <body …>)
# just a macro that expands to:
(def <name> (fn [<param …>] <body …>))

# early return from a function:
(break <?value>)

(short-fn <body>)
|<body>  # shorthand
# same as:
(fn [$] (<form …>))
# use `$` for arguments:
(|(* $ $) 3) #=> 9
(|(* $0 $1) 3 4) #=> 12

# For structs and tables, keys act as accessors (same as `in`):
({:a 1 :b 2} :b) #=> 2
(in {:a 1 :b 2} :b) #=> 2
# For vectors and arrays, indices can be used:
([:a :b :c] 2) #=> :c
(in [:a :b :c] 2) #=> :c
# `get` is like `in` but returns `nil` instead of throwing for out-of-range
(get <seq> <idx>)
#+end_src

** Control structures
#+begin_src janet
(do
  <form …>)
# to prevent creating a new local scope in a do block:
(upscope
  <form …>)

(if <condition>
  <when-true>
  <?when-false>)  # returns `nil` if false & else case is missing

# macro for pattern matching
(match <expr>
  <<pattern> <when-matched>
   …>
  <default>)  # returns `nil` if false & no default is provided
#+end_src

** Loops
#+begin_src janet
(while <condition>
  <form …>
  (break))  # early exit (only innermost loop, avoid outside of macros)

(for i <n-start> <n-end>
  <form>)

# loop over each item
(each x <coll>
  <form>)
# loop over each key
(eachk k <indexed coll>
  <form>)
# loop over key-value pairs
(eachp [k v] <indexed coll>
  <form>)

# repeatedly evaluate a form
(repeat <n> <form …>)

(next <indexed coll>)  # returns the next index
(in <indexed coll> <index>)  # returns the value, given an index
#+end_src

Iterable data structures are e.g. *tuples*, *arrays*, *structs*, *tables*, *strings*,
*buffers*, *fibers*, *keywords* and *symbols*
- fibers (generators) iterate over their generated values
- strings iterate over the bytes of each character
- keywords and symbols behave identically to strings

Iteration is based on the function ~next~.
- ~each~ uses ~next~ to compute the keys and then calls ~in~ to look up the values
- ~eachk~ just iterates over the keys from ~next~
- ~map~, ~reduce~, ~filter~, etc. also use ~next~ under the hood
- custom ~JANET_ABSTRACT~ types can receive a custom implementation of ~next~

** Macros
#+begin_src janet
# Macro definition
(defmacro <name> [<param …>]
  <form …>)

# Macro expansion:
# once
(macex1 '(my-macro …)
# fully
(macex '(my-macro …)
#+end_src

AST transformation:
#+begin_src janet
(quote <form>)
'<form>  # shorthand

(quasiquote <form>)
~<form>  # shorthand

(unquote <form>)  # must be used in quasiquote
,<form>  # shorthand

(splice <coll>)
;<coll>  # shorthand
,;<coll>  # unquote-splicing

# can be used like a spreading operator in JS:
[;(range 100)]  # returns a tuple instead of an array
(+ ;(range 100))  # sums the first 100 nat. numbers
#+end_src

** Threading macros
#+begin_src janet
(->> <form …>) # thread last
(-> <form …>)  # thread first

# short-circuit threading
# - will return `nil` if an intermediate value is `nil`
(-?>> <form …>)
(-?> <form …>)

# threading with symbol position
# - use the symbol in a `form` to indicate threading position
(as-> <arg> <as-symbol>
      <form …>)
(as?-> <arg> <as-symbol>
       <form …>)
#+end_src

** Arithmetic
#+begin_src janet
# Basic arithmetic operators:
(+ <n …>)  (* <n …>)  (/ <n …>)  (- <n …>)
# Remainder operator:
(% <n> <m>)
#+end_src
- https://janet-lang.org/docs/numbers.html

** Comparators
#+begin_src janet
# Comparators:
(< <expr …>) (<= <expr …>) (= <expr …>) (>= <expr …>) (> <expr …>)

# deep equality
(deep= <expr …>)

# Polymorphic comparison:
(compare< …) (compare<= …) (compare= …) (compare>= …) (compare> …)
#+end_src
- https://janet-lang.org/docs/comparison.html


* PEG (parsing expression grammar)

- https://janet-lang.org/docs/peg.html
- PEGs operate on /bytes/, not characters
- PEGs can be compiled /ahead of time/ using ~peg/compile~

** Grammars

Multiple patterns can be wrapped in a grammar (a Janet /struct/) and named
with keywords. The keywords can be referenced in all sub-patterns.
- each grammar *must* have a ~:main~ rule, the pattern that defines it
- PEG grammars can be mutually recursive
  - very recursive grammars can lead to stack overflow
  - some patterns may result in very slow loops if written poorly
  - the compiler can turn some recursion into iteration (tail-call opt.)
- nested grammars can access keys from outside

Example grammar:
#+begin_src janet
(def my-grammar
 '{:a (* "a" :b "a")
   :b (* "b" (+ :a 0) "b")
   :main (* "(" :b ")")})

(peg/match my-grammar "(bb)") # -> @[]
(peg/match my-grammar "(babbab)") # -> @[]
(peg/match my-grammar "(baab)") # -> nil
(peg/match my-grammar "(babaabab)") # -> nil
#+end_src

** API functions

To compile a PEG ahead of time (for reuse):
: (peg/compile <peg>)
- https://janetdocs.com/peg%2fcompile
- returns a compiled PEG object, which can also be used with ~peg/match~
- throws an error on invalid PEG code
- *call at the top level* to ensure execution during compilation

To match a PEG on a string:
: (peg/match <peg> <text>  <?start> <?args …>)
- https://janetdocs.com/peg%2fmatch
- on match, returns an array of captured data, else returns ~nil~
- starts at first char unless an optional ~start~ index is provided

To find (the first index / all indexes) where the PEG matches:
: (peg/find <peg> <text>  <?start> <?args …>)
: (peg/find-all …)
- [[https://janetdocs.com/peg%2ffind]]
- returns an integer of the index or ~nil~ if not found

To replace (the first match / all matches) of a PEG:
: (peg/replace <peg> <repl.> <text>  <?start> <?args …>)
: (peg/replace-all …)
- [[https://janetdocs.com/peg%2freplace]]
- returns a new /buffer/ with the replaced match
- if no matches found, returns the input ~text~ in a new buffer
- the PEG does not need to make captures


** Patterns

- PEGs are always anchored to the beginning of the input (like ~^…~ in regex)
- all pattern repetition is implicitly [[https://www.regular-expressions.info/possessive.html][possessive]]
  - e.g. ~(any 1)~ is equivalent to ~^.*+~ in regex
  - however, some combinators like ~choice~ do backtrack

*Primitive patterns:*

| PEG          | Matches                             | Advances |
|--------------+-------------------------------------+----------|
| ~"str"~        | a literal string                    | ?        |
| ~n~            | an integer number n of chars        | n chars  |
| ~-n~           | matches if not that many chars      | not      |
| ~(range "AZ")~ | matches chars in a range            | 1 char   |
| ~(range "09")~ |                                     |          |
| ~(set "abcd")~ | matches any char in the arg. string | 1 char   |

- ~n~ matches /n/ bytes
- ~-n~ fails, if the match could be advanced /n/ characters
  - e.g. ~-1~ asserts that there is no more input left (like ~…$~ in regex to
    mark the end of a line)

*Combining patterns:*

| PEG                   | Meaning                                | RegEx   |
|-----------------------+----------------------------------------+---------|
| ~(sequence <ptn …>)~    | match all in this order                | ~x y~     |
| / ~(* …)~               |                                        |         |
| ~(choice <ptn …>)~      | match one of (in order)                | ~x \vbar y~   |
| / ~(+ …)~               |                                        |         |
|-----------------------+----------------------------------------+---------|
| ~(any <ptn>)~           | match 0 or more rep. of                | ~x*~      |
| ~(some <ptn>)~          | match 1 or more rep. of                | ~x+~      |
| ~(between n m <ptn>)~   | match n ~ m rep. of (both incl.)       | ~x{n, m}~ |
| ~(opt <ptn>)~           | match 0 or 1 rep. of                   | ~x?~      |
| / ~(? …)~               |                                        |         |
| ~(at-least n <ptn>)~    | match at least n rep. of               | ~{n,}~    |
| ~(at-most n <ptn>)~     | match at most n rep. of                | ~{,m}~    |
| ~(repeat n <ptn>)~      | match exactly n rep. of                | ~{n}~     |
| / ~(n …)~               |                                        |         |
|-----------------------+----------------------------------------+---------|
| ~(not <ptn>)~           | match if not matches                   | ~[^x]~    |
| / ~(! …)~               |                                        |         |
| ~(if <cond> <ptn>)~     | match only if cond. matches            |         |
| ~(if-not <cond> <ptn>)~ | match only if cond. not matches        |         |
|-----------------------+----------------------------------------+---------|
| ~(look <offset> <ptn>)~ |                                        |         |
| / ~(> …)~               |                                        |         |
| ~(to <ptn>)~            | match up to pattern (not including it) |         |
| ~(thru <ptn>)~          |                                        |         |
| ~(backmatch <?tag>)~    | if tag: match against tagged capture   |         |
|                       | / else: match against last capture     |         |
|                       | / (only if it is untagged)             |         |

*Built-in patterns*

See Docs:
- https://janet-lang.org/docs/peg.html#Built-in-patterns

: :s[+/*]  # ASCII whitespace char
: :d[+/*]  # ASCII digit
: :a[+/*]  # ASCII letter
: :w[+/*]  # ASCII digit or letter (word char)

** Captures

| PEG                            | Meaning                                |
|--------------------------------+----------------------------------------|
| ~(capture <ptn> <?tag>)~         | capture all text if pattern matches    |
| / ~(<- …)~                       |                                        |
| ~(replace <ptn> <subst> <?tag>~) | replaces a capture from pattern        |
| / ~(/ …)~                        | / with (f capture(s)) or a new value   |
| ~(accumulate <ptn> <?tag>)~      | captures a string as the concatenation |
| / ~(% …)~                        | / of all captures in pattern           |
| ~(constant <const> <?tag>)~      | captures/returns a Janet constant      |
|                                | / useful for parsing                   |
| ~(group <ptn> <?tag>)~           | puts captures into an array            |
| ~(position <?tag>)~              | capture the current index              |
| / ~($ …)~                        |                                        |
| ~(unref <ptn> <?tag>)~           | scope tagged captures                  |
|                                | / e.g.to backmatch in nested patterns  |
| ~(number <ptn> <?base> <?tag>)~  | capture a number parsed from match     |
| ~(cmt <ptn> <fun> <?tag>)~       | invoke (fun capture(s)), expr fails    |
|                                | / if fun returns false or nil          |
| ~(backref <tag> <?tag>)~         | duplicate last capture with given tag  |
| ~(-> …)~                         | / match fails if no capture exists     |

- ~(quote …) / '…~ can be used instead of ~(capture …)~
- ~cmt~ stands for “match-time capture” (see [[http://www.inf.puc-rio.br/~roberto/lpeg/][LPEG]] (Lua))
- ~backref~ is especially useful when combined with ~cmt~ to re-capture a
  capture from a tag to use as an argument for its function
  - e.g. ~(cmt (* (-> :tag-name) …) ,my-fun)~ – the capture from ~:tag-name~ as
    well as all other captures from ~*~ will be passed as args to ~my-fun~

* Fibers

/Fibers/ are *lightweight cooperatively scheduled threads* for *single-core
*asynchronous* programming. They allow to stop (through ~yield~) and ~resume~
execution of a process, enabling multiple returns.
- fibers are *iterable* (like generators in JavaScript)
- a fiber has its own environment and its own call stack

Fibers can be used to implement /schedules/, /generators/, /iterators/,
/live-debugging/ and /error handling/.

Janets [[Event Loop]] and [[Error handling]] is built on top of fibers.

The status signals of a fiber are ~:alive~, ~:dead~, ~:debug~, ~:new~, ~:pending~ and
~:user0~ – ~:user9~.

When ~resume~ is called on a fiber, it will only return when that fiber either
/returns/, ~yield~'s, /throws/ an error, or otherwise emits a /signal/.
- ~resume~ throws an error if the fiber is ~:dead~

More infos:
- https://janet-lang.org/docs/fibers/index.html

** API

To create a fiber:
: (fiber/new <function> <?signalmask>)
- the ~function~ argument must have zero arity
- the optional ~signalmask~ is a collection of flags for checking what kinds of
  signals to trap and return via ~resume~
  - any un-trapped signals are propagated to the previous calling fiber
  - use ~:e~ to “catch” exceptions from an ~error~

To yield the next value of a fiber, optionally passing a value back to the
~yield~ call:
: (resume <fiber> <?x>)

To inspect the status of a fiber:
: (fiber/status <fiber>)

To get the last value returned or signaled from a fiber:
: (fiber/last-value <fiber>)

To create a fiber to yield multiple values:
: (coro <body …>)
- this is the same as calling ~(fiber/new (fn [] <body …>) :yi)~
- “coro” is short for [[*Coroutines][“coroutine”]]

** Signals

/Signals/ are used in fibers to differentiate different kinds of returns. They
can be intercepted by parent fibers.

Named signals:

| Signal      | Description              |
|-------------+--------------------------|
| ~:yield~ / ~:y~ | For yielded values       |
| ~:error~ / ~:e~ | For exceptions           |
| ~:debug~ / ~:d~ | For interactive debugger |

User signals:

| Signal | Description                            | resumable? |
|--------+----------------------------------------+------------|
| ~:0~     | From “early return” macro              | no         |
| ~:1~     |                                        | no         |
| ~:2~     |                                        | no         |
| ~:3~     |                                        | no         |
| ~:4~     |                                        | no         |
| ~:5~     |                                        | yes        |
| ~:6~     |                                        | yes        |
| ~:7~     |                                        | yes        |
| ~:8~     | interrupt one fiber from another fiber | yes        |
| ~:9~     | Something with async and event loop    | yes        |

** Error handling

Fibers are used internally by Janet for error handling
- when an ~error~ is thrown, control is returned to the parent fiber
- the ~try~ macro wraps its body in a new fiber, ~resume~'s the fiber and checks
  if it results in an error, in which case the error clause is evaluated

#+begin_src janet
# evaluates to nil and prints "got error: 1"
(try
  (error 1)
  ([err] (print "got error: " err)))

# Evaluates to 6 - no error thrown
(try
  (+ 1 2 3)
  ([err] (print "oops")))
#+end_src

** Generators
A fiber can be used to make a generator by /yielding/ from it.

Janet generators are similar to JS generators, but they don’t need a special
~function*~ keyword and can ~yield~ from a call to any other normal function.
- ~yield~ returns control from a /fiber/ instead of a /function/ (like in JS)

Janet generators will throw an error if the resumed fiber has already returned
(unlike JS generators, which return ~undefined~ on the ~.next()~ call).

#+begin_src janet
# generators can be normal (0-arity) functions that `yield` intermediate values
(defn my-generator []
  (yield <expr>))

# creating a fiber from a generator
(def my-fiber (fiber/new my-generator) <options>)

# fibers are iterable
(each value my-fiber
  (print value))  # ignores the final return value

#+end_src

** Coroutines

Use ~coro~ to create a /coroutine/, which is like a [[*Generators][generator]], but can receive a
value back when ~yield~'ing.

* Event Loop

The /event loop/ is a powerful /concurrency model/ for Janet. It is a little
*scheduler* in the background of the Janet runtime. All programs are wrapped in
an implicit loop that will run until all tasks are complete.
- most event loop functionality can be found in the [[https://janet-lang.org/api/ev.html][Event Module]] (~ev/~), but
  other functions may also interact with the event loop
- it is especially useful where there are many concurrent IO-bound tasks

Functions that may take a long time to complete will “yield to the event
loop”, meaning they’ll raise a /user signal 9/. Janet catches that signal at
the top-level of its runtime where it performs the desired effect and
resumes the fiber once it completes.

More infos:
- https://janet-lang.org/docs/event_loop.html
- https://janet.guide/concurrency-and-coroutines/

** API

Use ~ev/call~ or ~ev/go~ (more general way) to create new tasks.

To call a function asynchronously:
: (ev/call <fn> <?args …>)
- returns a fiber that is scheduled to run the function
- the fiber will be resumed as soon as the main fiber yields to the event loop
- implemented in terms of ~ev/go~

To put a fiber on the event loop to be resumed later:
: (ev/go <fib> <?val> <?supervisor>)
- returns the fiber
- functions are wrapped with ~fiber/new~ first
- an optional ~val~ can be provided to resume with (default: ~nil~)
- an optional ~core/channel~ can be provided as a ~supervisor~ (defaults to
  inherit the current supervisor)

To concisely run a series of forms in a new task:
: (ev/spawn <?body …>)
- macro for ~(ev/go (fn [] ;body))~

To cancel a suspended fiber in the event loop:
: (ev/cancel <fib> <err>)

To get the currently executing task:
: (fiber/root-fiber)

To suspends the current fiber (without blocking the event loop):
: (ev/sleep <sec>)

[[Channels]]:

To create a new channel:
: (ev/chan <?capacity>)

To read from a channel:
: (ev/take <channel>)
- suspends the current fiber if no value is available

To write a value to a channel:
: (ev/give <channel> <value>)
- suspends the current fiber if the ~channel~ is full
- returns the ~channel~ if write succeeds, ~nil~ otherwise


** Tasks / root fibers

Fibers on the event loop are called /root fibers/ or *tasks* in Janet. A root
fiber will be automatically ~resume~'d when an event (or sequence of events)
that it is waiting for occurs.
- root fibers should generally not be resumed manually (which is only possible
  with ~ev/go~)
- a default Janet program has a single task that will run until complete

[[*Channels][Channels]] and [[*Streams][Streams]] are Janets abstractions to /communicate/ between tasks.
- both work as queues (FIFO), but operate on different kinds of data

** Channels

/Channels/ allow for communication between tasks by sending any Janet value as
*messages*. They only work inside a /thread/, not between threads.
- most useful for things like /internal queues/ and /between-task communication/
  (prefer /streams/ for everything else)

A channel is a /bounded queue/, that can be *read from* and *written to*
/asynchronously/. Reads suspend execution until a value is available, and
writes suspend execution if the queue is full, resuming once another fiber
~take~'s a value off the queue.

**** Supervisor channel
See https://janet.guide/concurrency-and-coroutines/


** Streams

/Streams/ are wrappers around file descriptors and operate on *streams of
bytes*. They can communicate *across threads*, processes and across the
network.

The /Stream API/ is an abstraction over *byte buffers* that can be read from or
written to without blocking the program.
- e.g. to read and write to files or TCP sockets

* Stdlib
** Environment
To inspect documentation on a symbol:
: (doc <symbol>)

** IO
*** Imports
To import a source file:
: (use <filename>)  # without `.janet` extension!

To import a library:
: (import <libname>)

*** Print/Logs
Print:
: (print <form>)
: (prin <form>)  # without trailing newline
: (print)        # just a newline

Print formatted:
: (printf "… %q …" <form>)

Pretty-print:
: (pp <form>)

*** Files/resources
To load a file:
: (slurp "<filename>")

To write to a file:
: (spit "<new-filename>")

Explicit file handling:
: (file/open "<filename>")
: (file/read <file> <opts …>)
: (file/close <file>)

** System
Suspend program for /n/ seconds
: (os/sleep <seconds>)

** Booleans
Checks for truthyness:
: (truthy? <expr>)

** Strings
Check for a prefix in a string:
: (string/has-prefix? <prefix-str> <string>)

To create a formatted string:
: (string/format <string> <value …>)
- https://janetdocs.com/string%2fformat

To upper-case:
: (string/ascii-upper <string>)

To convert bytes (e.g. from string iteration) to a string:
: (string/from-bytes <byte-vals …>)

Join an array of strings with optional separator string:
: (string/join <str-array> <?sep>)

Examples:
#+begin_src janet
(string/format "Hello %s, you are %02d years old." "Peter" 35)
#=> "Hello Peter, you are 35 years old."
(string/format "This %q is an expression." [1 2 3])
#=> "This (1 2 3) is an expression."
#+end_src

** Arrays/Tuples
To select elements:
: (first <seq>)
: (last <seq>)

To get number of elements:
: (length <seq>)

Higher-order sequence functions (no mutation):
: (map <fn> <seq …>)
: (filter <pred> <seq>)
: (reduce <fn> <init> <seq>) (reduce2 <fn> <seq>)
: (partition <n> <seq>)

Map & concat:
: (mapcat <fn> <seq>)
- uses ~array/concat~ to concatenate
- returns a new array (mutable)

Create a table from two arrays/tuples:
: (zipcoll <keys> <vals>)
- returns a new table (mutable)

Create an array of numbers from ~start~ (incl.) to ~end~ (excl.):
: (range <end>)
: (range <start> <end> <?step>)

Interleave collections (like in Clojure):
: (interleave <coll …>)

*** Tuple

To take a sub-seq of an array/tuple from ~start~ (incl.) to ~end~ (excl.) index:
: (tuple/slice <seq> <?start> <?end>)
: (tuple/slice @[1 2 3])  # creates an immutable copy
- https://janetdocs.com/tuple%2fslice

*** Array

To insert an element to the end of an array (mutation):
: (array/push <array> <elem>)
- https://janetdocs.com/array%2fpush
- returns the ~array~

Concatenate a variable number of elements/arrays/tuples into the first array:
: (array/concat <arr> <x …>)
- mutates ~arr~!

Create a new ~array~ of ~count~ elements, all set to ~value~ (default: ~nil~)
: (array/new-filled <count> <?val>)
- returns a new ~array~

** Exceptions
To throw an exception
: (error <string>)

To catch an exception
: (try <form> ([<binding …>] <catch-expr>))

#+begin_src janet
(try …
  ([e] (print e)))
#+end_src

** Arithmetic
- https://janet-lang.org/api/math.html
- from the C library ~<math.h>~

To parse a number from a string:
: (scan-number <string> <?base>)

*** Bit-wise operaors
- like in C or Java

** Compilation
To compile an /abstract syntax tree/ into a function (with no args):
: (compile <ast> …)
- https://janetdocs.com/compile
- https://janet.guide/macros-and-metaprogramming/
* Code Examples

- [[https://github.com/saikyun/freja][freja]] (text editor)
