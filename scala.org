#+title: Docs/Scala

- [[https://scala-lang.org][https://scala-lang.org]]
- [[https://docs.scala-lang.org/scala3/reference/index.html][Scala 3 Reference]]
- [[https://docs.scala-lang.org/scala3/reference/syntax.html][Scala 3 Syntax Summary]] (EBNF forms)
- [[https://www.scala-sbt.org/1.x/docs/index.html][sbt documentation]]
- [[https://index.scala-lang.org][Scaladex]] (searchable index for Scala libs)
- [[https://github.com/lauris/awesome-scala][Awesome Scala]]

Learn
- [[https://users.scala-lang.org][Scala Users]] (forum)
- [[https://docs.scala-lang.org/scala3/book/introduction.html][Scala 3 Book]] (with sbt)
- [[https://scastie.scala-lang.org/][browser-based playground]]

* Install

According to https://scala-lang.org/download/ :
: brew install coursier/formulas/coursier && cs setup

** Coursier

https://get-coursier.io

On MacOS, Scala applications are installed to:
- =~/Library/Application Support/Coursier/bin=

** Editor integration

*Metals*: Scala language server with rich IDE features
- https://scalameta.org/metals/
- for VS Code, [[https://github.com/scalameta/nvim-metals][Neovim]], Emacs, Sublime Text

* Compile and run

Compiler:
: $ scalac
- like ~javac~, will create several =.class= files (as Java bytecode)

REPL and script runner:
: $ scala
To run a compiled =.class= file:
: $ scala <classname>

[[https://scala-cli.virtuslab.org/][Scala CLI]], interactive toolkit for Scala:
: $ scala-cli

** Worksheets

* sbt build tool
- https://www.scala-sbt.org

Tutorials:
- [[https://www.scala-sbt.org/1.x/docs/sbt-by-example.html][sbt by example]] (official)
- [[https://www.youtube.com/playlist?list=PLmtsMNDRU0BwinL745E_cv1PDeR_jhlMI][SBT - Rock the JVM]]

Create a new Scala 3 project:
: $ sbt new scala/scala3.g8
Create a new Scala 2 project:
: $ sbt new scala/hello-world.g8

Start sbt shell:
: $ sbt  : $ sbtn
- exit with ~exit~ or ~ctrl+d~
- type ~help <task>~ for a description of a specific task

All commands in the ~sbt~ console can also be executed from the shell:
: $ sbt <command>

** build.sbt

A scala file with a special structure/syntax.

Global variables can be set for the scope of the project:
: scalaVersion := "2.12.18"
: version := "1.0"
: name := "my-projectname"
: organization := "my.orgname"

Module ~ThisBuild~ applies to the entire project (global scope):
: ThisBuild / scalaVersion := "2.13.6"
: lazy val root = (project in file("."))
:   .settings(
:     …
:   )
- ???

To add dependencies:
: libraryDependencies += "com.lihaoyi" %% "fansi" % "0.4.0"
for multiple deps:
: libraryDependencies ++= Seq(
:   "com.lihaoyi" %% "fansi" % "0.4.0"
:   "org.scalatest" %% "scalatest" % "3.2.13" % Test
:   …
: )
- library definitions will be downloaded from a resolver, usually based on
  Maven (e.g. MavenCentral).
- ~%%~ after the org. name means that sbt will automatically append the Scala
  version number (e.g. ~_2.13~) to the library name
  - only relevant for Scala libs
  - use ~%~ to prevent this
- the ~Test~ token (a global immutable value known to sbt) means that the
  library will only be available within the =test= directory
- ? no need to ~import~, just use the library objects in source files

To add dependency resolvers:
: resolvers += Resolver.url("<repo-name>", url("<repo-url>"))
shorthand syntax, e.g.:
: resolvers += "clojars.org" at "https://repo.clojars.org"
local Maven repo =~/m2/…= :
: resolvers += Resolver.mavenLocal

** Project structure

Minimal setup generated by command ~sbt~, when =build.sbt= is present:
: project/ …
- contains additional files for sbt customization
: └─ build.properties
- contains sbt version number, which can be changed
: target/ …
- contains all binaries that will be compiled by the Scala compiler

Typical source file structure:
: src/
: ├─ main/
: │  └─ scala/
: └─ test/
:    └─ scala/

Main entry (eq. to Java):
#+begin_src scala
object Main {
  def main(args: Array[String]): Unit =
    println("Hello world")
}
#+end_src

*** =project/= directory

Every =project/*.scala= file or Scala object/definition is immediately
available to =build.sbt=.

**** Example:

Define constants in =project/Constants.scala=:
#+begin_src scala
object Constants {
  val rootPackage = "com.typesafe"
}
#+end_src

These values can be used in =build.sbt=:
#+begin_src scala
libraryDependencies += Constants.rootPackage %% "config" % "1.4.2"
#+end_src


** Compile and run JVM bytecode

To compile as class files:
: sbt:…> compile
to recompile every time a source file changes:
: sbt:…> ~compile
- press ~Enter~ to exit

To cross-compile for multiple different Scala versions:
: sbt:…> +compile
needs setup in =build.sbt= first, e.g.:
#+begin_src scala
val scala212 = "2.12.16"
val scala213 = "2.13.8"
scalaVersion := scala213
crossScalaVersions := List(scala212, scala213)
#+end_src

To run JVM bytecode:
: sbt:…> runMain my.package.Main

To re-read =build.sbt= and apply its settings:
: sbt:…> reload

** Run the app

To run the app:
: sbt:…> run

** Run tests

Add a test library:
: libraryDependencies += "org.scalatest" %% "scalatest" % "3.2.7" % Test
use like this, e.g. in =src/test/scala/HelloSpec.scala=:
#+begin_src scala
import org.scalatest.funsuite._

class HelloSpec extends AnyFunSuite {
  test("Hello should start with H") {
    assert("hello".startsWith("H"))
  }
}
#+end_src

To run all tests in =test/= directory:
: sbt:…> test
run tests continuously:
: sbt:…> ~testQuick

To run a specific test class:
: sbt:…> test:testOnly my.package.MyTestclass
using a RegExp:
: sbt:…> test:testOnly *MyTestclass

** Multiple modules/subprojects

List all modules/subprojects:
: sbt:…> projects
Switch to a different module/subproject:
: sbt:…> project core
: sbt:core>
Compile a submodule/subproject:
: sbt:…> core/compile

In =build.sbt=:

Scope settings to a module:
: <module> / <attribute> := <value>
- module ~ThisBuild~ applies to the entire project (global scope)

Specify modules (names, dirs, deps, etc.):
: lazy val core = (project in file("core"))
- ~"core"~ (example) is the name of the subdirectory within the project
- the directory will be automatically created by sbt
with module-specific settings:
: lazy val core = (project in file("core"))
:   .settings(
:     assembly / mainClass := Some("my.orgname.CoreApp"),
:     libraryDependencies += Constants.rootPackage %% "cats-effect" % "3.3.0"
:   )
- a module can also have its own =build.sbt= file at the root of its
  directory, but it is only recommended for larger projects

Modules can depend on one another:
: lazy val server = (project in file("server"))
:   .dependsOn(core)
- here, ~server~ module depends on ~core~

Modules can be aggregated under root module:
: lazy val root = (project in file(".")).aggregate(core, server)

** Plugins

In =project/plugins.sbt=, sbt-plugins can be specified, e.g.:
: addSbtPlugin("com.eed3si9n" % "sbt-assembly" % "1.2.0")
- can also be added globally in =~/.sbt/1.0/plugins/plugins.sbt=, to be
  loaded for all sbt projects
- ~sbt-assembly~ builds fat jars

** Custom Tasks

In =build.sbt=:
: lazy val myTask = taskKey[<ret-type>]("<task name>")
: myTask := { <Scala code> }

To run a task from another task:
: myTask := {
:   val taskVal = myTask.value
:   …
: }

To memoize a value, use a *setting*:
: lazy val mySetting = settingKey[<ret-type>]("setting name")
: mySetting := { <Scala code> }
and get the setting value from a *task*, which will be memoized:
: myTask := {
:   val settingVal = mySetting.value
:   …
: }

*** Example

In =project/PrintTask.scala=:
#+begin_src scala
object CustomTaskPrinter {
  def print() {
    println("Rock the JVM custom SBT task")
  }
}
#+end_src

In =project/StringTask.scala=:
#+begin_src scala
import java.util.UUID

object StringTask {
  def strTask(): String = {
    UUID.randomUUID.toString
  }
}
#+end_src

#+begin_src scala
// custom tasks
lazy val printerTask = taskKey[Unit]("Custom Printer task")
printerTask := { // binding code to task
  // will recompute every time (different values)
  val uuidTask = uuidStringTask.value
  println(s"Generated uuid from task: $uuidTask")

  // will be memoized (value always equal)
  val uuidSetting = uuidStringSetting.value
  println(s"Generated uuid from setting: $uuidSetting")
  CustomTaskPrinter.print()
}

lazy val uuidStringTask = taskKey[String]("Random UUID generator")
uuidStringTask := {
  StringTask.strTask()
}

// custom settings
lazy val uuidStringSetting = settingKey[String]("Random UUID setting")
uuidStringSetting := {
  val uuid = StringTask.strTask()
  // add some more code
  uuid
}
#+end_src
** Aliases

To add an alias:
: addCommandAlias("<name>", "<sbt command>")
- can be invoked in sbt console with ~name~
- write ~sbt command~ just like in sbt console

* Features

- *functional* /and/ *object-oriented*
  - “functions for the logic, objects for the modularity”
- scalable (Scala -> /scalable language/)
- statically typed
- pattern matching
- runs on the JVM, but can also compile to:
  - JS: [[https://www.scala-js.org][Scala.js]]
  - LLVM (native)
- native executables with [[https://github.com/scala-native/scala-native][Scala Native]] and *GraalVM*
- concurrent and parallel programming (-> Actor model, Akka framework)
- regularity (?)
- metaprogramming

[[https://docs.scala-lang.org/scala3/book/scala-features.html#a-functional-programming-language][FP features]], e.g.
- first-class functions
- higher-order functions
- lambdas
- immutable collections in stdlib

[[https://docs.scala-lang.org/scala3/book/scala-features.html#an-object-oriented-language][OOP features]], e.g.
- every value is an instance of a class
- every “operator” is a method
- all types inherit from top-level ~Any~, whose immediate children are:
  - ~AnyVal~ -> /value types/ like ~Int~, ~Boolean~
  - ~AnyRef~ -> /reference types/ as in Java
  - therefore no Java distinction between primiitive and boxed types (e.g. ~int~
    vs. ~Integer~)
- classes, traits, inheritance
- optional /mutable state/ through mutable variables and data structures

[[https://docs.scala-lang.org/scala3/book/scala-features.html#expressive-type-system][Type system features]], e.g.
- type inference
- type classes
- ADTs (with enums)
- intersection & union types
- type lambdas
  that has the type
  - see also [[https://docs.scala-lang.org/scala3/reference/contextual/][Contextual Abstractions]]

/Implicits/
- see [[https://docs.scala-lang.org/scala3/book/why-scala-3.html#4-implicits-simplified][Implicits, simplified]]
- [[https://docs.scala-lang.org/scala3/book/scala-features.html#term-inference-made-clearer][term inference]] -> given a type, the compiler synthesizes a “canonical” term

Java interop
- Java classes and libs can be used in Scala
- Scala code can be used in Java apps
- projects with mixed Scala and Java code are possible

* Types

** Numeric

| Type       | Range | Shorthand | Example |
|------------+-------+-----------+---------|
| Byte       |       |           |         |
| Int        |       |           |         |
| Long       |       | 1_000L    |         |
| Short      |       |           |         |
| Double     |       | 2.2D      |         |
| Float      |       | 3.3F      |         |

- type inference defaults: e.g. ~1~ -> ~Int~, ~1.0~ -> ~Double~

For very large numbers, use ~BigInt~ or ~BigDecimal~, e.g.:
: BigInt(1_234_567_890_987_654_321L)
: BigDecimal(123_456.789)

** Other

| Type   | Example |
|--------+---------|
| String | "Foo"   |
| Char   | 'f'     |

* Data structures

** List

[[https://scala-lang.org/api/3.x/scala/collection/immutable/List.html][Docs]]

: List(<item1>, <item2>, …)

Similar to Clojure:

: <>.head
: <>.tail

: <>.drop(<n>)
: <>.dropWhile(<pred>)

: <>.take(<n>)
: <>.takeWhile(<pred>)

Take a slice from ~i~ (incl.) to ~j~ (excl.):
: <>.slice(<i>, <j>)

Flatten a list of lists:
: <>.flatten

Higher-order functions:

: <>.map(<op>)
- e.g. ~things.map(_.toUpperCase)~

: <>.flatMap(<op>)

: <>.reduceLeft(<op2>)

: <>.foldLeft(<init>)(<op2>)
- see [[https://scala-lang.org/api/3.x/scala/collection/immutable/List.html#:~:text=associative%20binary%20operator.-,override,-def%20foldLeft%5B][Docs]]

*** Range

Create a range to (including) ~m~
: <n> to <m>
with optional increment:
: <n> to <m> by <inc>
up until (excluding) ~m~:
: <n> until <m>

Directly create the range as a list:
: List.range(<n>, <m>, ?<inc>)
same as:
: (<n> to <m> …).toList
** Tuple

Create a tuple:
: (<x>, <y>, …)

To get the value of index ~i~:
: <tuple>(<i>)

Extractor (destructuring into variables):
: val (<name0>, <name1>, …) = <tuple>


* Functions / Methods

Method definition:
: def <name>(<argname>: <argtype> = <default-val>, …): <returntype> =
:   <body>
- parentheses for args can be omitted if none taken
- return type annotation can be omitted for type inference
- ~body~ can be written in the same line as the ~=~ sign
- can be called with named-params, like ~answer(x = 42)~
- put ~@main~ before definition for the main method

Extensions methods for types:
: extension (<var>: <type>)
:   def …


Examples:
#+begin_src scala
extension (s: String)
  def makeInt(radix: Int): Int = Integer.parseInt(s, radix)

"1".makeInt(2)      // Int = 1
"10".makeInt(2)     // Int = 2
"100".makeInt(2)    // Int = 4
#+end_src


* Control structures

If-expression:
: if <cond> then
:  <expr>
: else if <cond> then
:  <expr>
: else
:  <expr>

Match-expression:
: <expr> match
:   case <pattern> => <body>
:   case <pattern> if <condition on pattern-var> => <body>
:   …
:   case _ => <fallthrough>
- can be used similar to Java ~switch~ statement
- not all types support pattern matching

try/catch/finally:
#+begin_src scala
try
  writeTextToFile(text)
catch
  case ioe: IOException => println("Got an IOException.")
  case nfe: NumberFormatException => println("Got a NumberFormatException.")
finally
  println("Clean up your resources here.")
#+end_src


Examples:

Match can be used with types:
#+begin_src scala
val p = Person("Fred")

// later in the code
p match
  case Person(name) if name == "Fred" =>
    println(s"$name says, Yubba dubba doo")

  case Person(name) if name == "Bam Bam" =>
    println(s"$name says, Bam bam!")

  case _ => println("Watch the Flintstones!")
#+end_src

Match can be used as the body of a function:
#+begin_src scala
// getClassAsString is a method that takes a single argument of any type.
def getClassAsString(x: Matchable): String = x match
  case s: String => s"'$s' is a String"
  case i: Int => "Int"
  case d: Double => "Double"
  case l: List[?] => "List"
  case _ => "Unknown"

// examples
getClassAsString(1)               // Int
getClassAsString("hello")         // 'hello' is a String
getClassAsString(List(1, 2, 3))   // List
#+end_src


* Loops

Clojure-like *for loop*:
: for
with generator(s):
:   <name> <- <coll>  …
with guard(s):
:   if <pred>  …
body as a statement:
:   do <instr>
body as an expression (returns a ~List~):
:   yield <expr>

*while loop*:
: while <cond> do <body>


Examples:
#+begin_src scala
for
  i <- 1 to 3
  j <- 'a' to 'c'
  if i == 2
  if j == 'b'
do
  println(s"i = $i, j = $j")   // prints: "i = 2, j = b"
#+end_src

* Strings

Multiline strings:
#+begin_src scala
val quote = """The essence of Scala:
               Fusion of functional and object-oriented
               programming in a typed setting."""
#+end_src

String interpolation:
#+begin_src scala
// With variables:
val firstName = "John"
val lastName = "Doe"
println(s"Name: $firstName $lastName")   // "Name: John Doe"

// With expressions:
val x = -1
println(s"x.abs = ${x.abs}")   // prints "x.abs = 1"
#+end_src
- interpolators other than ~s~ can be used, custom ones can be defined

** Methods

: s.capitalize


* Known

Constant/immutable variable:
: val <name>: <type> = <value>
Mutable variable:
: var <name>: <type> = <value>
- omit type annotation for type inference

Immutable collections:
: List(<item1>, <item2>, …)
: Map(<key1> -> <val1>, <key2> -> <val2>, …)

Pattern matching:
: <expr> match
:   case <some-val> | <alt-val> => <expr>
:   case _ => <default-expr>
- can be used as the body of a method (Haskell-style)

* Unknown

~trait~

~def~ -> type definition?


~Unit~ type

* IO

Readline for user input:
: import scala.io.StdIn.readLine
: val input = readLine()

Print:
: println(<str>)


* Java interop

Import Java libraries, e.g.:
: import java.io.*

Convert Java collections to Scala collections, e.g.:
#+begin_src scala
import scala.jdk.CollectionConverters.*
val scalaList: Seq[Integer] = JavaClass.getJavaList().asScala.toSeq
#+end_src
* Example to test library-interop

JSONiter
- https://github.com/json-iterator/java / https://jsoniter.com

Simple example code:
: import com.jsoniter.output.JsonStream;
: JsonStream.serialize(new int[]{1,2,3}); // from object to JSON
