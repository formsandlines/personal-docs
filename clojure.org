#+title: Docs/Clojure

- [[https://github.com/clojure/clojure/tree/master/src/jvm/clojure/lang][Clojure Source]]
- [[https://github.com/clojure/clojure/tree/master/src/jvm/clojure/lang][clojure.lang Java Source]]
- [[https://clojure.org/api/cheatsheet][Cheatsheet]]

Resources:
- https://github.com/razum2um/awesome-clojure

Libraries:
- https://www.clojure-toolbox.com
- EDN / JSON / Transit transforms: https://github.com/borkdude/jet

* REPL

- Guide: https://lambdaisland.com/guides/clojure-repls/clojure-repls

: $ clj
- C-d to exit the repl

#+begin_src clojure
(require '[my.namespace]) ; load some .clj file/namespace
(require '[my.namespace] :as foo) ; alias for namespace
(require '[my.namespace] :reload) ; reload after file change

(load-file "<path>/file.clj") ; load a file

(ns my.namespace) ; use namespace

*1, *2, *3 ; references to most recent evaluations in REPL

(set! *print-length* n) ; limit output of sequences to n

, ; (CIDER only) shows a set of commands (like 'refresh' to reset the REPL state)
#+end_src

** REPL tools
/Rebel Readline/ provides a better command-line REPL experience:
- https://github.com/bhauman/rebel-readline

Built-in REPL tools:
#+begin_src clojure
(require '[clojure.repl :refer :all]) ; (might be required by default)

; documentation for a function
(doc func)
(javadoc class-or-object)

; find functions that match a particular string
(apropos "func")

; include docstrings in search
(find-doc "func")

; list functions in a particular namespace
(dir clojure.x)

; print source of a function
(source func)
#+end_src

** nREPL
-> Clojure networked REPL server


* Clojure CLI tools

Guides:
- https://clojure.org/guides/deps_and_cli
- https://tomekw.com/clojure-deps-edn-a-basic-guide/

Tutorials (videos):
- [[https://www.youtube.com/watch?v=8aCO_wNuScQ][Use Clojure CLI and deps.edn to Build and Run Clojure app. tools.deps explained]]
- [[https://www.youtube.com/watch?v=OG_MYSGzSHo][How to create and use Clojure library. Publishing to git and Clojars.]]

Note: use ~clj~ for REPL and ~clojure~ for everything else.

** deps.edn

example config:
- https://github.com/dougllcooper/clojure-deps-edn/blob/master/deps.edn

** Executing

run ~-main~ function from a namespace (clojure.main):
: $ clojure -M -m my.namespace
- see https://clojure.github.io/clojure/clojure.main-api.html

run arbitrary (entry) function from a namespace:
- argument can only be 1 map
: $ clojure -X my.namespace/my-func :key1 "value1" :key2 "value2"
or
: $ clojure -X my.namespace/my-func "{:key1 "value1" :key2 "value2"}"

** Classpath

print classpath generated (using specified ~clojure~ options):
: $ clojure -Spath -M:dev

** Dependencies

list all dependencies in project and system:
: $ clojure -Sdescribe

find versions of a dependency using find-versions:
: $ clojure -X:deps find-versions :lib clojure.java-time/clojure.java-time

Maven dependencies can have ~"RELEASE"~ or ~"LATEST"~ version labels to get the
latest release or latest snapshot:
: $ clj -Sdeps '{:deps {org.clojure/clojure {:mvn/version "LATEST"}}}' -e '(clojure-version)'

** Tools

list installed tools:
: $ clojure -Ttools list

install a tool ([[https://github.com/clojure/tools.deps.graph][example]]):
: $ clojure -Ttools install org.clojure/tools.deps.graph '{:mvn/version "1.1.68"}' :as deps-graph

call with:
: $ clojure -Tdeps-graph clojure.tools.deps.graph/graph

** Scripting

create script file and make executable:
: $ touch <path>/myscript
: $ chmod -x <path>/myscript

content e.g.:
#+begin_src bash
#!/usr/bin/env bash

clojure -X my.namespace/my-func $@
#+end_src

execute like:
: $ ./<path>/myscript :arg1 val1 :arg2 var2 …


* Build and deploy

Tutorials:
- [[https://www.youtube.com/watch?v=OG_MYSGzSHo][How to create and use Clojure library. Publishing to git and Clojars.]]
  (YT @VolodymyrKozieiev)
- [[https://clojure-doc.org/articles/ecosystem/libraries_authoring/][Library Development and Distribution]]
  (Clojure Guides)

Helpful resources:
- [[https://cljdoc.org/d/rewrite-clj/rewrite-clj/1.1.47/doc/design/merging-rewrite-clj-and-rewrite-cljs#_library_version_scheme][Library version scheme]] (observations on different schemes used by
  Clojurians)

** To build a JAR:

1. add ~:build~ alias to =deps.edn=:
#+begin_src clojure
{:aliases
 {:build {:deps {io.github.clojure/tools.build
                 {:git/tag "v0.6.2" :git/sha "226fb52"}}
          :ns-default build}}}
#+end_src

2. create =build.clj= file/namespace in root dir

3. compile the JAR:
: $ clojure -T:build jar

** To put a JAR in local Maven repository:

Default path for a local Maven repository:
=~/.m2/repository/my-repo=

1. add function to build.clj that installs the JAR on local repo:
#+begin_src clojure
(defn install [_] (b/install ...))
#+end_src

2. invoke install function:
: $ clojure -T:build install

** To push a JAR to Clojars:

must have a Clojars account first

1. add deps-deploy library: https://github.com/slipset/deps-deploy
#+begin_src clojure
slipset/deps-deploy {:mvn/version "RELEASE"}
#+end_src

2. require in =build.clj=:
#+begin_src clojure
(:require [deps-deploy.deps-deploy :as dd])
#+end_src

3. add deploy function:
#+begin_src clojure
(defn deploy [_] (dd/deploy ...))
#+end_src

4. setup env variables (see deps-deploy repo):
: $ env CLOJARS_USERNAME=username CLOJARS_PASSWORD=clojars-token clj -X:deploy

5. invoke install function
: $ clj -T:build deploy

** To add a library to deps.edn:

#+begin_src clojure
; To add a local library (can have any name):
{:deps {some-name {:local/root "../my-local-lib"}}}

; To add a library from GitHub:
{:deps {com.github.my-user/my-repo {:git/sha "XXXX"}}}
; - copy SHA directly from the commit in GitHub repo
; with tag (can have shorter sha code):
{:deps {com.github.my-user/my-repo {:git/tag "v0.0.1" :git/sha "XXXX"}}}

; To add a local JAR package:
{:deps {some-name {:local/root "../my-local-lib/target/my-lib-0.0.1.jar"}}}

; To add a JAR, installed on local or remote Maven repo:
{:deps {repo-name {:mvn/version "0.0.1"}}}
#+end_src

** To build an uberjar (using Neil)
:PROPERTIES:
:ID: uberjar
:END:

needs tools.build
: $ neil add build
- adds tools.build =build.clj= file and :build alias

assumes project is under version control, so:
(actually might not be necessary anymore)
: $ git init
: $ git add deps.edn src test
: $ git commit -m "initial commit"

add ~(:gen-class)~ to namespace:
#+begin_src clojure
(ns myproject.core
  (:gen-class))
#+end_src

add ~:main '<entry-ns>~ in the call to b/uber:
#+begin_src clojure
(b/uber {:class-dir class-dir
         :uber-file uber-file
         :basis basis
         :main 'myproject.core})
#+end_src

to compile the uberjar:
: $ clojure -T:build uber

run like
: $ java -jar target/lib1-1.2.1-standalone.jar

(?) Mac OSX: to create .app from Uberjar:
https://github.com/TheInfiniteKind/appbundler/

*** Compile uberjar to native image with GRAALVM and babashka

after creating the uberjar, compile to native image like this:
: $GRAALVM_17_HOME/bin/native-image -jar target/my-project-standalone.jar --no-fallback --initialize-at-build-time=clojure,my-project my-project

-> compiles Java class files to machine code
** GraalVM native binary
See [[file:java.org][Docs/Java]] and [[https://github.com/clj-easy/graalvm-clojure/blob/master/doc/clojure-graalvm-native-binary.md][How to build a native binary for your Clojure projects with GraalVM]]

* Tests

- cognitect test-runner: https://github.com/cognitect-labs/test-runner
- for ClojureScript (same interface): https://github.com/Olical/cljs-test-runner


* Neil
https://github.com/babashka/neil

Tutorial:
- https://blog.michielborkent.nl/new-clojure-project-quickstart.html

: $ brew install babashka/brew/neil

** Create new projects

: $ neil new --name <name>
- same as ~… new scratch …~

: $ neil new app --name <name>

** Adding dependencies

search Clojars for a string in any attribute of an artifact:
: $ neil dep search <string>
- example: `"file system"`

: $ neil dep add :lib <lib-ns> :version <lib-version>
- example: `babashka/fs :version 0.1.6`

** Adding licenses
-> uses Github's license API

search for licenses:
: $ neil license list
: $ neil license list <string>
- example: `"lesser general"`

add a LICENSE file:
: $ neil license add <license-name>
: $ neil license add :license <name> :file <file>
- examples: `epl-1.0` , `:license mit :file myproj/license.txt`

** Adding cognitect test runner

add to deps.edn:
: $ neil add test

needs tests like =./test/myproject/core_test.clj=:
#+begin_src clojure
(ns myproject.core-test
  (:require [clojure.test :as t :refer [deftest is testing]]))

(deftest failing-test
  (testing "TODO: fix test"
    (is (= 3 4))))
#+end_src

to run all tests:
: $ clojure -M:test
to run a single test:
: $ clojure -M:test -v my.namespace-test/somefn-test

** Adding nrepl support

add to deps.edn:
: $ neil add nrepl

to start nrepl server (use jack-in instead if possible):
: $ clojure -M:nrepl

** Adding tools.build

: $ neil add build
- adds tools.build =build.clj= file and :build alias
- e.g. [[id:uberjar][to build an uberjar]]
** Managing versions
To get the current neil and project version:
: neil version

To set the current project version:
: neil version set <version>
- sets the ~:version~ key in =deps.edn=:
  - ~:aliases {:neil {:project {:version "..."}}}~
- *note:* creates a commit together with a version tag, which requires a clean
  working directory (unless ~--force~ is provided as an option)

To disable commit and tag creation use ~--no-tag~ option:
: neil version set <version> --no-tag

To increment the semantic version number:
: neil version major|minor|patch
- works like ~version set~

To just create a commit and tag for the current project version:
: neil version tag
- *warning:* will create a commit with all staged files
- requires that there are no unstaged files

* Babashka

Docs: https://book.babashka.org

Start nREPL server
: $ bb nrepl-server

** Executing

to evaluate an expression:
: $ bb -e '(+ 1 2 3)'

to run a script:
: $ bb -f script.clj

scripts can have shebangs to invoke them directly:
: #!/usr/bin/env bb
: (+ 1 2 3)

to execute ~-main~ function:
: $ bb -m my.namespace

to invoke a function using babashka CLI (example):
: $ bb -x clojure.core/identity --hello there
: {:hello "there"}
similar to:
: $ clojure -X clojure.core/identity '{:hello "there"}'
but converts Unix-style arguments to Clojure maps

** Tasks

to show available tasks:
: $ bb tasks

to run a task:
: $ bb <taskname>

*** Adding tasks for tests

https://blog.michielborkent.nl/babashka-test-runner.html

in =bb.edn=:
#+begin_src clojure
{:tasks
 {test:clj {:doc "Run clj tests"
            :extra-paths ["test"]
            :task (do (println "Clojure tests:")
                      (clojure "-M:test"))}
  test:bb {:doc "Run bb tests"
           :extra-paths ["test"]
           :extra-deps {io.github.cognitect-labs/test-runner
                        {:git/tag "v0.5.1" :git/sha "dfb30dd"}}
           :task (do (println "Babashka tests:")
                     (exec 'cognitect.test-runner.api/test))
           :exec-args {:dirs ["test"]}
           :org.babashka/cli {:coerce {:nses [:symbol]
                                       :vars [:symbol]}}}}}
#+end_src

run Clojure tests like this:
: $ bb test:clj

run Babashka tests like this:
: $ bb test:bb
: $ bb test:bb --vars my.namespace-test/some-fn-test
: $ bb test:bb --nses my.namespace-test

*** Adding tasks for native compilation with GraalVM

#+begin_src clojure
{…
 :tasks
 {:requires ([babashka.fs :as fs])
  uberjar {:task
           (when (seq (fs/modified-since "target/myproj-standalone.jar"
                                         ["src"]))
             (clojure "-T:build uber"))}
  native-image {:doc "Creating native image"
                :depends [uberjar] ;; <- calls this first
                :task
                (let [graalvm-home (System/getenv "GRAALVM_17_HOME")
                      native-image (str (fs/file graalvm-home
                                                 "bin" "native-image"))]
                  (shell native-image
                         "-jar" "target/myproj-standalone.jar"
                         "--no-fallback"
                         "--initialize-at-build-time=clojure,myproj"
                         ;; binary name:
                         "myproj"))}}}
#+end_src

optionally use this util to automate build-time options:
- https://github.com/clj-easy/graal-build-time

then just call:
: $ bb native-image

*** Using Unix-style task-arguments with babashka-cli

#+begin_src clojure
{:tasks
 mytask {;; exec … -> bb -x …
         :task (exec 'some.namespace/some-fn)
         ;; default arguments for exec call:
         :exec-args {:some-arg (my-expr …)}
         ;; cli arguments:
         :org.babashka/cli {:coerce {:myarg [:int]
                                     …}
                            :alias {:m :myarg
                                    …}}}}
#+end_src

calling:
: $ bb mytask -m 42
will evaluate ~'some.namespace/some-fn~
with ~{:some-arg (my-expr …) :m 42 …}~

*** Using external functions in tasks

#+begin_src clojure
;; create a file, e.g. =bb/tasks.clj=:
(ns tasks)
(defn my-fn [_] …)

;; in bb.edn:
{;; add directory to classpath:
 :paths ["src" "bb"]
 :tasks
 ;; require namespace:
 {:requires ([tasks])
  my-task {;; call function:
           :task (tasks/my-fn {})}}}
#+end_src

* FlowStorm

- ctrl+l -> clear all recordings

| Command         | Description                               |
|-----------------+-------------------------------------------|
| :dbg            | start debugger                            |
| :last           | go to last recording                      |
| :ex             | jump before the last exception            |
| :rec / :stop    | resume / pause tracing                    |
| :inst / :noinst | enable / disable compiler instrumentation |
|                 |                                           |
- ~:noinst~ will not remove instrumentation from already loaded functions, they
  will have to be re-evaluated

** Config for Clojure (ClojureStorm)
https://jpmonettas.github.io/flow-storm-debugger/user_guide.html#_clojurestorm

In =deps.edn=:
#+begin_src clojure
{:classpath-overrides {org.clojure/clojure nil}
 :extra-deps {com.github.jpmonettas/clojure {:mvn/version "LATEST-AVAILABLE-VERSION"}
              com.github.jpmonettas/flow-storm-dbg {:mvn/version "LATEST-AVAILABLE-VERSION"}}
 :jvm-opts ["-Dflowstorm.startRecording=true"
            "-Dclojure.storm.instrumentEnable=true"
            "-Dclojure.storm.instrumentOnlyPrefixes=YOUR-PROJECT-TOP-NS"]}
#+end_src

** Config for ClojureScript
https://jpmonettas.github.io/flow-storm-debugger/user_guide.html#_clojurescript

In =shadow-cljs=:
#+begin_src clojure
{:dependencies [[com.github.jpmonettas/flow-storm-inst "RELEASE"]]
 :nrepl        {:port 9000}  ; optional
 :builds       {:<build-id> {:devtools {:preloads [flow-storm.api]}}}}
 #+end_src

#+begin_src shell
clj -Sforce -Sdeps '{:deps {com.github.jpmonettas/flow-storm-dbg {:mvn/version "RELEASE"}}}' -X flow-storm.debugger.main/start-debugger :port 9000 :repl-type :shadow :build-id :<build-id>
#+end_src


** Instrumentation

Disabling instrumentation is useful when you want to measure performance or
in any other situation where you don't want instrumentation. If you start
ClojureStorm with disabled instrumentation it should be exactly the vanilla
Clojure compiler.

JVM opts
- ~-Dclojure.storm.instrumentOnlyPrefixes~
- ~-Dclojure.storm.instrumentSkipPrefixes~

If you start the jvm with
~-Dclojure.storm.instrumentOnlyPrefixes=my-project,lib1,lib2.core~ it means
that all functions under ~my-project.*~, ~lib.*~ and ~lib2.core.*~ will get
instrumented, everything else will be skipped and be compiled exactly like
with the vanilla Clojure compiler.

On the other side you have ~-Dclojure.storm.instrumentSkipPrefixes~ to specify
what to skip instead of what to instrument, in case you want to instrument
everything but certain libs.

Everything under ~clojure.*~ will be un-instrumented by default, but if you
set the right prefixes you can then re-eval the ~clojure.*~ functions you are
interested in and instrument them.



* Editor support
** Vim: conjure
- https://github.com/Olical/conjure

** Emacs: CIDER
- https://github.com/clojure-emacs/cider
- https://github.com/clojure-emacs/clj-refactor.el for additional refactoring

Installation in Doom Emacs: uncomment ~clojure~ in =init.el=.

Installation with ~use-package~:
#+begin_src elisp
(use-package cider
  :ensure t
  :config
  (require 'flycheck-clj-kondo))

;; Linter:
(use-package flycheck
  :ensure t
  :defer t
  :diminish
  :init (global-flycheck-mode))
(use-package flycheck-clj-kondo
  :ensure t)
#+end_src


** VS Code: Calva
(note: has some problems with Vim extension, see https://calva.io/vim/)

** Leiningen

: $ brew install leiningen

: $ lein
- installs Leiningen on the first run

to start the repl:
: $ lein repl
- ~(exit)~ to exit the repl

: $ lein new <name>
: $ lein new app <name>

to run Leiningen app (needs :main namespace in project.clj!):
: $ lein run

to create standalone executable:
: $ lein uberjar
- clean & uberjar: ~lein do clean, uberjar~
run like:
: $ java -jar <path>/...-standalone.jar

bundle executable package with JRT:
: $ jpackage --input ./target/uberjar/ --main-jar <name>-0.1.0-SNAPSHOT-standalone.jar

print dependency tree for the project:
: $ lein deps :tree

*** project.clj (Leiningen)

large annotated example to look for settings:
- https://github.com/technomancy/leiningen/blob/master/sample.project.clj


* Language
** Namespaces
~*ns*~ is a namespace object representing the current namespace.

Set ~*ns*~ to the namespace ~name~ (unevaluated), create it if needed:
: (ns name ?docstring ?attr-map references*)

~references~ can be zero or more of (args are the same as for the
corresponding functions, but are unevaluated and need not be quoted):
- ~(:refer-clojure & filters)~
- ~(:require & args)~
- ~(:use & args)~
- ~(:import & import-symbols-or-lists)~
- ~(:load & paths)~
- ~(:gen-class & options)~

Return a sequence of all namespaces:
: (all-ns)

Return a map of the /(public) intern mappings/ for the namespace:
: (ns-publics ns)
: (ns-interns ns)
- use ~ns-publics~ to see all public/accessible symbols from the namespace
- use ~ns-interns~ to see all symbols from the namespace, incl. private ones
- ~ns~ must be a symbol, e.g. ~'clojure.string~

Add an alias in the current namespace to another namespace:
: (alias alias-sym namespace-sym)
- prefer using ~:as~ in the ns macro to calling this directly

Can be used to alias the current namespace:
#+begin_src clojure
(ns my.very.long.complicated-name)

(alias 'foo 'my.very.long.complicated-name)

(def kw ::foo/bar)
#+end_src

** Multimethods
:PROPERTIES:
:CUSTOM_ID: multimethod
:END:
“Clojures functional brand of runtime polymorphism”
- see https://clojure.org/reference/multimethods

Create a new multimethod with associated ~dispatch-fn~:
: (defmulti name ?docstring ?attr-map dispatch-fn & options)
- ~dispatch-fn~ gets passed all args as given to the multimethod

*Note:* Clojure does not replace an already existing ~defmulti~ definition, so
to redefine a multimethod, set the old one to /nil/ first

Values for ~options~:
- ~:default~ → default dispatch value, defaults to ~:default~
- ~:hierarchy~ → specify a [[#hierarchy][hierarchy]] for hierarchical dispatch

Create & install a new method of ~multifn~ associated with ~dispatch-val~:
: (defmethod multifn dispatch-val & fn-tail)
- ~fn-tail~ are passed by the macro to ~fn~, so write ~[params*] exprs*~
- while ~dispatch-val~ is the return value of ~dispatch-fn~ in the ~defmulti~
  definition, ~fn-tail~ gets the actual args passed to the multimethod

Remove the method of ~multifn~ with associated ~dispatch-val~:
: (remove-method multifn dispatch-val)
Remove all methods from ~multifn~:
: (remove-all-methods multifn)

Return a map of /dispatch values → dispatch fns/ for ~multifn~:
: (methods multifn)

Return the /dispatch fn/ that would apply to the ~dispatch-val~ of ~multifn~:
: (get-method multifn dispatch-val)
- returns /nil/ if none apply and there is no default method


Cause ~multifn~ to prefer matches of ~dispatch-val-x~ over ~dispatch-val-y~ when
there is a conflict:
: (prefer-method multifn dispatch-val-x dispatch-val-y)
- use when multiple dispatch values match for an input value (e.g. with
  multiple inheritance in hierarchies, see example in /Programming Clojure/,
  pp. 214–215)

Return a map of /preferred value → set of other values/ from ~multifn~:
: (prefers multifn)

Examples:
#+begin_src clojure
;; Example from somewhere (forgot the source):
(defmulti diet (fn [x] (:eater x)))
(defmethod diet :herbivore [a] (str (:name a) " eats veggies."))
(defmethod diet :carnivore [a] (str (:name a) " eats animals."))
(defmethod diet :default [a] (str "I don't know what " (:name a) " eats."))

(diet {:species "deer" :name "Bambi" :age 1 :eater :herbivore})
;; -> "Bambi eats veggies."

;; Can have a variable number of arguments:
(defmulti varargs (fn [kw & _] kw))
(defmethod varargs :default [_ & args] args)
(defmethod varargs :foo [_ x] x)
(defmethod varargs :bar [_ x y] [x y])

;; Can be used for type-based polymorphism (similar to protocols):
(defmulti showme type)
(defmethod showme java.lang.String [txt] (str txt " is a String!"))
(defmethod showme java.lang.Long [n] (str n " is a Long!"))


;; Usage with a hierarchy (example from ClojureDocs):
(def h (-> (make-hierarchy)
           (derive :foo :bar)))

(defmulti f identity :hierarchy #'h) ;; hierarchy must be a reference type

(defmethod f :default [_] "default")
(defmethod f :bar [_] "bar")

(f :unknown) ;; "default"
(f :bar) ;; "bar"
(f :foo) ;; "bar" (because :foo is a child of :bar)

;; For an impressive example on recursion in multimethods (in calculation),
;; see p. 896 in ‘Clojure: The Essential Reference’
#+end_src

** Hierarchies
:PROPERTIES:
:CUSTOM_ID: hierarchy
:END:
Hierarchical relationships between symbols/keywords/classes.
- see https://clojure.org/reference/multimethods

Create a new (empty) hierarchy:
: (make-hierarchy)

*Note:* all functions below default to the global hierarchy when no explicit
hierarchy is given.

Establish a parent/child relationship between ~parent~ and ~tag~:
: (derive ?h tag parent)
- ~parent~ must be a /ns-qualified symbol/ or a /keyword/
- ~tag~ (child) can be either a /ns-qualified symbol/, a /keyword/ or a /class/
- modifies the /global hierarchy/ if ~h~ is not given
- classes are allowed only as children

Remove a parent/child relationship (see ~derive~):
: (underive ?h tag parent)

Check if ~child~ is (in)directly derived from ~parent~:
: (isa? ?h child parent)
- also returns /true/ if ~(= child ~parent)~
- also checks /Java type inheritance relationships/
- also works on vectors by testing their respective items

Get specific relationships of ~tag~ within a hierarchy as a /set/:
: (parents ?h tag)
: (ancestors ?h tag)
- useful to retrieve the set of classes or interfaces a class extends or
  implements
: (descendants ?h tag)

Hierarchies can also be used in [[#multimethod][Multimethods]].

Examples:
#+begin_src clojure
(def h (-> (make-hierarchy)
           (derive ::rect ::shape)
           (derive ::square ::rect)))

;; (pprint h)
{:parents     {:user/square #{:user/rect},
               :user/rect   #{:user/shape}},
 :ancestors   {:user/square #{:user/shape :user/rect},
               :user/rect   #{:user/shape}},
 :descendants {:user/rect   #{:user/square},
               :user/shape  #{:user/square :user/rect}}}

(ancestors ::square) ;; => nil (not in global hierarchy)
(ancestors h ::square) ;; => #{:user/shape :user/rect}


;; Example from ‘Clojure: The Essential Reference’:
(defn custom-hierarchy [& derivations]
  (reduce (fn [h [child parent]] (derive h child parent))
          (make-hierarchy)
          derivations))

(def h (custom-hierarchy [:clerk :person]
                         [:owner :person]
                         [:unix :os]
                         [:bsd :unix]
                         [:mac :bsd]))

;; checks for pairs of relationships and returns true only if all are true:
(isa? h [:mac :owner] [:unix :person]) ;;=> true

#+end_src

** Protocols
:PROPERTIES:
:CUSTOM_ID: protocols
:END:
High-performance, dynamic polymorphism construct as an alternative to
interfaces.
- specification only, no implementation
- a single type can implement multiple protocols
- allow /independent extension/ of the set of types, protocols, and
  implementations of protocols on types, by different parties
- see https://clojure.org/reference/protocols

Check if ~x~ satisfies a protocol:
: (satisfies? <protocol> <x>)

** Datatypes (deftype, defrecord, reify)
:PROPERTIES:
:CUSTOM_ID: datatypes
:END:
Define implementations of abstractions (→ [[#protocols][protocols]], interfaces) using
well-defined relationships to constructs of the host platform.
- provides a /host type/ (either named or anonymous with ~reify~) and some
  /structure/ (either explicit fields or implicit closure with ~reify~)
- not primarily interop constructs
- see https://clojure.org/reference/datatypes

*Construction*

: (deftype name [& fields] & opts+specs)
: (defrecord name [& fields] & opts+specs)
: (reify & opts+specs)

~deftype~ and ~defrecord~ are macros that dynamically generate compiled bytecode
for a named class with a set of given fields.
- when ~Foo~ is defined, both define a corresponding function ~->Foo~ that
  passes its args to the constructor
- when a ~defrecord~ ~Bar~ is defined, a corresponding function ~map->Bar~ is
  defined that takes a map and initializes a new record instance

~reify~ defines both an /anonymous/ type and creates an /instance/ of that type.
- the method bodies of reify are /lexical closures/, and can refer to the
  surrounding local scope

*Use-cases*

- use ~defrecord~ to represent application domain information
  - when generic processing of immutable data is important
- use ~deftype~ for classes that are artifacts of the
  implementation/programming domain
  - when a more specific/custom implementation is needed
  - when mutable fields are required
- use ~reify~ when a one-off implementation of one or more protocols or
  interfaces is needed
  - with the benefit of the local context
  - use case is similar to ~proxy~, or /anonymous inner classes/ in Java
    - more performant than ~proxy~ in both construction and invocation
    - preferable to proxy in all cases where its constraints are not
      prohibitive

*Features*

~deftype~ and ~defrecord~ can optionally implement methods via [[#protocols][protocols]] and/or
interfaces.

~defrecord~ provides a complete implementation of a persistent map:
- value-based equality and hashCode
- metadata support
- associative support
- keyword accessors for fields
- extensible fields (assoc keys not supplied with the definition)
- etc.

~deftype~ provides no functionality not specified by the user (other than a
constructor), but supports /mutable fields/.

Both can be written with a special reader syntax ~#my.thing[1 2 3]~, but
~defrecord~ supports an additional reader form ~#my.record{:a 1, :b 2}~.

Types created with ~deftype~, ~defrecord~, and ~definterface~, can emit classes
that include Java annotations for Java interop. Annotations are described as
/meta/ on:
- /Type name/ (deftype/record/interface) - class annotations
- /Field names/ (deftype/record) - field annotations
- /Method names/ (deftype/record) - method annotations

** Iteration
*** for pure data
Return a lazy seq of evaluations of ~body-expr~ – for each item as specified
in 1+ binding pairs in ~seq-exprs~, each followed by 0+ modifiers:
: (for seq-exprs* body-expr)
- list-comprehension, NOT a for-loop
- multiple seq bindings behave like a nested loop
- bindings can have ~:let~, ~:when~ and ~:while~ modifiers
  
Evaluate the ~exprs~ with the given ~bindings~ (like in a ~let~-form), using
~recur~ for iteration:
: (loop [bindings*] exprs*)
- /special form/

Jump back to the recursion point, a ~loop~ or ~fn~ method:
: (recur exprs*)
- /special form/
- MUST be in /tail-position/ (last expr in a branch)
- recursion via ~recur~ doesn't consume the stack

Return a lazy seq (infinite or length ~n~) of ~x~:
: (repeat ?n x)

Return a lazy seq of iteratively calling ~x~, ~(f x)~, ~(f (f x))~, …:
: (iterate f x)
- ~f~ must be free of side-effects
- ~rest~ and ~nthrest~ preserve the ~clojure.lang.Iterate~ type of the seq

Examples:
#+begin_src clojure
(for [letter [:a :b]
      number (range 3)]
  [letter number])
;;=> ([:a 0] [:a 1] [:a 2] [:b 0] [:b 1] [:b 2])

(for [x '(1 2 3)] (* x x)) ;;=> (1 4 9)

;; indexed:
(for [[i val] (map-indexed vector [:a :b :c])] ...)
;; or equivalently:
(for [[i val] (map vector (range) [:a :b :c])] ...)

;; argument to :when must be an expression of the local bindings
(for [i (range 10)
      :when (odd? i)]
  i) ;;=> (1 3 5 7 9)

;; get all neighbours of a coordinate in an area
(let [w 4, h 4
      x 2, y 1]
  (for [dx [-1 0 1]  ;; neighbour range
        dy [-1 0 1]
        :let [x' (+ x dx)  ;; calc new coords
              y' (+ y dy)]
        :when (and (not (= dx dy 0))  ;; exclude self
                   (<= 0 x' (dec w))  ;; check bounds
                   (<= 0 y' (dec h)))] [x' y']))
;;=> ([1 0] [1 1] [1 2] [2 0] [2 2] [3 0] [3 1] [3 2])

; use :while to constrain infinite sequences
(take 6 (for [i (range) ;; seq i constrained by take 6
              j (range)
              :while (< j 3)] [i j])) ;; constrains seq j
;;=> ([0 0] [0 1] [0 2] [1 0] [1 1] [1 2])


(loop [i 0]
  (if (< i 10)
    (recur (inc i)) i))
;; roughly equivalent to:
((defn f [i]
  (if (< i 10)
    (f (inc i)) i))
 0)
;; function arguments are implicit loop bindings:
(defn increases [i]
  (if (< i 10)
    (recur (inc i)) i))


(take 4 (iterate #(* % 2) 1)) ;;=> (1 2 4 8)
(take 9 (iterate #(repeat 3 %) 1))
;;=> (1 (1 1 1) ((1 1 1) (1 1 1) (1 1 1)))
#+end_src

*** for side-effects
Evaluate ~exprs~ ~n~ times using a binding:
: (dotimes [name n] exprs*)
- returns nil

Repeatedly execute ~body~ with bindings and filterings in 1+ ~seq-exprs~ (as
provided to ~for~):
: (doseq seq-exprs & body)
- multiple seq bindings behave like a nested loop
- if ~seq~ is a lazy sequence, forces evaluation
- returns nil

Fully realize a lazy seq to force any of its effects:
: (doall ?n coll)
- walks through the successive nexts of the seq, retains the head and
  returns it, thus causing the entire seq to reside in memory at one time
- does not retain the head of the sequence
- returns nil

Return a lazy seq of (~n~ or infinite) calls to ~f~ (must take no args):
: (repeatedly ?n f)

Execute a side-effecting procedure on successive items of ~coll~:
: (run! proc coll)
- returns nil
- uses ~reduce~ internally

Examples:
#+begin_src clojure
(dotimes [i 3] (println i))


(doseq [n (range 3)] (println n))
(doseq [v1 [1 2 3]
        v2 ['a 'b]] (println v1 v2))

(defn five-letter-words-imperative [dict]
  (def words (atom []))
  (doseq [word dict]
    (when (== (count word) 5)
      (swap! words conj word)))
  @words)


(def state (atom 1))
(repeatedly 5 #(swap! state inc)) ;=> (2 3 4 5 6)
@state ;;=> 6
#+end_src

** Transducer
- see https://clojure.org/reference/transducers

Transducers abstract transformations from input sequences and output data.

Example adapted from [[https://github.com/nufuturo-ufcg/clj-smells-catalog?tab=readme-ov-file#reinventing-the-wheel][clj-smells-catalog – Reinventing the Wheel]]:
#+begin_src clojure
(let [data [{:name "Alice" :active true  :tags ["admin" "editor"]}
            {:name "Bob"   :active false :tags ["viewer" "editor"]}
            {:name "Carol" :active true  :tags ["editor" "reviewer"]}]

      active (filter :active)
      names  (map :name)
      tags   (map :tags)
      ->transform-data (fn [& xforms] (into [] (apply comp xforms) data))]
  {:names (->transform-data active names)
   :seconds (->transform-data active tags (map second))
   :flat-tags (->transform-data active tags cat)})
;; =>
;; {:names ("Alice" "Carol"),
;;  :seconds ("editor" "reviewer"),
;;  :flat-tags ("admin" "editor" "editor" "reviewer")}
#+end_src

Because the output of ~eduction~ is a “reducible”, it can be used for
side-effects in transformations, e.g. to generate a new sequence of random
numbers on every call.

Example adapted from [[https://clojurecivitas.github.io/clojure/transducers/what_if.html][What if… we were taught transducers first?]]:
#+begin_src clojure
(let [s (eduction (map (fn [_] (rand-int 10))) (range 5))]
  [(into [] s) (into [] s)])
;; => [[7 9 9 1 0] [7 1 3 9 5]] (calls transformation twice)

(let [s (sequence (map (fn [_] (rand-int 10))) (range 5))]
  [(into [] s) (into [] s)])
;; => [[2 0 8 4 3] [2 0 8 4 3]] (results are cached)
#+end_src

** Transients
Temporary, localized permutation on otherwise persistent collections.
- supported on /vectors/, /hash-maps/, and /hash-sets/
- can only be used in an single-threaded scope
- share structure with persistent source
- creation and transforming back to persistent is O(1)
- creation does not modify the source
- ~get~, ~nth~ and ~count~ work as usual
- see https://clojure.org/reference/transients

Return (constant time) a transient version of ~coll~:
: (transient coll)

Mutation through ~!~-variants, which work just like their counterparts:
: (conj! …) : (assoc! …)
- return values have to be used, not designed to be bashed in-place!

Return (constant time) a new, persistent version of the transient ~coll~:
: (persistent! coll)
- after calling, the transient collection cannot be used anymore
  - also true for any alias
  - as a workaround, create a new binding to a ~transient~ call on the
    persistent ~coll~, which will keep the persistent version

* Clojure & Java interop

** Calling Clojure from Java

Interop package: [[http://clojure.github.io/clojure/javadoc/clojure/java/api/package-summary.html][clojure.java.api]]
- public Java API for Clojure, which consists of the classes/interfaces:
  - ~clojure.java.api.Clojure~
  - ~clojure.lang.IFn~
- see https://stackoverflow.com/a/23555959/1204047

*** In pure Java:

In =pom.xml=:
#+begin_src xml
<project …>
    <!-- ... -->
    <repositories>
        <repository>
            <id>clojars.org</id>
            <url>https://repo.clojars.org</url>
        </repository>
    </repositories>

    <dependencies>
        <!-- ... -->
        <dependency>
            <groupId>org.clojure</groupId>
            <artifactId>clojure</artifactId>
            <version>1.12.0-alpha4</version>
        </dependency>
        <dependency>
            <groupId>some.clojarslib</groupId>
            <artifactId>lib-name</artifactId>
            <version>0.1.0</version>
        </dependency>
    </dependencies>
#+end_src

In =.java= files:
#+begin_src java
import clojure.java.api.Clojure;
import clojure.lang.IFn;

// Locate a var from a Clojure namespace, return its `IFn` interface:
IFn cl_println = Clojure.var("clojure.core", "println");
IFn cl_require = Clojure.var("clojure.core", "require");
IFn cl_deref = Clojure.var("clojure.core", "deref");

// Call a Clojure function using its `invoke` method:
IFn plus = Clojure.var("clojure.core", "+");
plus.invoke(2,3);

// Read arbitrary Clojure syntax using Clojure’s EDN reader:
Clojure.read("{:foo 1 :bar 2}");

// Vars that are non-function values must be deref’d:
IFn printLength = Clojure.var("clojure.core", "*print-length*");
cl_deref.invoke(printLength);

// Use Clojures `require` to import libraries (must be on the classpath):
cl_require.invoke(Clojure.read("clojure.set"));
IFn union = Clojure.var("clojure.set", "union");
Object s = union.invoke(Clojure.read("#{:a :b}"), Clojure.read("#{:c :b}"));
// Use Clojures `println` to print Clojure values:
System.out.println(cl_println.invoke(s));

// `IFn`s can be passed to higher order functions:
IFn map = Clojure.var("clojure.core", "map");
IFn inc = Clojure.var("clojure.core", "inc");
map.invoke(inc, Clojure.read("[1 2 3]"));
#+end_src

*** In Scala:

? ~clojure~ package is already on the classpath

For libraries from *Clojars*, specify in =build.sbt=:
#+begin_src sbt
resolvers += "clojars.org" at "https://repo.clojars.org"
libraryDependencies += "some.clojarslib" % "lib-name" % "0.1.0"
#+end_src

In =.scala= files, everything similar to [[In pure Java:]], except:
- ~Clojure.`var`(…)~ (~var~ must be in backticks)
- no need to specify ~IFn~ and ~Object~ types
- no need to invoke Clojures ~println~, just use the one from Scala

** Type hints

Note: primitive type hints are not supported on protocol functions.
- [[https://clojure.org/reference/protocols][Source]]
