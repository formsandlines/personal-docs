#+TITLE: Docs / GNU Emacs Calculator
#+STARTUP: align shrink

Stack-based calculator in reversed polish notation (RPN).

Resources:
- [[info:Calc#Top][The GNU Emacs Calculator *info*]] (Introduction, Tutorial, Reference)

* Startup & IO
Invoke GNU Emacs Calculator functions:
: C-x * … : calc-dispatch

Toggle Calc modes:
- ~… c : calc~ → toggle Calc
- ~… q : quick-calc~ → use /Quick mode/ for quick /minibuffer/ calculations
- ~… k : calc-keypad~ → use /Keypad mode/ for a /mouse-based/ interface
- ~… e : calc-embedded~ → toggle /Embedded mode/ for /in-buffer/ calculations
- ~… w : calc-embedded-word~ → toggle /Embedded mode/ for a single “word”
- ~… j : calc-embedded-select~ → (?) toggle /Embedded mode/ for a selected part

Input to/from Calc:
- ~… y : calc-copy-to-buffer~ → /yank/ from Calc into current editing buffer
- ~… g : calc-grab-region~ → /grab/ numbers from /region/ into a /vector/
  - with ~C-u~ prefix, interprets the region as a single /formula/ instead
- ~… r : calc-grab-rectangle~ → /grab/ numbers from /rectangle/ into a /matrix/
- ~… : : calc-grab-sum-down~ → /grab/ /rectangle/ & compute its /column sums/
- ~… _ : calc-grab-sum-across~ → /grab/ /rectangle/ & compute its /row sums/

Calc setup:
- ~… x : calc-quit~ → exit Calc
- ~… 0 : calc-reset~ → reset Calc to its /initial state/: empty stack, initial
  mode settings
- ~… b : full-calc~ → toggles expansion of Calc to /full screen/ height
- ~… o : calc-other-window~ → like ~c~, but doesn’t select the Calc window
  - if Calc is already open and point is in another window, closes Calc
  - if the point is in Calc window, switches out to another window
  - use in combination with ~c~ to switch in and out of Calc quickly

… (many more, see [[info:Calc#Other C-x * Commands][Calc#Other C-x * Commands]])

** Calculator Modes
*Quick mode* prompts for a formula in /standard notation/. The result will be
shown in the /minibuffer/ and also appear in the /kill ring/ to be yanked into
the editing buffer.
- ~$~ in the formula can use the previous result as input

*Keypad mode* is designed like a real calculator layout and intended to be
used with the mouse.

*Embedded mode* is a way to use Calc directly inside an editing buffer. Emacs
reads and (invisibly) pushes the formula onto the Calc stack. It can be
manipulated using the usual Calc keys, which replaces the old formula by the
result copied from the stack.
- ~calc-embedded~ can be invoked with the point /on a formula separated by a
  blank line above and below/.
- ~calc-embedded-word~ can be invoked with the point /on a single number/ (or
  “word”) inside text.
- type ~C-x * e/w~ again to exit embedded mode
- if mode settings are changed, Calc adds them as TeX comments above
  - *Note:* earlier annotations will also affect editing of formulas later in
    the buffer, so they either need to be removed or overwritten by later
    ones

* General Commands
- ~q : calc-quit~ → exit calculator
- ~U : calc-undo~ → undo input
- ~D : calc-redo~ → redo input
- ~y : calc-copy-to-buffer~ → copy top of stack into editing buffer
- ~' : calc-algebraic-entry~ → enter an algebraic formula

Getting Help:
: h … : calc-help-prefix
- ~… k~: keybinding
- ~… f~: function
- ~… s~: summary
- type ~?~ (repeatedly) after a prefix key to see the prefixed commands in the
  minibuffer as a short reference
- ~u v~ shows a list of all built-in units

* Stack Manipulation
- ~RET / SPC : calc-enter~ (without input) → duplicate the top of the stack
- ~M-RET : calc-last-args~ → restores args of the last command to the stack
- ~DEL : calc-pop~ → delete/pop top entry from stack
- ~M-DEL : calc-pop-above~ → delete/pop second-to-top entry from stack
- ~TAB : calc-roll-down~ → rotate top 2 elements /downwards/ (swaps them)
  - top element in stack will be moved to /n/-prefixed (default: 2nd) place
- ~M-TAB / C-M-i : calc-roll-up~ → rotate top 3 elements /upwards/
  - /n/-prefixed (default: 3rd) element in stack will be moved to the top

Commands to handle larger formulas or numbers:
- ~< : calc-scroll-left~ → left horizontal scrolling
- ~> : calc-scroll-right~ → right horizontal scrolling
- ~` : calc-edit~ → edit the stack entry directly

Numeric prefixes change stack element selection for some commands (like
~calc-enter~ and ~calc-pop~):
- /numeric prefix/ operates on *all top n elements* from the stack
- /negative numeric prefix/ operates on the *nth element* of the stack
- /0-numbered prefix/ operates on the *entire stack*

* Trail
The /trail/ records everything that happens on the stack.
- ~t d : calc-trail-display~ → toggle display of the trail
- ~t i : calc-trail-in~ → move point inside trail window
- ~t o : calc-trail-out~ → move point back to calc window

The *trail pointer* is marked by a little ~>~ in front of a trail entry.

Trail pointer movement:
- ~t [ : calc-trail-first~ → move trail pointer to /first/ entry
- ~t ] : calc-trail-last~ → move trail pointer to /last/ entry
- ~t p : calc-trail-previous~ → move trail pointer to /previous/ entry
- ~t n : calc-trail-next~ → move trail pointer to /next/ entry
- ~t s : calc-trail-isearch-forward~ → /search/ & move trail pointer to that entry
- ~t r : calc-trail-isearch-backward~ → like ~t s~, but search backwards

Trail usage:
- ~t y : calc-trail-yank~ → /yank/ current trail entry onto stack
  - creates new trail entry

* Evaluation
Fully interpretable formulas will always be directly evaluated on the stack.

Formulas with variables are inserted uninterpreted even if their variables
have been already assigned.

To evaluate/reduce an algebraic formula with variables:
: = : calc-evaluate
- if a variable has no assigned value, it is left untouched
- if a call to a function is undefined (either its name or for the arguments
  passed), it is also left alone

If the evaluation of a formula failed, an explanation can be given with:
: w : calc-why


A formula can be separated from its evaluation by writing the ~=>~
(~evaluates-to~) operator at the end. On the stack, it will look like this:
: <input formula> => <evaluated formula>
- the evaluated formula will be updated whenever the value of one of its
  variables changes

The command ~s = : calc-evalto~ creates the same structure from a previously
entered formula on the stack.

* Algebraic Notation
:PROPERTIES:
:CUSTOM_ID: notation
:END:
Enter a formula with ~' : calc-algebraic-entry~.
- ~$~ always enters algebraic entry

Toggle *Algebraic mode* to avoid having to type ~'~ every time:
: m a : calc-algebraic-mode
- if a formula starts with a function name, the ~'~ is still necessary

Numbers can be entered in *different bases* by prepending ~N#~ for a base /N/.
- entry will be converted with the users base setting (see [[#display-commands][Display Commands]])

*Scientific notation* is used by Calc automatically whenever a number has too
many extra zeros, e.g. ~2.^10000~ => ~1.99506311689e3010~ .
- the user can also enter a number directly in this notation, but it will
  result in a /floating-point/ number instead of an integer (e.g. ~2.^1e4~ =>
  ~2.^10000.~ => ~1.99506311678e3010~ – note the difference!)

Element types:
- Integer :: e.g. ~42~
- Floating-point Number :: e.g. ~2.~ (= ~2.0~), ~3.41~
- Complex Number :: e.g. ~(0, 2)~
- Vector :: e.g. ~[1 2 3]~
- Matrix :: e.g. ~[[1 5] [2 6]]~
- HMS Form :: e.g. ~2@ 30' 15"~ (hours, minutes, seconds)
- Date Form :: e.g. ~<Fri Dec 25, 1987>~, ~<6:45:18pm Sat Apr 13, 2024>~
  - many common input formats allowed
- Error Form :: e.g. ~8 +/- 0.2~ (mean value, standard deviation)
- Group :: for explicit order of evaluation, e.g. ~(3*4)~
- Operator :: e.g. ~+~, ~-~ , ~*~, ~/~, ~^~
  - ~a b~ is another way to write ~a*b~
  - *NOTE:* ~a(1+2)~ will be interpreted as a function call; write ~a*(1+2)~ instead
- Fraction :: e.g. ~1:2~, ~2:1:2~ (2 1/2)
- Variable :: e.g. ~a~, ~x~
  - Unit :: e.g. ~m/h~, have to be entered algebraically (using ~'~)
- Equations :: e.g. ~[x + y = a, x y = 1]~
- Function :: e.g. ~sqrt(36)~
- Nameless Function :: e.g. ~<#1 - #2>~ (corresponding to ~$$-$~)
- Stack Reference :: ~$~ for 1st stack element, ~$$~ for 2nd, ~$$$~ for 3rd, etc.
  - consumes/pops the stack

Constants:
- Infinity :: ~inf~, ~-inf~ (e.g. from ~ln(0)~ in /infinity mode/)
- Undirected Infinity :: ~uinf~ (e.g. from dividing by 0 in /infinity mode/)
  - see graph of ~1 / x~ around point ~x = 0~
- Indeterminate Number :: ~nan~ (e.g. from subtracting infinities)
- Euler’s Number :: ~e~
- PI :: ~pi~

** Operator Precedence
~^~ → ~*~ → ~/~ → ~+~ → ~-~

By default, /multiplication has precedence over division/ and is /right
associative/, so ~a/b*c~ will be interpreted as ~a/(b*c)~.
- to change this, set variable ~calc-multiplication-has-precedence~ to nil

Operator precedence is not affected by spaces, so ~a/b*c~ = ~a/b * c~ = ~a/b c~.

Evaluation of operators at the same level is /left to right/, except with ~^~,
which is /right to left/.
- e.g. ~2-3-4~ = ~(2-3)-4~, but ~2^3^4~ = ~2^(3^4)~

** Variables
A variable name should consist of one or more letters or digits, beginning
with a letter.

To store the top stack number in a variable, leaving it on the stack::
: s s : calc-store
Like above, but removes the number from the stack:
: s t : calc-store-into
To unstore a specific variable (unbind its value):
: s u : calc-unstore

To edit a stored variable (in a temporary buffer):
: s e : calc-edit-variable
To edit the /EvalRules/, which store automatically applied rewrite rules:
: s E : calc-edit-EvalRules

Retrieving a variable’s value can be either by function ~calc-recall~ or by
typing it inside a formula.

To recall a variable’s value on the stack:
: s r : calc-recall

A “quick variable” (~q0~ … ~q9~) can be quickly stored and recalled by shorthand
commands with the variable digit (using e.g. ~s 3~, ~t 3~, ~r 3~).

* Display Commands
:PROPERTIES:
:CUSTOM_ID: display-commands
:END:
*Note:* display commands do not affect how a number is stored in memory, only
how it is displayed.
- only the current /precision/ governs the actual rounding of numbers in memory

Prefix ~H~ before any display command, to prevent it from updating the stack.
- only new entries or updated old entries (including by stack manipulation)
  will appear in the new format
- ~d SPC : calc-refresh~ still updates the whole stack afterwards

  
Formula display *language*:
- ~d N : calc-normal-language~ → default
- ~d B : calc-big-language~ → big math formulas
- ~d C : calc-c-language~ → C language
- ~d T : calc-tex-language~ → TeX typesetting
- ~d L : calc-latex-language~ → LaTeX typesetting
- …

  Example of big math formulas:
  :            ________                ________
  :           |  2                    |  2
  :          \| a  - 4  - a      a - \| a  - 4
  : [x = a + --------------, y = --------------]
  :                2                   2
  from normal language:
  : [x = a + (sqrt(a^2 - 4) - a) / 2, 
  :  y = (a - sqrt(a^2 - 4)) / 2]

/floating-point/ display *notation*:
  - number of decimal places defaults to users precision setting
  - /numeric prefix/ changes number of shown decimal places to /n/
    - gets filled with (vanishing) 0s if precision is too small, which may
      become “garbage digits” when viewed in other bases than 10
  - /negative argument/ + numeric prefix changes to /default - n/ decimal places
- ~d n : calc-normal-notation~ → default
- ~d f : calc-fix-notation~ → fixed-point
- ~d s : calc-sci-notation~ → scientific notation
- ~d e : calc-eng-notation~ → engineering notation
  
  *Note:* rounding due to fewer decimal places shown may result in numbers that
  look the same, but are different internally (see [[info:calc#Modes Answer
  1][calc#Modes Answer 1]]).
  - set ~d n~ precision a little higher than normal to avoid this

/fraction/ display:
- ~d o : calc-over-notation~ → enter 1 or 2 fraction separators (default: ~:~)
  - two symbols (e.g. ~+:~) for an integer plus fractional part (e.g. ~1+3:4~)
  - when followed by a number (e.g. ~:10~, ~+/3~), Calc tries to adjust all
    fractions to have the specified denominator or, if not possible, adjust
    the denominator to be a multiple of that value
  - see [[info:Calc#Fraction Formats][Calc#Fraction Formats]] for more infos

Grouping of digits:
- ~d g : calc-group-digits~ → group digits into chunks of 3 (4 in base 2 & 16)
  - /numeric prefix/ changes chunk size
  - /negative argument/ + numeric prefix also groups decimal places
- ~d , : calc-group-char~ → change grouping char (default: ~,~)

Base /N/ representation:
- ~d r : calc-radix~ → change representation to given /base/
- ~d 0 : calc-decimal-radix~ → shorthand for ~d r 10~
- ~d 2 : calc-binary-radix~ → shorthand for ~d r 2~
- ~d 6 : calc-hex-radix~ → shorthand for ~d r 16~
- ~d 8 : calc-octal-radix~ → shorthand for ~d r 8~

  Numbers can be entered in any base, see [[#notation][Algebraic Notation]].

  *Note:* if the radix is >= 15, the letter ~e~ (for exponent) will be interpreted
  as a digit, so it cannot be used.
  - use /algebraic mode/ to enter the exponent explicitly (~X*B^N~) or type ~X
    <RET> e N <RET> *~ for a number /X/ with exponent /N/ for the chosen base /B/

Leading zeros (e.g. for binary numbers):
- ~b w : calc-word-size~ → set /word size/ (default: 32 bits)
- ~d z : calc-leading-zeros~ → toggle leading zeros according to /word size/

Result/stack alignment:
- ~d = : calc-center-justify~ → center results
- ~d < : calc-left-justify~ → align results to the left
- ~d > : calc-right-justify~ → align results to the right

Annotations:
- ~d } : calc-right-label~ → add righthand label
- ~d { : calc-left-label~ → add lefthand label
  
* Numeric Precision
:PROPERTIES:
:CUSTOM_ID: precision
:END:
The default *floating-point precision* is 12.

To change floating-point precision to given number:
: p : calc-precision
- if the number before the decimal point is > 0, its digits will count too
- *Note:* numbers on the stack that have more digits will be /rounded down/ to the
  current precision before they are used in calculation
- *Note:* when raising a number to a floating-point power, the result may be
  /slightly less accurate/ than raising to an integer power, since the algorithm
  Calc uses there is different (see [[info:Calc#Modes Tutorial][Calc#Modes Tutorial]])
  - to be safe, always include a few extra /guard digits/ on top
- *Note:* floating-point numbers are always /stored in decimal/, so even though an
  exact number was entered, it may be rounded after being processed in decimal
  (e.g. ~3#0.1~ becomes ~0.333…~ and as such ~3#0.022…~ in base 3)
  - use fractions (~x:y~) to avoid imprecision

To convert a floating-point to an integer:
: F : calc-floor
To convert an integer to a floating-point:
: c f : calc-float
To convert an number to a fraction:
: c F : calc-fraction

To /round/ a floating-point number:
: R : calc-round

To “clean” the number on the top of the stack:
: c c : calc-clean
- /re-rounds/ floating-point numbers to the current precision
  - with /numeric prefix/, sets the /precision/ to that number (duration of call)
  - a negative or zero prefix /decreases/ the precision by that number
- /normalizes/ polar numbers, whose angular components have deviated from the
  -180 to +180 range (use the same angular mode for best results)
- vectors and formulas are cleaned by cleaning each component number
- no effects on integers and fractions

Shorthand for ~c c~ with a corresponding negative prefix argument:
: c <0-9> : calc-clean-num
- reduces the floating-point precision by /N/ digits while re-rounding
- good to fix roundoff errors, e.g. ~c 1~ on ~1.99999~ with precision 6 rounds the
  number to ~2~
- turns integer-valued floats into integers (e.g. ~2.~ becomes ~2~), except for
  very large ones
- *Note:* decreases very small floats to zero, if the exponent <= the specified
  precision (e.g. ~c 2~ with prec. 12 on ~1e-10~ becomes ~0~)
  - avoid using these commands for very small numbers, use ~c c~ instead

* Modes of Operation
Default mode line:
: --%*-Calc: 12 Deg       (Calculator)----All------
- ~12~ means floating-point precision to 12 significant figures
- ~Deg~ means angles are interpreted as degrees

See [[#precision][Numeric Precision]] for details on how to change floating-point precision.

*Fraction mode* produces fractions in integer division instead of floats:
: m f : calc-frac-mode
- return to floating-point results by prepending the /negative argument/
- use ~d o ::~ to always display mixed fractions

*Angular modes*:
- ~m r : calc-radians-mode~ → interpret in radians
- ~m d : calc-degrees-mode~ → interpret in degrees
- ~c r : calc-to-radians~ → convert to radians
- ~c d : calc-to-degrees~ → convert to degrees

  Example: ~45 m d S~ yields the same number as ~P 4/ m r S~

*Infinity mode* in which ~1 / 0~ results in a representation of infinity instead
of being left unevaluated:
: m i : calc-infinite-mode

*Symbolic mode* leaves formulas like ~sqrt(5)~ that can’t be evaluated exactly in
symbolic form instead of giving an approximate answer:
: m s : calc-symbolic-mode

** Saving Mode Settings across Sessions
- ~m m : calc-save-modes~ → save all current mode settings
  - the save-file is defined in the ~calc-settings-file~ variable
  - the default save-file is =~/.emacs.d/calc.el=
  - includes everything controlled by the ~m~ and ~d~ prefix keys, the current
    precision and binary word size, whether or not the trail is displayed,
    the current height of the Calc window, etc.
- ~m R : calc-mode-record-mode~ → like ~m m~ every time a mode setting changes
  - this “automatic mode recording” mode is also saved
  - ~m R~ again disables it (must be saved with ~m m~ to disable permanently)

* Math Functions
** General
| <16>            | <12>      | <38>                                           |
| Command key(s)  | Formula   | Meaning                                        |
|-----------------+-----------+------------------------------------------------|
| ~:~               | ~a:b~       | enter rational number                          |
| ~( r i )~         | ~(r, i)~    | enter complex number                           |
| ~<a> M <n>~       | ~a mod n~   | enter modulo form                              |
| ~n~               |           | change sign (positive/negative)                |
| ~k r~             | ~random(x)~ | generate random number from top stack          |
|-----------------+-----------+------------------------------------------------|
| ~c f~             |           | convert rational number to float               |
| ~c F~             |           | convert float to rational number               |
| ~c p~             |           | convert complext number to polar form          |
|-----------------+-----------+------------------------------------------------|
| ~u v~             |           | show list of all built-in units                |
| ~u c <unit>~      |           | convert between units (e.g. ~m/s~)               |
| ~u b~             |           | convert to base units (shorthand for ~u c base~) |
| ~u t <temp-unit>~ |           | convert betw. /absolute/ temperature units       |
| ~u s~             |           | simplify units                                 |
|-----------------+-----------+------------------------------------------------|
| ~a =~             |           | compare if equal                               |
| ~a <~ / ~a >~       |           | compare if smaller/greater                     |

Functions can also be invoked using ~x~, which is like ~M-x~ but with ~calc-~
prefixed.

_Operators_

*Negative numbers* can ether be entered with the prefix ~_~ (~-~ is bound to
subtraction) or by changing the sign with ~n~ afterwards.

Both, /binary/ (e.g. ~+~, ~-~, ~*~, ~/~, ~^~) and /unary operators/ (e.g. ~n~, ~Q~, ~&~) can be
applied to /n/ stack elements by using a *numeric prefix*.
- e.g. ~M-3 +~ adds the top 3 numbers on the stack

/Binary operators/ can also be applied /pairwise/ to stack elements by adding the
*negative prefix* to a numeric prefix.
- e.g. ~M-- M-3 +~ adds the top number to the 3 numbers after it

The pipe ~|~ “concatenates” numbers, vectors and matrices together.

_Units_

Calling ~u c~ on a /number/ (instead of a formula with a unit), prompts to enter
the old and new units and converts accordingly without explicitly attaching
any unit.

When converting temperature units (like ~degF~ or ~degC~) with ~u c~, Calc
interprets them as /changes/ of temperature. Use ~u t~ to convert between
/absolute/ temperature units instead.

_Randomness_

~k r : random(x)~ can be invoked with different *argument types* (either given
as a /numeric prefix/ or else taken from the /stack/):
- with a positive number /n/, generates a random number in range [0 /n/)
- with a negative number /n/, generates a random number in range (/n/ 0]
- with ~0.~, picks a /Gaussian-distributed/ random number (mean: 0, stddev: 1)
- with a vector /v/, selects a random element from /v/ (equal probability)
- see [[info:Calc#Random Numbers][Calc#Random Numbers]] for details

When ~random(x)~ is used in a formula applied to a vector, it will be
evaluated once and the same number used on each element. To avoid this,
define a *nameless function* instead.
- a nameless function will not be evaluated until it is used
- e.g. ~<#+random(2.0)>~ instead of ~$+random(2.0)~.

** Arithmetics
| <16>           | <12>      | <38>                                   |
| Command key(s) | Formula   | Meaning                                |
|----------------+-----------+----------------------------------------|
| ~+~ / ~-~ / ~*~ / ~/~  | ~x op y~    | add / subtract / multiply / divide     |
| ~f [~ / ~f ]~      |           | decrement/increment by 1 in last place |
| ~^~              | ~x^n~       | power                                  |
| ~Q~              | ~sqrt(x)~   | square root                            |
| ~I ^~ / ~& ^~      |           | nth root                               |
| ~&~              |           | reciprocal of a number, i.e. ~1 / x~     |
| ~\~              |           | integer quotient, i.e. ~/ F~             |
| ~%~              |           | remainder/modulo                       |
|----------------+-----------+----------------------------------------|
| ~P~              | ~pi~        | PI                                     |
| ~H P~            | ~e~         | Euler’s number /e/                       |
|----------------+-----------+----------------------------------------|
| ~e~              | ~e^x~       | power of /e/                             |
| ~H e~            | ~10^x~      | power of 10 (or write ~1e…~)             |
| ~L~              |           | natural logarithm (base-/e/)             |
| ~H L~            |           | base-10 logarithm                      |
| ~<n> B~          |           | base-~n~ logarithm                       |
|----------------+-----------+----------------------------------------|
| ~k p~            |           | test if number is prime                |
| ~k g~            | ~gcd(x,y)~  | greatest common denominator (gcd)      |
| ~k l~            | ~lcm(x,y)~  | least common multiple (lcm)            |
| ~k E~            | ~egcd(x,y)~ | extended gcd, returns ~[g, a, b]~,       |
|                |           | where ~g = gcd(x,y) = a x + b y~         |

_Modular Arithmetics_

Dividing /a mod m/ by an integer /x/ actually divides by /x mod m/, where Calc
[8]tries to find a number which, when multiplied by /x mod m/, yields the
original /a mod m/.
- if /m/ is prime and the divisor /x/ is not a multiple of /m/, it is always
  possible to find such a number
  - for non-prime /m/ it is only sometimes possible

Raising /a mod m/ to a power /x/ yields a number /b mod m/ such that /(a^x) % m/
equals /b/.

** Combinatorics
| <16>           | <12>        | <38>                                   |
| Command key(s) | Formula     | Meaning                                |
|----------------+-------------+----------------------------------------|
| ~!~              | ~fact(x)~     | factorial                              |
| ~f g~            | ~gamma(x)~    | Euler’s Gamma function                 |
| ~k c~            | ~choose(n k)~ | binomial coefficient (/n-choose-k/)      |
| ~k f~            |             | prime factors                          |
| ~k n~            |             | next prime number (prefix ~I~ for lower) |

** Vector Analysis
| <16>           | <12>      | <38>                                          |
| Command key(s) | Formula   | Meaning                                       |
|----------------+-----------+-----------------------------------------------|
| ~[ x y … ]~      | ~[x y …]~   | collect numbers in a vector                   |
| ~v l~            |           | get vector length (count of elements)         |
| + ~H …~          |           | - matrix (or higher dim.) size: [ d1 d2 … ]   |
| ~v u~            |           | unpack vector/matrix as stack elements        |
| ~v p~            |           | pack into vector/matrix                       |
| ~v x <n>~        |           | gen. vector of ~n~ indices [ 1 … ~n~ ]            |
|                |           | - negative ~n~ results in [ ~n~ … -1 ]            |
| + n,s,i ~C-u …~  |           | gen. ~n~ items, start from ~s~, increm. by ~i~      |
| ~v b <n>~        |           | build vector from ~n~ top stack elements        |
| ~v a <n>~        |           | (re)arrange vector to ~n~ columns (or ~n~-groups) |
|                |           | - if ~n~ = 0, flattens the vector               |
| ~v v~            |           | reverse vector                                |
| ~v S~            |           | sort vector in increasing order               |
| + ~I …~          |           | - decreasing order                            |
|----------------+-----------+-----------------------------------------------|
| ~v r <n>~        |           | extract row ~n~ from vector or matrix           |
| ~v c <n>~        |           | extract col ~n~ from vector or matrix           |
| + i ~C-u …~      |           | - apply index from top of stack instead       |
| + s..e ~C-u …~   |           | - index-range to extract of rows/cols         |
| + [i,…] ~C-u …~  |           | - vector of indices to extract of rows/cols   |
| + ~C-- <n> …~    |           | - /delete/ row/col instead                      |
| / if ~n~ = 0     |           | - extracts diag. elems of a sq. matrix as v.  |
| i ~a _~          | ~[…]_n~     | like ~v r~, where index is the top elem.        |
|                | ~[…]_i_j_…~ | for deep extraction with multiple indices     |
| s e ~v s~        |           | get subvector from second /s/ to (excl.) top /e/  |
|                |           | - same as ~v r~ with interval index             |
|                |           | - /s/e/ <= 0 is relative to the end of vec.     |
| + ~I …~          |           | - removes subvector from the vector           |
| ~v f~            |           | find first index of top elem. in second vec.  |
|                |           | - starts at 1, returns 0 when not found       |
|                |           | - with num. prefix, search starts at /n/        |
|----------------+-----------+-----------------------------------------------|
| ~v k~            |           | cons second element to top vector             |
| + ~H …~          |           | - append top element to second vector         |
| ~\vbar~              |           | append/concat top elem./vec. to vector        |
| + ~I …~          |           | - prepend/concat top elem./vec to vector      |
| + ~H …~          |           | - concat top vector to vector                 |
| + ~H I …~        |           | - concat top vector before second vector      |
| ~v h~            |           | get head / first element                      |
| + ~I …~          |           | - get tail / all but first element            |
| + ~H …~          |           | - get all but last element                    |
| + ~H I …~        |           | - get last element                            |
|----------------+-----------+-----------------------------------------------|
| ~[ a .. b ]~     |           | create a closed interval                      |
| ~( a .. b )~     |           | create an open interval                       |
|----------------+-----------+-----------------------------------------------|
| ~v M <op>~       |           | map vector with ~op~ (apply to each elem.)      |
| ~v R <op>~       |           | reduce vector with ~op~                         |
| ~v U <op>~       |           | reduce with ~op~ while accumulating results     |
|----------------+-----------+-----------------------------------------------|
| ~A~              | ~abs(v)~    | absolute value (→ lenght of the vector)       |
| ~+~              |           | vector addition                               |
| ~*~              |           | dot product                                   |
| ~v C~            |           | cross product of 3-dim. vector                |
| ~v D~            |           | calculate determinant                         |
| ~RET A /~        |           | normalize vector (divide by length)           |
|----------------+-----------+-----------------------------------------------|
| ~[ [ v ] … ]~    | ~[v; …]~    | collect vectors in a matrix                   |
| ~v i <dim>~      |           | gen. identity matrix of dimension ~dim~         |
| ~v d~            |           | gen. diagonal square matrix from top elem.    |
|                |           | - if vector, use all elements of it           |
|                |           | - if number, set numeric prefix for /n/ copies  |
| ~v t~            |           | transpose matrix                              |
| ~&~              |           | inverse of matrix (reciprocal)                |
|----------------+-----------+-----------------------------------------------|
| ~*~              |           | composition (matrix multiplication)           |
| ~/~              |           | divide matrices (multiply by the inverse)     |

*Note:* to speed up computation /significantly/ for very large vectors (1000+
elements), toggle abbreviation of vector display with ~v .~ and ~t .~ (for the
trail window).
- using ~t .~ loses the ability to get old vectors back from the trail
- when in ~v .~ mode, the full vector can still be seen with ~`~ (to edit)

_Map / Reduce_

With /binary operators/, ~v M~ applies the operation element-wise to both
corresponding components of the top two vectors on the stack.
- e.g. ~v M *~ on ~[2 3] [1 2]~ on the stack yields ~[2 6]~

Algebraic formulas can also be plugged into mapping and reduction functions,
where ~$~ then refers to the /current/ element in the vector (or ~$~ to the 1st,
~$$~ to the 2nd in a two-argument function, etc.).
- e.g. ~$$-$~ is equivalent to using the ~-~ operator

To /map/ over a vector using the *formula* on top of the stack, ~v M $~ applies it
to the vector after it, using a given /argument list/ as input to match vector
values to the variables in the formula.

_Intervals_

Intervals are always ascending and will be flipped accordingly when their
bounds values change to descending, keeping open/closed bounds.

** Date & Time
| <16>           | <12>       | <38>                                                                             |
| Command key(s) | Formula    | Meaning                                                                          |
|----------------+------------+----------------------------------------------------------------------------------|
|                | ~<…>~        | enter date form (various input formats)                                          |
| ~<h>@ <m>' <s>"~ | same       | enter HMS form                                                                   |
|----------------+------------+----------------------------------------------------------------------------------|
| ~t N~            |            | current date and time in date form                                               |
| ~x time~         |            | current time of day in HMS/modulo form                                           |
| (~M-<1-9>~) ~t P~  |            | extract part (prefix 1-9) of a date form                                         |
| ~t I~            |            | increment month                                                                  |
| ~t +~ / ~t -~      |            | add/subtract /x/ business days                                                     |
| ~t W~            |            | find beginning of the week from date                                             |
|----------------+------------+----------------------------------------------------------------------------------|
| ~t D~            |            | date to/from number (days since Jan 1, 1 AD)                                     |
| ~c h~            | ~hms(h,m,s)~ | convert real number(s) to HMS form (interpreted according to current angular mode) |

The /trigonometric/ functions accept HMS forms directly as input.

_Date Arithmetic_
- date form ~+~ / ~-~ number :: advances date by number of days
- date form ~-~ date form :: produces a difference measured in days
- date form ~*~ / ~/~ number :: is /undefined/
- HMS form ~+~ / ~-~ number ::
  - advances HMS by hours (integer) and minutes/seconds/etc. (decimal)
  - maps a number 0.5 to 30 minutes in the HMS form
- HMS form ~*~ / ~/~ number :: multiplies/divides HMS by that number (as expected)
- HMS form ~+~ / ~-~ date form :: advances date by amount of time

** Algebra
| <16>           | <12>                     | <38>                                                            |
| Command key(s) | Formula                  | Meaning                                                         |
|----------------+--------------------------+-----------------------------------------------------------------|
| ~a =~            | ~eq(a,b)~ / ~a = b~ / ~a == b~ | equality check, simplifies and equates undetermined expressions |
| ~a #~            | ~neq(a,b)~ / ~a != b~        | non-equality check, see ~a =~                                     |
| ~a !~            |                          | swap equality or boolean value                                  |
| ~a S <var, …>~   |                          | solve equation for given variable(s)                            |
| ~a .~            |                          | extract righthand side of equation                              |
| ~a r <rule>~     |                          | apply given rewrite rule                                        |
|----------------+--------------------------+-----------------------------------------------------------------|
| ~a x~            |                          | “expand” formula                                                |
| ~a c <x>~        |                          | collect terms involving ~x~                                       |
| ~a M~ ~<op>~       |                          | apply function to both sides of equation                        |
|----------------+--------------------------+-----------------------------------------------------------------|
| ~s l <var>~      |                          | “let”: temporarily assign the top value                         |
|                |                          | to a given variable and evaluate (~=~)                            |
|                |                          | the next expression on the stack                                |
|----------------+--------------------------+-----------------------------------------------------------------|
| ~a P <var>~      |                          | solve eq. using ~H a S~, returns vector of all solutions          |
| ~a i <var>~      |                          | integrate with given variable                                   |
| ~a d <var>~      |                          | take the derivative with given variable                         |

~a S~ normally returns a single “princ[ ...ipal” solution and picks ~+~ if it needs
to come up with an arbitrary sign (e.g. from a quadratic formula). If it
needs an arbitrary integer, it picks zero.
- a full solution can be obtained by using either ~a P~ or ~H a S~ instead
  - ~a P~ solves the eq. using ~H a S~ and returns a vector of all solutions
  - ~H a S~ may use a new variable ~s1~ to represent an /unknown sign/, which is
    supposed to be either ~+1~ or ~-1~; use ~s l~ to assign one of these values

If the input to ~s l~ is an equation with a variable on the lefthand side
(e.g. ~x = 1.5~), then no variable name needs to be entered.

_Rewrite rules_

Write like this: ~a := b~, where the /pattern/ ~a~ gets substituted by ~b~ using
/meta-variables/ to identify and match the relevant parts / /sub-formulas/.
- e.g. ~a r a/x + b/x := (a+b)/x~
- /meta-variable/ names are independent from variables in the target formula
- *Note*: special /constant variables/ like ~pi~, ~e~ or ~i~, etc. match literally
  (not as meta-variables)

*Apply* a rewrite rule with ~a r~ to a formula on top of the stack with the
given shape.

Prefer to *store the pattern* (as a formula) in a variable using ~s t~ and apply
it more conveniently by just typing the variable name in ~a r~.
- Calc compiles rules stored in variables into an optimized pattern-matching
  language and reuses that compiled version, which is much more efficient
- storing rewrite rules in the variable ~EvalRules~ ensures that they get
  automatically applied in a formula
  - *Note*: all Calc operations will run somewhat slower when ~EvalRules~
    contains any rules; unstore with ~s u EvalRules~ to un-store the variable

~a r~ also accepts a *vector of rewrite rules*. It then tries all the rules in
the vector against all parts of the given formula, repeating until no
further change is possible.
- the exact order of which rules are tried is rather complex
  - for any given subformula, earlier rules in the rule set will be tried
    before later ones
- for more infos, see [[info:calc#Nested Formulas with Rewrite
  Rules][calc#Nested Formulas with Rewrite Rules]]
- Calc repeats only up to 100 times; use a /numeric prefix/ to set a different
  repeat limit (~M-0 a r~ sets no limit at all)

Rewrite rules can be *conditional* by adding ~::~ after the rule and the desired
condition.
- e.g. ~sin(a + k pi) := sin(a) :: k % 2 = 0~ only applies the rule if ~k~ is
  an even number
- the stored pattern can be edited using ~s e~

Rewrite rules can be *recursive*, e.g.:
: [ fib(1) := 1,
:   fib(2) := 1,
:   fib(n) := fib(n - 1) + fib(n - 2) :: integer(n) :: n > 2 :: remember ]
storing this set of rules in a variable “fib” allows it to refer to itself
and, in this case, find the fibonacci number by pattern-matching.
- the conditionals on the last line ensure that ~fib(x)~ will not get caught
  in an infinite loop and ~fib(0)~ will also remain unevaluated
- the ~:: remember~ on the last line gets rid of needless recomputations if
  the same rule matches a pattern that was being matched before
  - for any successful match on a rule with ~:: remember~, Calc adds another
    rule that describes that match to the front of the rule set
  - e.g. if ~fib(7)~ is matched by the ~fib(n)~ rule and finally evaluates to
    ~13~, then ~fib(7) := 13~ will be added to the rule set

** Geometry
| <16>           | <12>         | <38>                                    |
| Command key(s) | Formula      | Meaning                                 |
|----------------+--------------+-----------------------------------------|
| ~f h~            |              | hypothenuse, i.e. ~sqrt(a^2 + b^2)~       |
|----------------+--------------+-----------------------------------------|
| ~S~ / ~s S~        | ~sin(x)~       | sine of /n/                               |
| ~C~ / ~c C~        | ~cos(x)~       | cosine of /n/                             |
| ~T~ / ~t T~        | ~tan(x)~       | tangent of /n/                            |
| ~I S~ / ~I s S~    | ~arcsin(x)~    | inverse sine                            |
| ~I C~ / ~I c C~    | ~arccos(x)~    | inverse cosine                          |
| ~I T~ / ~I t T~    | ~arctan(x)~    | inverse tangent (slope → angle)         |
| ~f T~            | ~arctan2(x,y)~ | inverse tangent from quotient of a pair |
|----------------+--------------+-----------------------------------------|
| ~H S~            | ~sinh(x)~      | hyperbolic sine                         |
| ~H C~            | ~cosh(x)~      | hyperbolic cosine                       |
| ~H T~            | ~tanh(x)~      | hyperbolic tangent                      |
| ~I H S~          | ~arcsinh(x)~   | inverse hyperbolic sine                 |
| ~I H C~          | ~arccosh(x)~   | inverse hyperbolic cosine               |
| ~I H T~          | ~arctanh(x)~   | inverse hyperbolic tangent              |

** Bitwise Operations
| <16>           | <12>    | <38>                            |
| Command key(s) | Formula | Meaning                         |
|----------------+---------+---------------------------------|
| ~b t~            |         | rotate number 1 bit to the left |
| ~b l~ / ~b r~      |         | left/right bit shift            |

** Statistics
| <16>              | <12>            | <38>                               |
| Command key(s)    | Formula         | Meaning                            |
|-------------------+-----------------+------------------------------------|
| ~<mean> p <stddev>~ | ~mean +/- stddev~ | enter an error form                |
|                   | ~sdev(a,b)~       | build an error form from arguments |
| ~v u~               |                 | unpack error form                  |
|-------------------+-----------------+------------------------------------|
| ~a F~               |                 | apply least-squares fit            |

* Graph Output
:PROPERTIES:
:CUSTOM_ID: graphs
:END:
Requires *GNUPLOT* program:
1. install ~gnuplot~ command-line app – e.g. on MacOS:
   : $ brew install gnuplot
2. install ~gnuplot~ Emacs package:
   : (use-package gnuplot :ensure t)

*Plotting device* may have to be set in advance to properly generate the plot.
- ~qt~ works for viewing graphs in a separate graphics window
  - *Note:* don’t quit the ~gnuplot_qt~ app directly, just close the window, leave
    it open or quit GNUPLOT in Calc with ~g q~ to avoid malfunction

Basic Commands:
- ~g f : calc-graph-fast~ → quick & simple data plot
  - takes 2 vectors of equal length from stack (1: y values, 2: x values)
  - plots a basic line graph with points represented by symbols
- ~g p : calc-graph-plot~ → (re)draw graph as described in ~*Gnuplot Commands*~
- ~g a : calc-graph-add~ → add curve from top 2 values on stack to existing plot
  - type ~g p~ again to plot the new curve on top of the existing graph
- ~g q : calc-graph-quit~ → terminate GNUPLOT
- ~g c : calc-graph-clear~ → clear the current plot
- ~g D : calc-graph-device~ → set plotting device
- ~g C : calc-graph-command~ → enter GNUPLOT command

Graph Style:
- ~g S : calc-graph-point-style~ → toggles symbols at data points on/off
- ~g s : calc-graph-line-style~ → toggles lines between data points on/off
- ~g g : calc-graph-grid~ → toggles grid on/off

* Macros
The built-in Emacs macro system can be used in Calc too.

Record a macro (start → do stuff → end):
: C-x ( : kmacro-start-macro
: C-x ) : kmacro-end-macro

Call the recorded macro (or end recording):
: C-x e : kmacro-end-and-call-macro

* Programming
** Using Formulas
Generate a user-defined command from the formula on top of the stack:
: Z D : calc-user-define

The command is given a shortcut key and can be applied just like any other
Calc function to the stack.

** Using Emacs Lisp
The ~defmath~ macro extends the basic ~defun~ function to define math functions
to be used by Calc.

Example:
#+begin_src elisp
(put 'calc-define 'thing
     '(progn
	(defmath falld
	  ;; define argument 't' as a scalar float
	  ((float (scalarp t))) 
	  ;; set command to be usable in algebraic expressions
	  (interactive 1 "falld")
	  ;; define the formula
	  (/ (* 98 (/ (^ t 2)) 2) 100))))
#+end_src

The function can then be used in an algebraic formula in Calc, e.g. like
~4*falld(5)~.

* Known Bugs/Issues
When a different font and/or line-height has been set, the trail window might
not follow new Calc entries, because the window height results in a
chopped-off line at the bottom.

For some reason, setting ~calc-window-height~ directly does not fix this and it
can only be fixed by setting the frame height to a very specific pixel size
(which needs some experimentation).
- even changing just the font without the ~:height~ property may cause this
- a different line-height might also mess up the cursor position, so that it
  sometimes appears on the center of the Calc or trail window and keeps
  jumping there when new entries are made or ~t ]~ is invoked
