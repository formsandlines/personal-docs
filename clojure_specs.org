#+title: Docs/Clojure/Specs

Docs:
- Specs: https://clojure.github.io/spec.alpha/index.html
- Generators: https://clojure.github.io/test.check/clojure.test.check.html
- Resources: https://clojure.org/community/resources#spec

Spec Rationale:
- https://clojure.org/about/spec

Guides:
- https://clojure.org/guides/spec
- /Getting Clojure/, chapter 15 (p.175+)
- https://blog.taylorwood.io/2017/10/15/fspec.html
- Generators: https://clojure.github.io/test.check/intro.html

Best practices:
- https://clojureverse.org/t/what-is-2021-recommendation-for-specs/7508/4
- https://corfield.org/blog/2019/09/13/using-spec

Successor (WIP):
- https://github.com/clojure/spec-alpha2
- main difference: https://github.com/clojure/spec-alpha2/wiki/Schema-and-select



src_clojure{ (require '[clojure.spec.alpha :as s]) }


* 3rd-party extensions/libraries

Strings that include Unicode characters, generated from a regex
- https://github.com/gfredericks/test.chuck

Complete instrumentation (not only ~:args~) in function specs:
- https://github.com/jeaye/orchestra

* Usage

** Instrumentation

** Assertions

*** : *compile-asserts*

If true, compiler will enable spec asserts, which are then subject to runtime
control via check-asserts? If false, compiler will eliminate all spec assert
overhead.

** Input validation

Q/A from:
https://clojurians.slack.com/archives/C1B1BB2Q3/p1650359089658499?thread_ts=1650356728.738089&cid=C1B1BB2Q3

*** Q1: what does "validating inputs from external systems or users" refer to? using
function ~:pre [...]~ conditions? what spec functions should i use, if not
~s/assert~?

-> I would suggest using a construct like

#+begin_src clojure
(when-not (s/valid? ::spec data)
  (throw (ex-info "error in..." {:error-data error-data}))
#+end_src

because asserts (and pre-posts i think) can be disabled by various options to
the JVM. Be explicit with your throws after validation.

*** Q2: is there a way to do something like ~instrument~, but only for checking
~:args~, so i wouldn't need to repeat such logic as function ~:pre~ conditions?

-> I would not recommend using ~instrument~ or ~pre~ when validating input from
users or other systems. Rather make this validation a separate step in the
processing of data. The way to handle incorrect data can differ between various
systems and sources of data.

* Spec definition

The primary operations for defining specs are ~s/def~, ~s/and~, ~s/or~, ~s/keys~
and the regex ops.

** : (s/def <k> <spec-form/pred>)

Makes an entry in the registry mapping ~k~ to the ~spec~.
- ~k~ can be a namespace-qualified keyword or a resolvable symbol
- can be given a spec, spec-name, predicate or regex-op

Example:
src_clojure{ (s/def :book/title string?) }

* Spec connectives

** : (s/and & <pred>)

Validates true if all of the given predicates match.

*Note:* do not use with ~s/alt~ in functions specs, use ~s/&~ instead!

Successive conformed values propagate through rest of the predicates and can
then be reused:
#+begin_src clojure
(s/def ::foo
  (s/and (s/cat :int int?
                :str string?)
         #(== (:int %) (count (:str %)))))

(s/conform ::foo [3 "hi"]) ;=> :clojure.spec.alpha/invalid
(s/conform ::foo [3 "hai"]) ;=> {:int 3, :str "hai"}
#+end_src

Use ~s/nonconforming~ to remove conformed values (?)

** : (s/or & <key-pred-forms>)
e.g.
    : (s/or :even even? :small #(< % 42))

Validates true if either of the given predicates match.
- keywords are required to help producing coherent feedback on match fail

*Note:* in function specs ~:args~ for multi-arity fns, use ~s/alt~ instead

Example:
src_clojure{ (s/or :ok ::result :err ::error) }

* Spec maps

** : (s/keys & {:keys [req req-un opt opt-un gen]})
e.g.:
    : (s/keys :req [::x ::y] :opt [::z])
    : (s/keys :req-un [:my.ns/x :my.ns/y])
    : ...

Macro that creates and returns a map validating spec.
- ~:req~ and ~:opt~ are both vectors of ns-qualified keywords
- ensures that ~:req~ keys are present
- :opt serves as documentation
- keys can be grouped with ~and~ and ~or~ in ~:req~
  : (or ::secret (and ::user ::pwd))
- -un versions of ~:req~ and ~:opt~ allow unqualified keys in validated map
  - qualified names will be generated by specs (if they exist)

*** Examples

Must have both ~:book/title~ and ~:book/author~:
src_clojure{ (s/keys :req [:book/title :book/author]) }

Either ~{}~ or a map that can have ~:block/uid~ or ~:block/text~ keys:
#+begin_src clojure
(s/or :none (s/keys :req [])
      :some (s/keys :req [(or :block/uid
                              :block/kind)]))
#+end_src

** : (s/keys* & {:keys [req req-un opt opt-un gen]})
Same as ~s/keys~ but returns a regex op that matches seqs of kvs, converts
them into a map, and conforms that map with a corresponding ~s/keys~ call.
- for [[#keyword-arguments][keyword arguments]] in function specs
- see [[https://clojure.github.io/spec.alpha/clojure.spec.alpha-api.html#clojure.spec.alpha/keys*][keys* (spec reference)]]

** : (s/every-kv <kpred> <vpred> & opts)
Like ~s/every~, but takes separate key and val preds and works on associative
collections.
- same ~opts~ as ~s/every~

Example:
#+begin_src clojure
(s/conform (s/every-kv int? string?)
             {1 "a" 2 "b"}) ;=> {1 "a", 2 "b"}
#+end_src

** : (s/map-of <kpred> <vpred> & opts)
Returns a spec for a map whose keys satisfy ~kpred~ and vals ~vpred~.
- very similar to ~s/every-kv~, but will exhaustively conform every value.
- same ~opts~ as ~s/every~

** : (s/merge & pred-forms)

* Spec sequences

** : (s/alt & <key-pred-forms>)

Validates true if either one of the preds/patterns is matched in a sequence.
- requires descriptive keywords for coherent feedback

*WARNING:* elements are processed one-by-one, so it does work with ~s/cat~, but
not with e.g. ~s/coll-of~, which matches a sequence as a whole
- use ~s/alt~ for arities in function specs (together with ~s/cat~ or other
  regex specs) and ~s/or~ for sequential data

*** Examples
#+begin_src clojure
(s/def spec (s/alt :a string? :b int?))
(s/conform spec [12]) ; -> [:b 12]
(s/conform spec ["hi"]) ; -> [:a "hi"]
(s/conform spec [12 "hi"]) ; -> invalid
#+end_src

*** Differences to s/or :

With ~s/alt~, ~s/coll-of~ doesn’t work, because items are fed one by one in a
stream:
#+begin_src clojure
(s/conform (s/alt :int int?
                  :str (s/coll-of string?))
           ["a" "b" "c"]) ;=> :clojure.spec.alpha/invalid
#+end_src
Here, ~s/coll-of~ would get just ~"a"~ and fails to conform it.

But it does work with ~s/or~ where the sequence is processed as a whole:
#+begin_src clojure
(s/conform (s/or :int int?
                 :str (s/coll-of string?))
           ["a" "b" "c"]) ;=> [:str ["a" "b" "c"]]
#+end_src
So in this case, ~s/coll-of~ gets ~["a" "b" "c"]~ as a whole.

~s/alt~ works only with other regex specs such as ~s/cat~ or ~s/+~, but ~s/or~
treats every sequence/coll spec equally:
#+begin_src clojure
(s/def ::alt (s/alt :coll-of (s/coll-of int?)
                    :cat (s/cat :x keyword? :y keyword?)
                    :tuple (s/tuple string? string?)
                    :every (s/every symbol?)
                    :+ (s/+ float?)))

(s/def ::or (s/or :coll-of (s/coll-of int?)
                  :cat (s/cat :x keyword? :y keyword?)
                  :tuple (s/tuple string? string?)
                  :every (s/every symbol?)
                  :+ (s/+ float?)))

;; s/alt works only with regex specs:
(s/conform ::alt '(42 93)) ;; => :clojure.spec.alpha/invalid
(s/conform ::alt '([42 93])) ;; => [:coll-of [42 93]]
(s/conform ::alt '(:i :j)) ;; => [:cat {:x :i, :y :j}]
(s/conform ::alt ["a" "b"]) ;; => :clojure.spec.alpha/invalid
(s/conform ::alt '(("a" "b"))) ;; => :clojure.spec.alpha/invalid
(s/conform ::alt '(["a" "b"])) ;; => [:tuple ["a" "b"]]
(s/conform ::alt '(a b)) ;; => :clojure.spec.alpha/invalid
(s/conform ::alt '((a b))) ;; => [:every (a b)]
(s/conform ::alt '(1.5 2.5)) ;; => [:+ [1.5 2.5]]

;; s/or works with all specs:
(s/conform ::or '(42 93)) ;; => [:coll-of (42 93)]
(s/conform ::or '(:i :j)) ;; => [:cat {:x :i, :y :j}]
(s/conform ::or '("a" "b")) ;; => :clojure.spec.alpha/invalid
(s/conform ::or ["a" "b"]) ;; => [:tuple ["a" "b"]]  (must be vector)
(s/conform ::or '(a b)) ;; => [:every (a b)]
(s/conform ::or '(1.5 2.5)) ;; => [:+ [1.5 2.5]]

;; s/and also doesn’t mix well with s/alt, so use s/& instead:
(s/conform
 (s/alt :a (s/and (s/cat :x int? :y keyword?)
                  #(> (:x %) 2)))
 '(3 :x)) ;; => :clojure.spec.alpha/invalid

(s/conform
 (s/alt :a (s/& (s/cat :x int? :y keyword?)
                #(> (:x %) 2)))
 '(3 :x)) ;; => [:a {:x 3, :y :x}]

(s/conform
 (s/or :a (s/and (s/cat :x int? :y keyword?)
                 #(> (:x %) 2)))
 '(3 :x)) ;; => [:a {:x 3, :y :x}]
#+end_src

** : (s/cat & <key-pred-forms>)
e.g.
    : (s/cat :e even? :o odd?)

Validates true if the exact order, type and number of elements is matched.
- requires descriptive keywords for coherent feedback
- can be used to for ~:args~ in a function spec, for example

*Note:* ~s/cat~ should not be used to describe a sequential data structure, it
works more like a regex on multiple items. Similar to ~s/alt~ but as a
concatenation instead of an alternation.

*** Examples
src_clojure{ (s/cat :service any? :query string?) }
** : (s/tuple & <preds>)
* Spec functions
** : (s/fspec & {:keys [args ret fn gen] :or {ret `any?}})
Useful to spec higher order functions.

Example:
#+begin_src clojure
(defn adder [x] #(+ x %))

(s/fdef adder
  :args (s/cat :x number?)
  :ret (s/fspec :args (s/cat :y number?)
                :ret number?)
  :fn #(= (-> % :args :x) ((:ret %) 0)))
#+end_src

#+begin_src clojure
(s/def ::f (s/fspec :args (s/cat :x int?)
                    :ret  string?))

(s/conform ::f (fn [a] (str a))) ;=> #function[test7/eval15574/fn--15575]
(s/conform ::f (fn [a] a)) ;=> :clojure.spec.alpha/invalid
#+end_src

** : (s/multi-spec <multimethod> <retag>)
Takes the name of a spec/predicate-returning multimethod and a tag-restoring
keyword or function (~retag~). The returned spec will pass its data to the
multimethod to get an appropriate spec.
- each registered method must have one arg. that should be ignored

Example:
#+begin_src clojure
(defmulti op-spec :type)
(defmethod op-spec :add [_] #(s/valid? (s/every int?) (:args %)))
(defmethod op-spec :join [_] #(s/valid? (s/every string?) (:args %)))

(s/def ::op (s/multi-spec op-spec :type))

(s/conform ::op {:type :add :args [1 2]})
;=> {:type :add, :args [1 2]}
(s/conform ::op {:type :join :args ["mi" "su"]})
;=> {:type :join, :args ["mi" "su"]}
#+end_src

* Regex operations
“When regex ops are combined, they describe a single sequence. If you need to
spec a nested sequential collection, you must use an explicit call to spec to
start a new nested regex context.”

** : (s/* <pred>)

Matches 0 or more occurrences of a predicate/pattern.

** : (s/+ <pred>)

Matches 1 or more occurrences of a predicate/pattern.

** : (s/? <pred>)

Matches 1 or 0  occurrences of a predicate/pattern.

** : (s/& <regex> & <preds>)

Takes a regex op and further constrains it with one or more predicates.
- regex-counterpart to ~s/and~, can be used with e.g. ~s/cat~

* Spec collections

** : (s/coll-of <pred> & opts)

Validates true if a collection of items satisfies ~pred~.
- will exhaustively conform every value (unlike ~every~)
- same options as ~every~
- options:
  - ~:gen-max~ -> can be used to restrict generation number in tests
  - ~:kind~ -> predicate the collection type must satisfy
  - ~:count~ -> collection must have exactly this count
  - ~:min-count~, ~:max-count~ -> min/max count of elements required
  - ~:distinct~ -> all elements are distinct (default ~nil~)

Example:
src_clojure{ (s/coll-of string? :gen-max 3) }

** : (s/every <pred> & opts)

Takes a ~pred~ and validates collection elements against that pred.
- does not do exhaustive checking or conforming of elements

* Spec other objects

** : (s/spec <pred> & :gen <generator>)

Defines a spec from a predicate (usually not needed, use s/def instead)
- additional ~:gen~ option can be used to attach generators for tests
- (?) useful to specify that a nested regex starts anew vs being included in the
  same pattern

** UUIDs
src_clojure{ (s/spec #(instance? java.util.UUID %) :gen gen/uuid) }
In CLJS:
src_clojurescript{ (s/spec #(instance? cljs.core/UUID %) :gen gen/uuid) }

** Ranges

*** : (s/int-in <start> <end>)

Validates true if integer is in the range from start (incl.) to end (excl.).

*** : (s/double-in & :min :max :infinite? :NaN?)

Like ~s/int-in~ but for double ranges (64-bit floating point).
- ~:min~ & ~:max~ both inclusive, positive or negative
- ~:infinite?~: +/- infinity allowed (def. true)
- ~:NaN?~: NaN allowed (def. true)

*** : (s/inst-in <start> <end>)

Like ~s/int-in~ but for ranges of ~inst~ (dates in inst format).

**** Examples

src_clojure{ (s/inst-in #inst "2000" #inst "2010") }
** : (s/nilable <pred>)
Returns a spec that accepts ~nil~ and values satisfying ~pred~.

Example:
#+begin_src clojure
(def ::my-spec (s/nilable int?))
(valid? ::my-spec 2) ;=> true
(valid? ::my-spec 3.3) ;=> false
(valid? ::my-spec nil) ;=> true
#+end_src

* Validate matches

** : (s/valid? <spec> x) -> bool
: (s/valid? <spec> x form) -> bool

Returns true when ~x~ is valid for ~spec~.
- works with infinite lazy seqs.

** : (s/assert <spec> x)
* Debug matches

** : (s/explain <spec> x) -> nil

Prints explanation if value does not conform to spec.
- hangs on infinite lazy seqs

** : (s/conform <spec> x) -> fail: s/invalid | success: x

Returns the (possibly destructured) value on success or s/invalid on fail.
- can be used directly in implementations to get
  destructuring/parsing/error-checking
- useful for e.g. macro implementations and at I/O boundaries
- hangs on infinite lazy seqs

* Function Specs

** : (s/fdef <fn-sym> & <specs>)
e.g.:
    : (s/fdef <fn-sym>
    :   :args (s/cat <arg-k> <spec-for-arg>
    :                ...)
    :   :ret <spec-for-return-value>
    :   :fn (fn [{:keys [args ret]}] ...))

Registers a function spec for a defined function to validate inputs and outputs.
- ~:args~ takes a category spec with specs/preds on each argument as a key
- ~:ret~ takes a spec/pred for the return value
- ~:fn~ is called after return and takes as parameters a map with ~:args~ and ~:ret~
  keys whose values have been conformed by the matching specs

*** Examples

Use ~s/alt~ for functions with multiple arities:
- ~s/?~ can be used to include zero arity
#+begin_src clojure
(defn create-block
  ([] (create-block "" {}))
  ([content] (create-block content {}))
  ([content block-data]
   (merge {:block/uid (random-uuid)
           :block/content content
           :block/kind :p
           :block/children []} block-data)))

(s/fdef create-block
        :args (s/alt :with-data (s/cat :content :block/content
                                       :block-data ::block-data)
                     :content (s/? :block/content))
        :ret ::block)
#+end_src

** Keyword Arguments (since Clojure 1.11.0)
:PROPERTIES:
:CUSTOM_ID: keyword-arguments
:END:
See https://clojure.org/news/2022/03/22/clojure-1-11-0
- also [[https://clojure.atlassian.net/browse/CLJ-2606][[spec] kwarg invocation with a map requires spec update to keys*]]

Use ~s/keys*~ to spec keyword args.

: (defn with-opts-no-g
:   [& {:as opts}]
:   opts)
: 
: (s/fdef with-opts-no-g
:   :args (s/cat :opts (s/keys*)) 
:   :ret …)
- Source: [[https://clojurians.slack.com/archives/C053AK3F9/p1712158041984799][user sheluchin on Clojars]]

* Testing

src_clojure{ (require '[clojure.spec.test.alpha :as stest]) }

** : (stest/instrument 'my.namespace/my-fn)
: (stest/instrument)  ; for all instrumentable vars

Checks that functions are called with spec-conforming inputs.
- only validates that the ~:args~ spec is being invoked – ~:ret~ and ~:fn~ specs are
  not checked
- can generate a stub using the function spec for testing:

  src_clojure{ (stest/instrument `my-fn {:stub #{`my-fn}}) }
  - ~my-fn~ can be called, before even being written
    this can be helpful when testing another function that depends on it

** : (stest/unstrument 'my.namespace/my-fn)
: (stest/unstrument)  ; for all instrumented vars

To unstrument instrumented functions:

** : (stest/check 'my.namespace/my-fn)
: (stest/check)

Checks that the implementation of spec’d functions is correct.
- checking is disabled by default due to performance reasons
- generates conforming inputs to test a spec function
- verifies if return value is correct according to ~:ret~
- verifies if the semantic spec (~:func~) is correct

** : (stest/summarize-results <check-results>)

Pretty prints the summary-result of each given check-result (e.g. from ~check~).
- returns a map with the ~:total~ number of results
  & a key for each different ~:type~ of result

Example:
src_clojure{ (stest/summarize-results (stest/check `my-specd-fn)) }


* Generate data

** : (s/gen <spec>)
Produces a generator from given spec/predicate.

*** Examples

Predicates with mapped generators (like ~int?~) can be used with ~s/and~ to
apply predicates without generators (like ~even?~) as filters on their generated
values:
src_clojure{ (s/gen (s/and int? even?)) }

Generators can be created from a fixed set of values:
src_clojure{ (s/gen #{:my.domain/name :my.domain/occupation :my.domain/id}) }


** : (s/with-gen <spec> <gen-fn>)
Defines a spec with an associated custom generator.

*** Examples

A spec can be associated with the custom generator in the ~s/gen~ example like
this:
#+begin_src clojure
(s/def :ex/kws (s/with-gen (s/and keyword? #(= (namespace %) "my.domain"))
                 #(s/gen #{:my.domain/name :my.domain/occupation :my.domain/id})))

(s/valid? :ex/kws :my.domain/name)  ;; true
(gen/sample (s/gen :ex/kws))
;;=> (:my.domain/occupation :my.domain/occupation :my.domain/name  ...)
#+end_src


** : (s/exercise <spec>)
: (s/exercise <spec> n)
: (s/exercise <spec> n <overrides>)

Returns pairs of generated and conformed values for a spec.
- by default produces 10 samples, adjust with ~n~

** : (s/exercise-fn `my-specd-fn)

Like ~s/exercise~ but for spec’ed functions.
- invokes the function and returns the args and the return value as pair

** Generators

src_clojure{ (require '[clojure.spec.gen.alpha :as gen]) }

Use with ~s/gen~ to obtain a generator from a spec/predicate.

*** : (gen/generate <generator>)
Generates a single value using a generator.

*** : (gen/sample <generator>)

Generates multiple values using a generator.



*** Compound generators
**** : (gen/vector <generator>)

***** Examples

Generate vector of natural numbers:
src_clojure{ (gen/vector (gen/nat)) }

**** : (gen/list <generator>)

***** Examples

Generate list of booleans:
src_clojure{ (gen/list (gen/boolean)) }

**** : (gen/map <k-generator> <v-generator>)

***** Examples

Generate map of keywords to booleans:
src_clojure{ (gen/map (gen/keyword) (gen/boolean)) }

**** : (gen/hash-map & <key> <v-generator>)

***** Examples

Generate map of ~{:a <rand bool>, :b <rand int>}~:
src_clojure{ (gen/generate (gen/hash-map :a (gen/boolean) :b (gen/int))) }

**** : (gen/tuple <generator> <generator>)

Creates a generator of a tuple of two generators.

***** Examples

Generate tuple [int, boolean, ratio]:
src_clojure{ (gen/tuple (gen/nat) (gen/boolean) (gen/ratio)) }

Can Be used to generate specific values between random values:
#+begin_src clojure
(s/def :ex/hello
  (s/with-gen #(clojure.string/includes? % "hello")
    #(gen/fmap (fn [[s1 s2]] (str s1 "hello" s2))
      (gen/tuple (gen/string-alphanumeric) (gen/string-alphanumeric)))))
(gen/sample (s/gen :ex/hello))
;;=> ("hello" "ehello3" "eShelloO1" "vhello31p" "hello" "1Xhellow" ...)
#+end_src


*** Combinators

**** : (gen/fmap <fn> <generator>)

Maps a generator over a function to obtain a new generator.
The function will be applied to each sample produced by the generator.
- can be used to compose generators

***** Examples

Can be used to further process values from generators:
#+begin_src clojure
(def kw-gen (gen/fmap #(keyword "my.domain" %) (gen/string-alphanumeric)))
(gen/sample kw-gen 5)
;;=> (:my.domain/ :my.domain/ :my.domain/1 :my.domain/1O :my.domain/l9p2)
#+end_src

**** : (gen/such-that <pred> <generator>)
Specifies a filtering condition for a generator.

***** Examples

#+begin_src clojure
(def kw-gen-3 (gen/fmap #(keyword "my.domain" %)
               (gen/such-that #(not= % "")
                 (gen/string-alphanumeric))))
(gen/sample kw-gen-3 5)
;;=> (:my.domain/O :my.domain/b :my.domain/ZH :my.domain/31 :my.domain/U)
#+end_src

**** : (gen/bind <generator> <fn>)

Binds a function to a generator that gets the returned value of the generator as
input and returns a new generator.

***** Examples

Generator that returns a tuple of a randomly selected keyword from a generator
(that returns a vector of keywords) and the generated vector:
#+begin_src clojure
(def keyword-vector (gen/such-that not-empty (gen/vector gen/keyword)))
(def vec-and-elem
  (gen/bind keyword-vector
            (fn [v] (gen/tuple (gen/elements v) (gen/return v)))))

(gen/sample vec-and-elem 4)
;; => ([:va [:va :b4]] [:Zu1 [:w :Zu1]] [:2 [:2]] [:27X [:27X :KW]])
#+end_src


*** Recursive generators
**** : (gen/recursive-gen <compound-gen> <scalar-gen>)

Require: src_clojure{ [clojure.test.check.generators :refer [recursive-gen]] }

Creates a recursive structure generated from ~compound-gen~ for the containers
and ~scalar-gen~ for the values.

***** Examples

Tree of boolean vectors:
#+begin_src clojure
(def nested-vector-of-boolean (gen/recursive-gen gen/vector gen/boolean))
(last (gen/sample nested-vector-of-boolean 20))
;; => [[[true] true] [[] []]]
#+end_src

JSON-like structure:
#+begin_src clojure
(def compound (fn [inner-gen]
                  (gen/one-of [(gen/list inner-gen)
                               (gen/map inner-gen inner-gen)])))
(def scalars (gen/one-of [gen/small-integer gen/boolean]))
(def my-json-like-thing (gen/recursive-gen compound scalars))
(last (gen/sample my-json-like-thing 20))
;; =>
;; (()
;;  {(false false)  {true -3, false false, -7 1},
;;   {4 -11, 1 -19} (false),
;;   {}             {1 6}})
#+end_src


*** Primitives

**** : (gen/string-alphanumeric)
**** : (gen/boolean)
**** : (gen/keyword)

**** : (gen/uuid)

*** From data

**** : (gen/return <value>)
Creates a generator that always returns the ~value~ and never shrinks.

**** : (gen/elements <coll>)
Creates a generator that randomly chooses an element from ~coll~.

**** : (gen/shuffle <coll>)
Creates a generator that generates vectors with the elements of ~coll~ in
random orders.
