#+title: Docs/APL

Infos:
- [[https://www.jsoftware.com/papers/tot.htm][Notation as a Tool of Thought]] (Ken Iverson)

* Language
** Keyboard Layout
- https://dfns.dyalog.com/n_keyboards.htm
- https://dfns.dyalog.com/n_kbmac.htm
- https://www.dyalog.com/apl-font-keyboard.htm (download layouts here)

Dyalog Mac APL/en-GB keyboard:
: â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
: â”‚Â± âŒº â”‚! âŒ¶ â”‚@ â« â”‚Â£ â’ â”‚$ â‹ â”‚% âŒ½ â”‚^ â‰ â”‚& âŠ– â”‚* âŸ â”‚( â± â”‚) â² â”‚_ ! â”‚+ âŒ¹ â”‚Backspaceâ”‚
: â”‚Â§ â‹„ â”‚1 Â¨ â”‚2 Â¯ â”‚3 < â”‚4 â‰¤ â”‚5 = â”‚6 â‰¥ â”‚7 > â”‚8 â‰  â”‚9 âˆ¨ â”‚0 âˆ§ â”‚- Ã— â”‚= Ã· â”‚         â”‚
: â”œâ”€â”€â”€â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¤
: â”‚Tab    â”‚Q   â”‚W   â”‚E â· â”‚R   â”‚T â¨ â”‚Y   â”‚U   â”‚I â¸ â”‚O â¥ â”‚P â£ â”‚{ â â”‚} â¬ â”‚Enter â”‚
: â”‚       â”‚q ? â”‚w âµ â”‚e âˆŠ â”‚r â´ â”‚t ~ â”‚y â†‘ â”‚u â†“ â”‚i â³ â”‚o â—‹ â”‚p * â”‚[ â† â”‚] â†’ â”‚      â”‚
: â”œâ”€â”€â”€â”€â”€â”€â”€â”´â”¬â”€â”€â”€â”´â”¬â”€â”€â”€â”´â”¬â”€â”€â”€â”´â”¬â”€â”€â”€â”´â”¬â”€â”€â”€â”´â”¬â”€â”€â”€â”´â”¬â”€â”€â”€â”´â”¬â”€â”€â”€â”´â”¬â”€â”€â”€â”´â”¬â”€â”€â”€â”´â”¬â”€â”€â”€â”´â”¬â”€â”€â”€â”´â”     â”‚
: â”‚Caps    â”‚A   â”‚S   â”‚D   â”‚F â› â”‚G   â”‚H   â”‚J â¤ â”‚K âŒ¸ â”‚L âŒ· â”‚: â‰¡ â”‚" â‰¢ â”‚|   â”‚     â”‚
: â”‚Lock    â”‚a âº â”‚s âŒˆ â”‚d âŒŠ â”‚f _ â”‚g âˆ‡ â”‚h âˆ† â”‚j âˆ˜ â”‚k ' â”‚l â• â”‚; â â”‚' â• â”‚\ # â”‚     â”‚
: â”œâ”€â”€â”€â”€â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”¬â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”¤
: â”‚Shift â”‚~ âŠ£ â”‚Z âŠ† â”‚X   â”‚C   â”‚V   â”‚B   â”‚N   â”‚M   â”‚< âª â”‚> â™ â”‚? â  â”‚Shift       â”‚
: â”‚      â”‚` âŠ¢ â”‚z âŠ‚ â”‚x âŠƒ â”‚c âˆ© â”‚v âˆª â”‚b âŠ¥ â”‚n âŠ¤ â”‚m | â”‚, â â”‚. â€ â”‚/ âŒ¿ â”‚            â”‚
: â”œâ”€â”€â”€â”€â”¬â”€â”´â”€â”€â”€â”¬â”´â”€â”€â”€â”¬â”´â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”´â”¬â”€â”€â”€â”´â”¬â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
: â”‚    â”‚     â”‚alt â”‚     â”‚                        â”‚     â”‚ altâ”‚      â”Œâ”€â”€â”€â”
: â”‚fn  â”‚ctrl â”‚    â”‚cmd  â”‚                        â”‚  cmdâ”‚    â”‚â”Œâ”€â”€â”€â” â”œâ”€â”€â”€â”¤ â”Œâ”€â”€â”€â”
: â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜

** Glyphs
:PROPERTIES:
:TABLE_EXPORT_FILE: ./apl-keys.csv
:TABLE_EXPORT_FORMAT: orgtbl-to-csv
:END:
| Key | Glyph |   | Key | Glyph |   | Key | Glyph |   | Key | Glyph |
|-----+-------+---+-----+-------+---+-----+-------+---+-----+-------|
| a   | âº     |   | A   | â¶     |   | 1   | Â¨     |   | !   | âŒ¶     |
| b   | âŠ¥     |   | B   | Â£     |   | 2   | Â¯      |   | @   | â«     |
| c   | âˆ©     |   | C   | â§     |   | 3   | <     |   | #   | â’     |
| d   | âŒŠ      |   | D   |       |   | 4   | â‰¤     |   | $   | â‹     |
| e   | âˆŠ     |   | E   | â·     |   | 5   | =     |   | %   | âŒ½     |
| f   | _     |   | F   | â«     |   | 6   | â‰¥     |   | ^   | â‰     |
| g   | âˆ‡     |   | G   |       |   | 7   | >     |   | &   | âŠ–     |
| h   | âˆ†     |   | H   | â™     |   | 8   | â‰      |   | *   | âŸ     |
| i   | â³      |   | I   | â¸     |   | 9   | âˆ¨     |   | (   | â±     |
| j   | âˆ˜     |   | J   | â¤     |   | 0   | âˆ§     |   | )   | â²     |
| k   | '     |   | K   | âŒº     |   | `   | â—Š     |   | ~   |       |
| l   | â•     |   | L   | âŒ·     |   | -   | Ã—     |   | _   | !     |
| m   | \vert     |   | M   |       |   | =   | Ã·     |   | +   | âŒ¹     |
| n   | âŠ¤     |   | N   |       |   | ,   | â     |   | <   | âª     |
| o   | â—‹     |   | O   | â¥     |   | /   | âŒ¿     |   | ?   | â      |
| p   | â‹†     |   | P   | â£     |   | [   | â†     |   | {   | â     |
| q   | ?     |   | Q   |       |   | ]   | â†’     |   | }   | â¬     |
| r   | â´     |   | R   |       |   | ;   | â     |   | :   | â‰¡     |
| s   | âŒˆ      |   | S   |       |   | '   | â•     |   | "   | â‰¢     |
| t   | âˆ¼     |   | T   | â¨     |   | \   | âŠ¢     |   | \vert   | âŠ£     |
| u   | â†“     |   | U   |       |   | Â§   |       |   | Â±   |       |
| v   | âˆª     |   | V   |       |   | .   | .     |   | >   | â€     |
| w   | âµ     |   | W   | â¹     |   |     |       |   |     |       |
| x   | âŠƒ     |   | X   | Ï‡     |   |     |       |   |     |       |
| y   | â†‘     |   | Y   | Â¥     |   |     |       |   |     |       |
| z   | âŠ‚     |   | Z   |       |   |     |       |   |     |       |

** Terminology
[[https://mastering.dyalog.com/Introduction.html#conventions][source]]

- Array :: generic word for any set of values, whatever the number of its
  dimensions (whatever its shape)
  - rank: n
  - Mixed Array :: array that contains scalar numbers /and/ scalar characters
  - Nested Array :: array that contains /sub-arrays/
  - Simple Array :: array that is not /nested/
- Scalar :: a single value, a number or a single character
  - rank: 0
- Vector :: a plain list of values, e.g. ~4 32.5 7~ or ~'my water bottle'~
  - rank: 1
- Matrix :: an array with 2 dimensions
  - rank: 2
- Table :: another common word used for 2D-arrays (matrices)
  - rank: 2
- Cube :: common word used for 3D-arrays
  - rank: 3

- Shape :: vector that specifies the number of elements for each dimension
  in an array
- Rank :: integer that specifies the number of dimensions of an array
- Depth :: ?
- Axis :: integer that selects a specific dimensional axis of an array
  (as the corresponding index for its /shape/)
- (k-)Cell :: a /sub-array/ of rank /k<r/ of an array of rank /r/
  - Major Cell :: /(r-1)/-cell
    - e.g. /vectors/ are major cells of /matrices/

- Fill Item :: neutral element that is used in place of a missing item
  - ~0~ for numbers, ~' '~ for characters

- Scalar Function :: function that applies to each scalar of an array and
  returns an array of the same shape as its input
  - see [[https://help.dyalog.com/19.0/index.htm#Language/Primitive%20Functions/Scalar%20Functions.htm][Dyalog APL Lang. Reference Guide / Scalar Functions]]
  - if *dyadic*, either its arguments must be the same shape or one/both of
    them must be a single value, in which case the returned shape matches
    the non-singleton array (if not both are singleton)
    - for any /nested arrays/, their sub-arrays must also either be matched by
      shape or with a single value
  - pervasive :: permeates down through the structure of nested arrays,
    until it reaches the lowest-level items, and then applies itself at this
    level
- Mixed Function :: mixed rank function
  - see [[https://help.dyalog.com/19.0/index.htm#Language/Primitive%20Functions/Mixed%20Functions.htm][Dyalog APL Lang. Reference Guide / Mixed Functions]]
  - Structural â€¦ :: change the structure of arguments in some way
  - Selection â€¦ :: select elements from an argument
  - Selector â€¦ :: identify specific elements by a boolean map or by an
    ordered set of indices
  - Miscellaneous â€¦ :: transform arguments in some way to provide
    information about the arguments
  - Special â€¦ :: symbols with special properties

** Conditionals

*If-statements*

Imperative if-statement in Dyalog APL:
: :If <condition>
:   <true-branch>
: :EndIf

Example ([[https://youtu.be/myoK22rq1jk?t=1026][source]]):
#+begin_src gnu-apl
âˆ‡vowelsâ†JustVowels word
  vowelsâ†''
  :For letter :In word
    :If letterâˆŠ'aeiou'
      vowels,â†letter
    :EndIf
  :EndFor
âˆ‡
#+end_src

GNU APL does not support control structures, but this works:
: âˆ‡ râ†<function header>
:   â†’(<condition>)/error
:   râ†<true-branch>
:   â†’0
: error:
:   râ†<false-branch>
: âˆ‡
- source: [[https://stackoverflow.com/a/37907592]]

Example: function to calculate binomial coefficients
- adapted from snippet A.3 in Iversons [[https://www.jsoftware.com/papers/tot.htm][â€œNotation as a Tool of Thoughtâ€]],
  which doesnâ€™t work in GNU APL
#+begin_src gnu-apl
âˆ‡râ†bc arg ;x
  â†’(arg=0)/error
  râ†(x,0) + (0,xâ†bc arg-1)
  â†’0
error:
  râ†1
âˆ‡
#+end_src

*Conditional expressions*

GNU APL doesnâ€™t have guards for conditional expressions, so this will work
in Dyalog but NOT in GNU APL:
: {<b>:<b=1> â‹„ <b=0>}
- 1â†’true, 0â†’false

There are [[https://stackoverflow.com/questions/15752895/conditional-function-in-apl][various workarounds]], but they will evaluate both their true and
their false branch:
- Using *Index*:
: <i> âŒ· <i=1> <i=2>
- same with bracket notation:
: (<i=1> <i=2>)[<i>]
- Using *Pick*:
: <i> âŠƒ <i=1> <i=2>
- index ~i~ acts as a â€œbooleanâ€, with 1-indexed values 1â†’â€œfalseâ€ and 2â†’â€œtrueâ€
- set index origin to 0 to avoid adding 1 to the boolean:
  : â•IOâ†0

** Loops

Imperative for-each loop in Dyalog APL:
: :For <name> :In <v>
:   <body>
: :EndFor

Example ([[https://youtu.be/myoK22rq1jk?t=821][source]]):
#+begin_src gnu-apl
âˆ‡tâ†Count array;element
  tâ†0
  :For element :In array
    t+â†1
  :EndFor
âˆ‡
#+end_src

Count with a recursive approach (only in Dyalog):
#+begin_src gnu-apl
{âºâ†0 â‹„ 0=â´âµ:âº â‹„ (âº+1)âˆ‡1â†“âµ}
#+end_src

Count with higher-order function:
#+begin_src gnu-apl
{+/âµ=âµ}

â even simplier:
{â‰¢âµ}
{â´âµ}
#+end_src

Count as a derived function (only in Dyalog):
#+begin_src gnu-apl
(+/=â¨)
#+end_src

** Definitions

To define a variable:
: <name> â† <x>
- values can be assigned to multiple variables in one expression, e.g.:
  : (g h j) â† 30 51 49
  - the parentheses can be left out, but this is highly discouraged

Variable names are case-sensitive and must not start with a digit.

The following letters are allowed for variable names:
#+begin_src text
0123456789
ABCDEFGHIJKLMNOPQRSTUVWXYZ_
abcdefghijklmnopqrstuvwxyz
Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã˜Ã™ÃšÃ›ÃœÃáº
Ã Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã¸Ã¹ÃºÃ»Ã¼Ã¾
âˆ†â™
#+end_src


Redefinition is not allowed! Erase the definition first:
: )ERASE <name>

*Direct function* (like a lambda)

Embedded in another expression:
: â€¦ { <body> } â€¦
As an ad-hoc definition:
: <fn-name> â† { <body> }

~body~ may contain the following parameters:
- ~âº~ for /left-hand/ argument
- ~âµ~ for /right-hand/ argument

*Explicit function definition*

: âˆ‡<result-name> â† <?l-arg> <fn-name> <?r-arg> <? ;local-vars ;â€¦>
:  <body>
:  â€¦
: âˆ‡

** Data Structures
*** Array

Sequence of zero or more items.

Arrays can be multi-dimensional, Dyalog APL supports up to 15 dimensions.
- ~<n m â€¦>â´<a>~ constructs a multi-dimensional array along axes ~n~, ~m~, â€¦

**** Shape & Rank

- ~â´<a>~ gets the /shape/ (axis-length for each dimension) of an array
- ~â‰¢â´<a>~ gets the /rank/ (number of dimensions) of an array
  - scalars have a rank of 0
  - note: ~1â´42~ is an 1D-array (one item), while ~42~ is a scalar, or
    0D-array!

**** Index

Arrays/vectors are *1-indexed* by default.
- set index origin to 0 to avoid adding 1 to the boolean:
  : â•IOâ†0
  - ~â•IO~ to see the current index origin

Get item(s) from /n/-dimensional array in the shape specified by /n/ indices:
: <arr>[i1;i2;â€¦in]
Each index can be a vector of indices, selecting multiple parts from each
axis of the array:
: <arr>[i1 j1 â€¦; â€¦ ;in jn â€¦]
Selections can be independent of one specific row/column/â€¦ intersection by
specifying multiple vectors of length /n/:
: <arr>[(i1 â€¦ in)(j1 â€¦ jn)â€¦]

Indices can repeat to get the same item multiple times
- instead of listing indices directly, they can be enumerated with ~â³~

Get item(s) from /n/-dimensional array by /k â‰¤ n/ indices:
: <i1 i2 â€¦ ik> âŒ· <arr>
Equivalently:
: <(i1 i2 â€¦ ik)> âŒ· <arr>
- when not specifying all /n/ axes, /k/-dimensional sub-arrays are returned
  Each index can be a vector of indices, selecting multiple parts from
  each axis of the array:
: <(i1 j1 â€¦) (i2 j2 â€¦) â€¦ (ik jk â€¦)> âŒ· <arr>
- *Note:* must specify at least two axes

Examples:
- ~xs[1 5 6;1 3]~ selects rows 1, 5 and 6 with columns 1 and 3 each
  - ~(1 5 6)(1 3)âŒ·xs~ is equivalent
- ~xs[3;]~ selects all cols from row 3, ~xs[;]~ returns the whole array


Set items at index/indices in array to the same number of values or a
single scalar:
: <arr>[i j kâ€¦] â† xi xj xkâ€¦
: <arr>[i j kâ€¦] â† x
- *Note:* the replacement array must have exactly the same shape as the
  array of indices it replaces

An index can be of any shape and the result will always match the shape of
the index, as if each item of the index had been replaced by the item it
designates.

**** Axis

*Axis Operator*

The square-bracket notation to select the axis on a function behaves
like an operator which produces a derived function, which is why it is
often called the /axis operator/.

*Dyadic scalar functions* normally apply to each scalar of its arguments,
but they can also be applied to a specific ~axis~ of an array. The axis of
the higher-dimensioned array gets selected, while the other argument
must be an array of the same length as that axis:
: <L> <f>[axis] <R>
- e.g. for a 3x2 matrix, ~matÃ—[1]2 3 4~ multiplies the first row by 2, the
  second by 3 and the third by 4, while ~matÃ—[2]5 6~ multiplies the first
  column by 5 and the second by 6

Some *dyadic non-scalar functions* and some *operators* can also be applied
to a given axis and may reduce (e.g. ~/~) or expand (e.g. ~,)~ the array
along that axis.

*** Character

A single character is a scalar (0-dimensional), a string of characters is a
character vector. Multiple strings are represented by a nested array.

To enter an apostrophe ~'~, it must be doubled, e.g.:
: 'It''s raining, isn''t it?'

Unicode characters of multiple bytes count as single characters.

#+begin_src gnu-apl
      â‰¢â´'a'
0
      â‰¢â´'ab'
1

      â‰¢'ğŸ™‹'
1
      â‰¢'é••'
1
#+end_src

*** Number

*Scientific notation*

Positive exponent:
: <n>e<exp>
Negative exponent:
: <n>eÂ¯<exp>

Examples:
- ~1e6 = 1000000~

*Complex Numbers*

: <real>J<imag>

** Primitive Functions
List of all scalar (mon./dya.) functions:
- https://mastering.dyalog.com/Appendices.html#appendices-scalar-functions

Monadic/Dyadic:
: + - Ã— Ã· | âŒŠ âŒˆ â‹† âŸ â—‹ ! 
Only Monadic:
: ~ ? âŠ¢ âŠ£
Only Dyadic:
: âˆ§ âˆ¨ â² â± < â‰¤ = â‰¥ > â‰ 

List of all operators:
- https://mastering.dyalog.com/Appendices.html#dyalog-apl-operators
  
*** General
**** ~â—Š~ â†’ *Statement separator*

Display expressions separately on multiple lines:
: <expr1> â—Š <expr2> â—Š  â€¦

**** ~â~ â†’ *Comment*

Add a comment:
: â <some comment>

**** ~â†~ â†’ *Assignment* (dya.)

Assign the value of an expression to a variable name:
: <name> â† <expr>

**** ~â•~ â†’ *Format* (mon./dya.)

Returns a character representation of its argument.

**** ~âŠ£~ / ~âŠ¢~ â†’ *Same* (mon.), *Left / Right* (dya.)

In the monadic case, returns its argument as is (identity function).
- can be used to display the value of a variable from an assignment

In the dyadic case, returns its /left/ (~âŠ£~) or /right/ (~âŠ¢~) argument.

*** Arithmetics
**** ~Â¯~ â†’ *Negative Number*

-/n/:
: Â¯n

**** ~|~ â†’ *Magnitude {Abs. value}* (mon.), *Residue {Remainder/Modulus}* (dya.)

/Absolute value/ (real number) or /magnitude/ (complex number) of ~n~:
: |<n>
- the magnitude of a complex number is the length of its diagonal on the
  complex plane

~n~ is a /divisor/ of ~m~ OR ~m~ /mod/ ~n~:
: <n>|<m>

Equivalence (see [[https://mastering.dyalog.com/Some-Primitive-Functions.html#residue][explanation]]):
: (<n>|<m>) â‰¡ (<m> - (<n> Ã— (âŒŠ(<m>Ã·<n>))))

**** ~+~ â†’ *Conjugate* (mon.), *Addition* (dya.)

With no /imaginary/ part, the monadic form acts as the /identity function/,
as the complex conjugate of a real number is the number itself.
- this is also true for character input

Example:
- ~+ 0J1~ results in ~0JÂ¯1~

**** ~-~ â†’ *Negation* (mon.), *Subtraction* (dya.)

/Negation/ is not /logical negation/, which is â€œNotâ€ (~~~). This will only
reverse the minus sign of any number.
- note that ~- 0~ is just ~0~

**** ~Ã—~ â†’ *Direction/Signum* (mon.), *Multiplication* (dya.)

For real numbers, /Direction/ simply returns the sign of the number:
- ~1~ for positive numbers
- ~0~ for zero
- ~Â¯1~ for negative numbers

For complex numbers, the number is scaled to have a /magnitude/ of 1.

Geometrically, complex numbers can be represented as triangles, which
reveals a relation between monadic ~Ã—~ and ~|~:
- the â€œsmaller triangleâ€ (via ~Ã—~) times the magnitude of the â€œoriginal
  triangleâ€ (via ~|~) returns the original triangle, as shown in:
  : v â‰¡ (Ã—v)Ã—|v

**** ~Ã·~ â†’ *Reciprocal* (mon.), *Division* (dya.)

Reciprocal (1 / ~n~):
: Ã·<n>

- division by 0 throws a domain error
- ~0Ã·0 = 1~ (this convention can be [[https://mastering.dyalog.com/Some-Primitive-Functions.html#some-primitive-functions-division-control-div-and-other-mathematical-subtleties][changed]])

**** ~â‹†~ â†’ *Exponential* (mon.), *Power* (dya.)

Exponential (/e/ to the power of ~n~):
: â‹†<n>

~n~ to the power of ~m~:
: <n>â‹†<m>

- there is no special square-root function, so âˆš2 is just ~2 * 0.5~
- also, the imaginary number is: ~Â¯1 â‹† 0.5 = 0J1~

**** ~!~ â†’ *Factorial* (mon.), *Combinations* (dya.)

Factorial of ~n~:
: !<n>

Number of ~k~-combinations out of ~n~ items (binomial coefficient function):
: <k>!<n>

Examples:
- ~2!6~ is the same as ~(!6)Ã·(!6-2)Ã—!2~ (= 15)
- pascalâ€™s triangle (with apex on the left): ~pasâ†{((â³âµ)-1)âˆ˜.!(â³âµ)-1}~

**** ~âŸ~ â†’ *Logarithm*

Natural logarithm of ~n~:
: âŸ<n>

Base ~b~ logarithm of ~n~:
: <b>âŸ<n>

Equivalences:
: +/mâ´n â†â†’ nÃ—m
: Ã—/mâ´n â†â†’ n*m
: +\mâ´n â†â†’ nÃ—â³m
: Ã—\mâ´n â†â†’ n*â³m
: Ã—/v â†â†’ *+/âŸv

**** ~âŒŠ~ / ~âŒˆ~ â†’ *Floor / Ceiling* (mon.), *Minimum / Maximum* (dya.)

Can be used to cap values in an array to upper/lower bounds.

To /round/ decimal values to the /nearest/ integer, two methods can be used:
- ~âŒŠv+0.5~ will round /up/ in case of x.5
- ~âŒˆv-0.5~ will round /down/ in case of x.5

Equivalences:
: âŒˆ/v â†â†’ -âŒŠ/-v
: âŒŠ/v â†â†’ -âŒˆ/-v

*** Scalars
**** ~â¬~ â†’ *Empty numeric vector* (nil.)

#+begin_src gnu-apl
      â¬â‰¡â³0
1
      â¬â‰¡0â´0
1
      â¬â‰¡0 0â´0
0
      â¬â‰¡''
0

      3 2â´â¬ 1 2
   1 
2    
1  2 

      â¬â´5 3 6
5  â the vector collapses to a zero-dim. point, the first element

â maximum/minimum reduction over an empty list returns the identity element
â which is the elem. that doesnâ€™t affect the outcome for any other argument
      âŒˆ/â¬
Â¯1.797693135E308  â smallest 64 bit float (there is always a greater number)
      âŒŠ/â¬
1.797693135E308  â biggest 64 bit float (there is always a smaller number)
#+end_src

**** ~?~ â†’ *Roll* (mon.), *Deal* (dya.)

Select random number from ~â³n~:
: ?<n>
â€¦ for each integer in vector:
: ?<v>
- e.g. to roll 10 dices: ~?10â´6~
- note that selecting from ~â³n~ means 0 is not included!

Pick/deal ~n~ random integers from ~â³m~ without repetition:
: <n>?<m>
- ~n~ must be â‰¤ ~m~

**** ~âŠ¤~ â†’ *Encode* (dya.)

Encode each number in vector in the number system with radices ~r~:
: <r â€¦> âŠ¤ <v>
- the count of ~r~ determines the number of places in the resulting number
  - e.g. ~2 2 2 âŠ¤ 5~ represents the number 5 in 3 binary places: ~1 0 1~
  - with a vector, numbers are arranged as columns in the result

Example: boolean matrix function ~Tâ†{(âµâ´2)âŠ¤(â³2â‹†âµ)-1}~
- adapted from snippet A.2 in Iversons [[https://www.jsoftware.com/papers/tot.htm][â€œNotation as a Tool of Thoughtâ€]],
  which doesnâ€™t work in GNU APL
    
**** ~âŠ¥~ â†’ Decode (dya.)


: |-(0 60âŠ¥,)/<n> 2â´<h1> <m1> <h2> <m2> â€¦

*** Logic
**** ~âˆ¼~ â†’ *Not* (mon., bool.), *Without* (dya.)

Remove element(s) ~x~ from vector:
: <v>~<x>
- e.g. ~'apple'âˆ¼'p'~ â‡’ ~ale~
- the size and shape of ~x~ are irrelevant, only its items are used

**** ~âˆ¨~ ~âˆ§~ â†’ *Disjunction / Conjunction* (dya.), *GCD / LCM* (dya.)

Find the /greatest common divisor/ (GCD):
: <x>âˆ¨<y>
Find the /least common multiple/ (LCM):
: <x>âˆ§<y>

Equivalences:
: âˆ§/b â†â†’ ~âˆ¨/~b
: âˆ¨/b â†â†’ ~^/~b

**** ~â±~ ~â²~ â†’ *Nor / Nand* (dya.)
**** ~=~ ~â‰ ~ â†’ *Equality / Not equal, *Equivalence / Exclusive-or* (dya.)

Element-wise (scalar) comparison, NOT a check for array equality!
- use ~â‰¡~ and ~â‰¢~ instead

Equivalences:
: â‰ /b â†â†’ ~=/~b
: =/b â†â†’ ~â‰ /~b

**** ~â‰¤~ â†’ *Less than or equal* (dya.), *Material implication* (dya., bool.)
- /a â‰¤ b/  can be translated to  /a â†’ b/  in logic.

**** ~â‰¥~ â†’ *Greater than or equal* (dya.), *Converse (implic.)* (dya., bool.)
- /a â‰¥ b/  can be translated to  /a â† b/  in logic.

**** ~<~ â†’ *Less than* (dya.), *Material nonimplication* (dya., bool.)
- /a < b/  can be translated to  /a â†› b/  in logic.

**** ~>~ â†’ *Greater than* (dya.), *Converse nonimplication* (dya., bool.)
- /a > b/  can be translated to  /a â†š b/  in logic.

**** Logical truth tables:
#+begin_src gnu-apl
      0 1âˆ˜.,0 1
0 0  0 1  â  all pairs in a Ã— b
1 0  1 1 

      0 1âˆ˜.=0 1
1 0  â  a â‡” b
0 1
      0 1âˆ˜.â‰ 0 1
0 1  â  a XOR b
1 0

      0 1âˆ˜.âˆ¨0 1
0 1  â  a âˆ¨ b
1 1
      0 1âˆ˜.âˆ§0 1
0 0  â  a âˆ§ b
0 1

      0 1âˆ˜.â‰¤0 1
1 1  â  a â†’ b
0 1
      0 1âˆ˜.â‰¥0 1
1 0  â  a â† b
1 1

      0 1âˆ˜.<0 1
0 1  â  a â†› b
0 0
      0 1âˆ˜.>0 1
0 0  â  a â†š b
1 0
#+end_src

*** Arrays
**** ~â‰¡~ â†’ *Depth* (mon.), *Match* (dya.)

? Get the depth of an array:
: â‰¡ <arr>

Check if two arrays are equal:
: <arr> â‰¡ <arr>
- returns a boolean scalar

**** ~â‰¢~ â†’ *Tally* (mon.), *Not match* (dya.)

Get the number of elements of an array (main axis):
: â‰¢ <arr>

Check if two arrays are different:
: <arr> â‰¢ <arr>
- returns a boolean scalar

**** ~â†‘~ â†’ *Mix* (mon.), *Take* (dya.)

Take ~n~ items from ~arr~:
: <n>â†‘<arr>
- if ~(|n)>â‰¢arr~, padds with ~(|n)-â‰¢arr~ /fill items/ from the /left/ (if ~n<0~)
  or from the /right/ (if ~n>0~).

Mix items of a /nested array/ into rows of a matrix:
: â†‘<nested-arr>
: â†‘[n]<nested-arr>
- returns an array of higher /rank/ and lower /depth/ than its argument
- a nested /sub-array/ will become a row in the matrix
- if the /sub-arrays/ differ in length, extra elements in the matrix will
  be filled/padded with /fill-items/

**** ~â†“~ â†’ *Split* (mon.), *Drop* (dya.)

Drop ~n~ items from ~arr~:
: <n>â†“<arr>

Split array â€¦
: â†“<arr>
- returns an array of lower /rank/ and higher /depth/ than its argument

*Note*: /mix/ can be followed by /split/ to create a /nested array/ that has the
same number of elements in its /sub-arrays/.

**** ~âŠ‚~ â†’ *Enclose* (mon.), *Partitioned Enclose* (dya.)

Enclose/â€œzipâ€ an array for nesting (returns a scalar):
: âŠ‚<arr>
- can be used to assign a nested array to an index in another array:
  - e.g. ~a â† 1 2 3 â‹„ a[2] â† âŠ‚15 20 25 â‹„ â• â† a~ results in ~1 15 20 25 3~

**** ~âŠƒ~ â†’ *First* (mon.), *Pick* (dya.)

Extract the first item of an array (â€œunzipsâ€ an /enclosed array/):
: âŠƒ<arr>

Pick an item in ~arr~ by index/indices:
: <idx>âŠƒ<arr>

**** ~âŠ†~ â†’ Nest (mon.), Partition (dya.)

Turn an array into a nested array:
: âŠ†<arr>

Partition an array according to equal subsequences in a ~parts~ vector:
: <parts>âŠ†<arr>

**** ~, âª~ â†’ *Ravel* (mon.), *Catenate {Join} / â€¦first* (dya.)

Join (â€œravelâ€) scalars of an array into a vector (â€œrow-majorâ€ order):
: ,<arr>
- /sub-arrays/ are preserved

Catenate two arrays (along ~axis~):
: <arr>,<arr>
: <arr>,[axis]<arr>
- defaults to last axis/dimension of the array
- for /axis 1/, ~<arr>âª<arr>~ is equivalent to ~<arr>,[1]<arr>~

Specifically:

Catenate two scalars to a vector:
: <s>,<s>

Catenate two vectors to an extended vector:
: <v>,<v>

Catenate scalar to matrix as new row (~i~ â†’1) or column (~i~ â†’2):
: <m>,[i]<s>
- creates copies of the scalar along the catenation axis

Catenate vector to matrix as new row (~i~ â†’1) or column (~i~ â†’2):
: <m>,[i]<v>
- vector length must match row/col count on catenation axis

Catenate matrix to matrix before/after first/last row (~i~ â†’1) or column
(~i~ â†’2):
: <m>,[i]<m>
- number of rows/columns on catenation axis must match between matrices

**** ~/~ ~âŒ¿~ â†’ *Replicate (Compress) / â€¦first* (dya.)

Filter by boolean vector:
: <bv>/<v>
- e.g. ~0 1 0 1/'tesa'~ results in ~ea~
- e.g. ~'aeiou'{(âµâˆŠâº)/âµ}~ will filter a word for vowels

Replicate elements in ~vr~ according integer counts in ~vl~:
: <vl>/<vr>
- e.g. ~1 2 3/'abc'~ results in ~abbccc~
- if ~vl~ is a single scalar, it will apply to all elements of ~vr~
- negative integers will use /n/ *fill items* instead
  - for numbers, the fill item is ~0~, for characters it is ~' '~

**** ~\~ ~â€~ â†’ *Expand / â€¦first* (dya.)

**** ~âˆŠ~ â†’ *Enlist* (mon.), *Membership* (dya.)

Check if elements in ~match~ array are members of ~arr~:
: <match>âˆŠ<arr>

Enlist all elements in the array (even nested ones):
: âˆŠ<arr>
- unnests nested arrays

**** ~â·~ â†’ *Find* (dya.)

Check where in ~arr~ the /whole/ ~find~ array is found:
: <find>â·<arr>
- returns a boolean array where 1 is the first index of the found array

**** ~â³~ â†’ *Index generator* (mon.), *Index of* (dya.)

Generate a number sequence [ 1, ~n~ ]:
: â³<n>
Multi-dimensional:
: â³<n> <m> â€¦

Index all items in vector by their index in search vector:
: <search>â³<v>
- items not matched are indexed with last index of match vector + 1
  - this can be used beneficially as a â€œnot foundâ€ item in another
    vector that matches the indices afterwards
- only the first match is listed for each item in search vector

Equivalences:
: +/â³n â†â†’ ((n+1)Ã—n)Ã·2

**** ~â¸~ â†’ *Where* (mon.), *Interval Index* (dya.)
Get /n/ indices for all /n>0/ in a boolean/integer array:
: â¸ <arr>
- doesnâ€™t work for nested arrays
- returns a vector of nested indices for arrays of rank > 1

Given an ordered set of intervals/ranges, determine for each scalar in
the array the index of one of the intervals it belong to:
: <interval-vec> â¸ <arr>
- returns an array of the same shape of the original array

The interval conditions for each index of a vector /a b c/ are as follows:

| i | condition |
|---+-----------|
| 0 | X < a     |
| 1 | a â‰¥ X < b |
| 2 | b â‰¥ X < c |
| 3 | X â‰¥ c     |

**** ~âŒ½~ ~â‰~ ~âŠ–~ â†’ Reversal / Rotation / Transposition
- ~âŒ½~ â†’ *Reversal* (mon.), *Rotation* (dya.)
- ~âŠ–~ â†’ *Reverse first* (mon.), *Rotate first* (dya.)
- ~â‰~ â†’ *Transpose* (mon.), *Dyadic transpose* (dya.)
- â€œfirstâ€ meaning /first axis/ (e.g. vertical in a matrix)
  
? Equivalent for matrix ~m~ and rotation ~n~
: (âŒ½[1]<m>) = âŠ–<m>    (<n>âŒ½[1]<m>) = <n>âŠ–<m>
: (âŒ½<m>) = âŠ–[2]<m>    (<n>âŒ½<m>) = <n>âŠ–[2]<m>

Reverse array on last (rightmost) axis:
: âŒ½<a>
Reverse array on first (leftmost) axis:
: âŠ–<a>
Reverse array on specified axis:
: âŒ½[i]<a>
: âŠ–[i]<a>
- e.g. for matrix: /column/ order (~i~ â†’1), /row/ order (~i~ â†’2), â€¦
- ? same for ~âŒ½~ and ~âŠ–~

Rotate array by ~n~ elements on last (rightmost) axis left-/upwards:
: <n>âŒ½<a>
Rotate array by ~n~ elements on first (leftmost) axis up-/leftwards:
: <n>âŠ–<a>
Rotate array by ~n~ elements on specified axis up-/leftwards:
: <n>âŒ½[i]<a>
: <n>âŠ–[i]<a>
- e.g. for matrix: /column/-wise (~i~ â†’1), /row/-wise (~i~ â†’2), â€¦
- negative ~n~ rotates in the opposite direction
- ? same for ~âŒ½~ and ~âŠ–~

Swap rows and columns (â†’ /transpose/) on a matrix:
: â‰<m>
Swap axes in specified order on array:
: <i j kâ€¦>â‰<a>
- ~2 1~ on a matrix is equivalent to the monadic transpose
- ~1 1~ takes the /leading diagonal/

**** ~â´~ â†’ *Shape* (mon.), *Reshape* (dya.)

Form a vector of /n/ elements:
: <n>â´<x>
Form a matrix of /m/ rows and /n/ columns:
: <m> <n>â´<x>

Note: elements will repeat if ~(â‰¢x) < mÃ—n~
- e.g. ~6â´4~ results in ~4 4 4 4 4 4~

**** ~Â¨~ â†’ *Each* (mon./dya.)

e.g. ~+/Â¨(1 2) (3 4)~ will take the sum for each subvector

**** ~âŒ¹~ â†’ *Matrix inverse* (mon.), *Matrix divide* (dya.)
**** ~â‹~ ~â’~ â†’ *Grade Up/Down* (mon.), *Dyadic Grade Up/Down* (dya.)

Return indices which would select items in ascending order:
: â‹ <arr>

Can be used to sort an array via sort indices from a different array of
the same shape:
#+begin_src gnu-apl
      namesâ†'Joe' 'Sue' 'Sam'
      agesâ†34 22 25
      names[â‹ages]
â”Œâ†’â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚Sueâ”‚Samâ”‚Joeâ”‚
â””â”€â”€â†’â”´â”€â”€â†’â”´â”€â”€â†’â”˜
      names[â’ages]
â”Œâ†’â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚Joeâ”‚Samâ”‚Sueâ”‚
â””â”€â”€â†’â”´â”€â”€â†’â”´â”€â”€â†’â”˜
#+end_src
- [[https://help.dyalog.com/19.0/#Language/Symbols/Grade%20Up.htm][source]]

** Operators (higher-order functions)
Operators produce /derived functions/, given one or two functions as input
(their /operands/). For a monadic operator, the operand is its /left/ argument.
- e.g. ~+/~

*** ~/~ ~âŒ¿~ â†’ *Reduce {Fold, N-Wise Reduce} / â€¦first* (mon.)

Apply ~f~ between each element of the array:
: <f>/<arr>
- by default applied along the last axis of the array
for /axis/ ~n~:
: <f>/[n]<arr>
- e.g. column (~n~ â†’1), row (~n~ â†’2), â€¦ of a matrix
- the resulting /shape/ is the shape of the array without its ~n~'th item,
  reducing its /rank/ by 1 (the origin of the term â€œreduceâ€)
- for /axis 1/, ~<f>âŒ¿<arr>~ is equivalent to ~<f>/[1]<arr>~

~n~-wise reduction (puts ~f~ between ~n~ pairs of successive items from ~arr~):
: <n><f>/<arr>
- e.g. ~3,/â³5~ â‡’ ~1 2 3  2 3 4  3 4 5~

*Note:* ~3{âº âµ}/â³5~ will be evaluated like ~(1 (2 3)) (2 (3 4)) (4 (5 6))~,
because ~fâ†{âº âµ}~ will be applied like ~(1 f 2 f 3) (2 f 3 f 4) (4 f 5 f 6)~.
- the pairwise rightward-nesting is just an effect of evaluation order

---

If ~f~ is a *scalar function* â€¦

â€¦ and the argument is a *nested array*, applies ~f~ between the /ith/ items of
each sub-array. Scalars are applied to all items. The result is a nested
array of the same length as the sub-arrays.
- e.g. ~+/ (1 2 3) (4 5 6) 10~ gets applied like:
  : ((1 + 4 + 10) (2 + 5 + 10) (3 + 6 + 10))
  : = (15 17 19)
- all sub-arrays must be of the same shape or scalars

â€¦ and the argument is a *matrix*, applies ~f~ between each element of each /row/
of the matrix.
- e.g. ~+/ 2 3â´â³6~ gets applies like:
  : 1 + 2 + 3  â 1st row
  : 4 + 5 + 6  â 2nd row
  : = 6 15

â€¦ and the argument is a *higher-dimensional array*, it will get reduced like
matrices: only the last (vector) axis gets reduced, the rest of the shape
stays the same.

*Note:* /non-commutative functions/ may produce counter-intuitive results!
This is because APL applies the function in /right-associative/ order.
- ~-/<v>~ produces an alternating sum, e.g. ~1 - 2 + 3 - 4 + â€¦~
- ~Ã·/<v>~ produces an alternating product, e.g. ~1 Ã· 2 Ã— 3 Ã· 4 Ã— â€¦~

---

*Non-scalar functions* get applied between each element of the first axis in
the array.
- e.g. ~,/0 (1 2) (3 4 5) (6 7 8 9)~ gets applied like:
  : âŠ‚ 0,(1 2),(3 4 5),(6 7 8 9)
  : = (0 1 2 3 4 5 6 7 8 9)

---

*** ~\~ ~â€~ â†’ *Scan / â€¦first* (mon.)

Use cases:

Isolate the first â€œtrueâ€ (~1~) value in a boolean vector:
: <\<b>
- e.g. ~<\0 0 1 1 0 1 1~ results in ~0 0 1 0 0 0 0~

Keep only the leading 1â€™s in a boolean vector:
: âˆ§\<b>
- e.g. ~âˆ§\1 1 0 1~ results in ~1 1 0 0~

Switch the boolean vector to all 1â€™s from the first 1:
: âˆ¨\<b>
- e.g. ~âˆ¨\0 0 1 0 0~ results in ~0 0 1 1 1~

Sum scan (vector of intermediate sums):
: +\<v>

_Note:_ for /non-associative/ functions like ~-~ or ~Ã·~, the right-to-left
evaluation rule of APL makes reductions and scans on these functions
behave in alternating ways with their right inverse functions (~+~ in case
of ~-~, ~Ã—~ in case of ~Ã·~).
- e.g. ~â -/1 2 3 4~ evaluates like ~(1 - (2 - (3 - (4 - 5))))~, which, after
  sign inversion, is equivalent to ~1 - 2 + 3 - 4 + 5~.

_Note:_ the results from ~f\v~ on a /k/-element vector correspond to each
separate result of a /k/-prefix reduction ~f/v[1..k]~, NOT to intermediate
results of a single reduction!

*** ~.~ â†’ *Product* (dya.): *Inner product* (~f.g~), *Outer product* (~âˆ˜.f~)

Inner product (generalised matrix product):
: <g>.<f>
-  applies function args like ~g/âºfâµ~

Examples:
- dot product: ~+.Ã—~
- multiplication table: ~(â³10)âˆ˜.Ã—â³10~

Equivalences:
: p+.Ã—q â†â†’ +/pÃ—q

*** ~âˆ˜~ â†’ *Beside and Bind* (dya.), *Compose {Jot}* (dya.)

~Aâˆ˜B~ (matrix mult.) is essentially ~A +.Ã— B~ optimized for space and speed.

Apply dyadic function ~f~ like ~XfY~ (swap arguments):
: (<f>âˆ˜<Y>)<X>
- e.g. ~(>âˆ˜0 1 4) 1 2 3~ results in ~1 1 0~

Compose two functions to apply them like ~g(fâµ)~ (mon.) or ~âºg(fâµ)~ (dya.)
(preprocesses the right argument):
: <g>âˆ˜<f>
- works just like ~<g>â¤<f>~

*** ~â¤~ â†’ *Atop* (dya.), *Rank* (dya.)

Apply the result of (dyadic or monadic) function ~g~ to monadic function ~f~,
i.e. ~f(âºgâµ)~:
: <f>â¤<g>

Apply ~f~ monadically to each /sub-array (~k~-cell)/ of the input array, sliced
according to a given /rank/ ~k~:
: <f>â¤<k>âŠ¢
- ~k=0~: scalar-wise
- ~k=1~: vector-wise
- ~k=2~: matrix-wise
- â€¦
- if ~k~ is negative, a ~k~-cell of an array of rank ~r~ is an ~r+k~-cell, which
  allows ~k~ to be specified relative to the rank of the original array

Apply ~f~ dyadically to each /sub-array (~i~-cell / ~j~-cell)/ of both input
arrays, sliced according to given /ranks/ ~i~ for ~âº~ and ~j~ for ~âµ~:
: <f>â¤<i> <j>âŠ¢
- sub-arrays of both ~âº~ and ~âµ~ donâ€™t have to be the same rank
- the /frames/ of ~âº~ and ~âµ~ must be the same:
  - ~fâº â† (-<i>)â†“â´âº~ (frame of left arg.)
  - ~fâµ â† (-<j>)â†“â´âµ~ (frame of right arg.)
  - /either/ ~fâº â‰¡ fâµ~ must be true
  - /or/ one of the frames is ~â¬~ (~i~ / ~j~ is the same as the rank of ~âº~ / ~âµ~)

*** ~â¥~ â†’ *Over* (dya.)

Preprocess ~âº~ and ~âµ~ with monadic function ~g~ before applying dyadic function
~f~ to both, i.e. ~(gâº)f(gâµ)~:
: <f>â¥<g>

*** ~â¨~ â†’ *Commute/Switch* (mon., func.), *Constant* (mon.)
Swap arguments of a function:
: <f>â¨
- in case of a single argument to a dyadic function, passes the same
  argument twice, e.g. ~Ã—â¨3~ is the same as ~3Ã—3~

*** ~âŒ¸~ â†’ *Key* (mon.)

Take unique items from vector ~keys~ and match/associate them via the dyadic
function ~f~ with items at the same index in vector ~vals~:
: <keys> <f>âŒ¸ <vals>
- if ~keys~ is not specified, takes ~vals~ as keys/âº and ~â³â‰¢vals~ as vals/âµ

Example:
#+begin_src gnu-apl
      1 2 2 3 1 {âº âµ}âŒ¸ 'abede'
â”Œâ†’â”¬â”€â”€â”
â†“1â”‚aeâ”‚
â”œâ”€â”¼â”€â†’â”¤
â”‚2â”‚beâ”‚
â”œâ”€â”¼â”€â†’â”¤
â”‚3â”‚d â”‚
â””â”€â”´â”€â†’â”˜
#+end_src

*** ~â£~ â†’ *Power* (dya.)

Apply function ~f~ ~n~ times:
: <f>â£<n>
- if ~n~ is negative,
  - e.g. ~â¸â£Â¯1~ creates the shortest possible boolean/integer vector for a
    vector of indices (i.e. the inversion of /where/ ~â¸~)
    - in case of duplicate indices, the 1â€™s are added up, exactly like
      /where/ would duplicate the indices as many times

** System Functions
Write a vector of character vectors to a text file:
: <char-vecs> â•NPUT <path>

Example:
#+begin_src gnu-apl
â•â†(âŠ‚'apple' 'pie') â•NPUT 'writing.txt'
#+end_src

* Patterns/Idioms
Idiom lists:
- [[https://aplcart.info][APLcart]]
- [[https://docs.dyalog.com/latest/CheatSheet%20-%20Idioms.pdf][Dyalog Idioms CheatSheet]]
- [[https://www.ibm.com/support/pages/system/files/support/swg/swgdocs.nsf/0/819cd2373bb755d98525716c004c108e/$FILE/APL2IDIOMS.pdf][IBM APL2 Idioms Library]]
- [[https://aplwiki.com/wiki/FinnAPL_idiom_library][FinnAPL idiom library]]

Rank of an array:
: â‰¢â´ <arr>

Check if ~x~ is a scalar:
: 0=â‰¢â´ <x>
: â¬â‰¡â´ <x>

Sum of squares:
: +/Ã—â¨ <arr>

Average:
: +âŒ¿Ã·â‰¢ <arr>

Check if all elements are equal in an array:
: âŠƒâˆ§.=âŠ¢ <arr>

Catenate rows of totals to the bottom of a matrix ~m~:
: <m>,[1] +/[1]<m>

Flatten a nested array (joins sub-arrays):
: ,/ <nested-arr>

Symmetric iota (Â¯nâ€¦0â€¦n):
: symiota â† (-1+âŠ¢)+(â³1+2Ã—âŠ¢)
Symmetric normalized (Â¯1â€¦0â€¦1):
: symnorm â† (âŠ¢Ã·â¨(-1+âŠ¢)+(â³1+2Ã—âŠ¢))
In a polar unit matrix:
: polarum â† (âˆ˜.,â¨symiotaÃ·âŠ¢)

*Boolean masks* can be used to /count/ (~/+b~) or /select/ (~b/v~) corresponding true
elements from the original array.

* Dyalog implementation
https://www.dyalog.com

- based on APL2
- closed source, free for non-commercial use
- namespaces
- lexical scoping
- different paradigms like OOP, FP, etc.

Tacit functions in Dyalog APL:

Tacit code is parsed at definition time, while explicit code is parsed at run
time. In addition, the interpreter can recognise certain tacit constructs and
take shortcuts.
- [[https://www.youtube.com/watch?v=YMDClM03zyQ&lc=UgyISRlaDrty46lMWOB4AaABAg.9yaWiB7WsMr9yjswhlaXgd][source]]

Resources:
- [[https://help.dyalog.com/19.0/index.htm][Dyalog APL 19.0 Help]] (documentation on functions, etc.)
- https://www.dyalog.com/getting-started/tips.htm

** RIDE Editor

By default, ~`~ is used as a prefix key to enter symbols. Type ~``~ and a name
to have RIDE suggest the appropriate glyph.

*Input buffer:*
- press /Ctrl + Shift + Backspace/ to scroll backwards in input history
- press /Ctrl + Shift + Enter/ to scroll forwards in input history

*Session log:*
- press /Enter/ on a line in session log to re-execute it
- change a previous line in the session log to mark it for re-execution
  - the line will be marked with a tiny red dot and text color
  - pressing /Enter/ anywhere will execute all marked lines top to bottom
  - execution will copy the changed lines and keep the log unmodified
  - any error will prevent the next lines from executing
  - /Shift + ESC/ removes the mark
- press /Shift + Enter/ to edit a name/variable

*Note:* lines in the session log cannot be deleted from within RIDE on macOS

** System Functions

Dyalog built-in functions which provide services related to both the APL and
the external environment.
- case-insensitive names beginning with the ~â•~ symbol.
- implicitly available in a clear workspace
- see ch. 4 â€œSystem Functionsâ€ in =Dyalog APL Language Reference Guide.pdf=

** System Commands

*Not* executable APL expressions that provide services or infos associated
with the workspace and the external environment.
- case-insensitive names beginning with the ~)~ symbol.
- see ch. 5 â€œSystem Commandsâ€ in =Dyalog APL Language Reference Guide.pdf=

A Dyalog workspace may contain objects, namely classes, namespaces,
operators, functions and variables defined by the user.

Workspaces & Sessions:
- ~)OFF~ saves the Session log before closing APL
  - workspaces will not be saved
- ~)SAVE <wsname>~ to save the /active workspace/ to a file named ~wsname~
  - without an explicit path, Dyalog uses the /workspace search path/
- ~)LOAD <wsname>~ to load workspace named ~wsname~
  - *replaces* the /active workspace/ in memory, unsaved changes are lost!
  - without an explicit path, Dyalog searches in /workspace search path/
  - when there are spaces in a name/path, must be wrapped in dquotes ~"~
  - the extension ~.dws~ can be omitted
- ~)DROP <wsname>~ to delete workspace named ~wsname~ from disk
- ~)WSID~ shows the name of the current workspace
  - this is the WS most recently loaded/saved, not necessarily identical to
    the /active workspace/ in memory
- ~)LIB <? path>~ to list all available workspaces (optionally from ~path~)
- ~)CONTINUE~ saves a temporary workspace named ~continue~ and terminates APL
  - type ~)LOAD continue~ to retrieve the workspace later on
- ~)COPY <wsname> <? x y â€¦>~ to copy object(s) ~x y â€¦~ from workspace ~wsname~ to
  the /active workspace/
  - *replaces* objects with the same name!
    - use ~)pcopy~ instead, which does not replace objects with the same name
    - replacing can be useful to revert changes made in the /active WS/
  - omit the object names to copy all objects
- ~)CLEAR~ clears the workspace
- ~)ERASE <x y â€¦>~ erases object(s) ~x y â€¦~ from workspace
- ~)ED <x>~ opens the editor to change defined object ~x~
- ~2â•NQâ•SE'FileWrite'~ makes display settings permanent
- =View > Show Workspace Explorer= shows a tree view of the current workspace

Files:
- ~)ED "<path>"~ to edit plain text files in Dyalog

** System Variables
Other than with [[System Commands]], these can be used as part of APL
expressions.

- ~â•WSID~ â†’ like ~)WSID~

** User Commands

Dyalog-specific user commands to access various utilities and functionality
within the Dyalog environment.
- case-insensitive names beginning with the ~]~ symbol.
- see ch. 1 â€œDisplay of Arraysâ€ in =Dyalog Programming Reference Guide.pdf=

General:
- ~]Help~ opens the online documentation
- ~] -?~ to see a list of all available user commands
- ~]<cmd> -?~ to get help for ~cmd~ (~-??~ for more details and examples)
- ~]<cmd>~ shows the current state of ~cmd~ (append ~?~ for the full state)

Row processing:
: ]Rows [on|off|reset|?] [-style=<s>] [-fold=<f>] [-fns[=on|off]] [-dots=<c>]
- will cut, wrap, fold or extend the display of output lines to fit the
  Session window
- ~]Rows on~ enables row-processing
- ~]Rows off~ restores native â•PW block-wrapping

Boxing:
: ]Box [on|off|reset|?] [-style={non|min|mid|max}] [-view={non|min|mid|max}]
:      [-trains={box|tree|parens|def}] [-fns[=off|on]]
- ~]Box on~ to draw boxes for clearer visual separation in nested arrays
- ~-style=max~ for verbose boxes incl. hints on axes and data types
- ~-trains=tree~ to display function trains with a tree structure
- ~-fns=on~ to have boxes display in nested arrays even if they are printed to
  the session from within functions

Utilities:
- ~]Map~ displays the content and structure of the current workspace
- ~]Defs~ shows all function definitions
- ~]Plot <data>~ draws simple graphs (see ~]Plot -??~)
- ~]Open <filename>~ opens a target file or web address in its default app
- ~]CD <dir>~ to change directory inside the APL session
- ~]Get <src>~ to import data/code in various formats from local/remote src
- ~]Repr <arr>~ to generate an expression for (almost) any given array

** Namespaces
Namespaces can be nested and are separated by a ~.~ (dot).
- relative name: ~NS1.NS2.OBJ~
- absolute name: ~#.NS.OBJ~
- ~#~ â†’ top level or â€œRootâ€ namespace
- ~##~ â†’ parent or space containing the current namespace
- ~â•SE~ â†’ session namespace, preserved across workspace ~load~ and ~clear~

Create a namespace:
: )NS <nsname>
: â•NS <nsname>

Change current/relative namespace (similar to changing a directory):
: )CS <nsname>
: â•CS <nsname>

** Script Files
For functions/operators/objects.

Script files can be loaded into a Dyalog session:
: 2â•FIX'/path/to/myscript.dyalog'

Example file:
#+begin_src gnu-apl
:Namespace MyNamespace
    
    â Variables
    SomeVar â† 42
    
    â Functions
    âˆ‡ result â† Add(x y)
        result â† x + y
    âˆ‡
    
    â Nested namespace
    :Namespace Nested
        InnerVar â† 100
    :EndNamespace
    
:EndNamespace
#+end_src

** Libraries/Workspaces
*DISPLAY*
Like ~]box on.~

Load:
: )copy DISPLAY
Use:
: DISPLAY <x>

*Benchmark functions*

Import the â€œcompare executionsâ€ (~cmpx~) function from the ~dfns~ workspace:
: 'cmpx'â•CY'dfns'

** Plotting

*SharpPlot*
- https://xpqz.github.io/cultivations/Plotting.html

The user command ~]Plot <data>~ draws simple graphs using SharpPlot.
: ]Plot x y â€¦
: ]Plot x y â€¦ -type=<charttype>
- ~]Plot -??~ help for basic usage
- ~]plot -???~ description/list of chart types
- also works with the Dyalog Jupyter kernel
- limited compared to direct SharpPlot code

On MacOS and Linux, the ~View~ function will render an SVG in the default
viewer, on Windows it draws a raster image.

Simple example:
#+begin_src gnu-apl
â 1. Import functions from sharpplot workspace:
'InitCauseway' 'View' â•CY'sharpplot'

â 2. Initialize plot:
InitCauseway â¬
sp â† â•NEW Causeway.SharpPlot
sp â† â•NEW Causeway.SharpPlot (800 600)  â optional paper size (w h in pts)

â 3. Draw the plot:
line â† 4 3 8 2 4 5
sp.DrawLineGraph âŠ‚line  â Single argument must be enclosed

â Save as svg:
sp.SaveSvg 'plot.svg' Causeway.SvgMode.FixedAspect  â Write graph image to disk
â View in a graphical window:
View sp
#+end_src

Set different markers like this:
: sp.SetMarkers Causeway.Marker.Bullet

Set no markers in scatterplot:
: sp.ScatterPlotStyle â† Causeway.ScatterPlotStyles.NoMarkers

Set lines between points in scatterplot:
: sp.ScatterPlotStyle â† Causeway.ScatterPlotStyles.Lines

** Custom operators

Example:
: ]get github.com/abrudz/dyalog_vision/blob/main/QuadEqual.aplo
- use ~#.QuadEqual~ just like a built-in operator or assign to a symbol

* GNU APL implementation
- based on APL2
- free and open source
- slow compared to Dyalog
- no lexical scoping
- no namespaces
- no control structures

Emacs package ~gnu-apl-mode~:
- http://www.gnu.org/software/apl/

* J implementation
https://www.jsoftware.com

- open source
- performant
- ASCII-compatible syntax

References:
- [[https://code.jsoftware.com/wiki/NuVoc][The NuVoc Portal]] (J primitives)
- [[https://www.jsoftware.com/help/dictionary/vocabul.htm][J vocabulary]]

Getting started:
- [[https://code.jsoftware.com/wiki/Vocabulary/HowNuVoc][Overview]]
- [[https://olegykj.sourceforge.net/jbyeg/jbyeg.htm][J by example]]
- [[https://code.jsoftware.com/wiki/Vocabulary/JayTaster][A taste of J]]
- [[https://code.jsoftware.com/wiki/Vocabulary/ArrayProcessing][How do you process an array?]]

Introductions:
- [[https://www.jsoftware.com/help/primer/start_here.htm][J primer]]
- [[http://www.jsoftware.com/help/learning/contents.htm][Learning J]]
- [[http://www.jsoftware.com/help/jforc/contents.htm][J for C programmers]]

** Installation
Follow instructions on:
- https://code.jsoftware.com/wiki/System/Installation/J9.4/Zips

Run MacOS fix (Terminal needs permissions for app management):
: ./macos-fix.command

Install dependencies for ~jqt.app~ to work:
: ./updatejqt.sh

Now ~jqt~ and ~jcon~ can be used.

** Usage
Exit jconsole:
: exit 0

Exit JHS: ~ctrl+\~

* BQN
- no complex numbers (yet, there is a [[https://mlochbaum.github.io/BQN/spec/complex.html][spec]])
