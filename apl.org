#+title: Docs/APL

Infos:
- [[https://www.jsoftware.com/papers/tot.htm][Notation as a Tool of Thought]] (Ken Iverson)

* Language
** Keyboard Layout
- https://dfns.dyalog.com/n_keyboards.htm
- https://dfns.dyalog.com/n_kbmac.htm
- https://www.dyalog.com/apl-font-keyboard.htm (download layouts here)

Dyalog Mac APL/en-GB keyboard:
: ┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬─────────┐
: │± ⌺ │! ⌶ │@ ⍫ │£ ⍒ │$ ⍋ │% ⌽ │^ ⍉ │& ⊖ │* ⍟ │( ⍱ │) ⍲ │_ ! │+ ⌹ │Backspace│
: │§ ⋄ │1 ¨ │2 ¯ │3 < │4 ≤ │5 = │6 ≥ │7 > │8 ≠ │9 ∨ │0 ∧ │- × │= ÷ │         │
: ├────┴──┬─┴──┬─┴──┬─┴──┬─┴──┬─┴──┬─┴──┬─┴──┬─┴──┬─┴──┬─┴──┬─┴──┬─┴──┬──────┤
: │Tab    │Q   │W   │E ⍷ │R   │T ⍨ │Y   │U   │I ⍸ │O ⍥ │P ⍣ │{ ⍞ │} ⍬ │Enter │
: │       │q ? │w ⍵ │e ∊ │r ⍴ │t ~ │y ↑ │u ↓ │i ⍳ │o ○ │p * │[ ← │] → │      │
: ├───────┴┬───┴┬───┴┬───┴┬───┴┬───┴┬───┴┬───┴┬───┴┬───┴┬───┴┬───┴┬───┴┐     │
: │Caps    │A   │S   │D   │F ⍛ │G   │H   │J ⍤ │K ⌸ │L ⌷ │: ≡ │" ≢ │|   │     │
: │Lock    │a ⍺ │s ⌈ │d ⌊ │f _ │g ∇ │h ∆ │j ∘ │k ' │l ⎕ │; ⍎ │' ⍕ │\ # │     │
: ├──────┬─┴──┬─┴──┬─┴──┬─┴──┬─┴──┬─┴──┬─┴──┬─┴──┬─┴──┬─┴──┬─┴──┬─┴────┴─────┤
: │Shift │~ ⊣ │Z ⊆ │X   │C   │V   │B   │N   │M   │< ⍪ │> ⍙ │? ⍠ │Shift       │
: │      │` ⊢ │z ⊂ │x ⊃ │c ∩ │v ∪ │b ⊥ │n ⊤ │m | │, ⍝ │. ⍀ │/ ⌿ │            │
: ├────┬─┴───┬┴───┬┴────┼────┴────┴────┴────┴────┼────┴┬───┴┬───┴────────────┘
: │    │     │alt │     │                        │     │ alt│      ┌───┐
: │fn  │ctrl │    │cmd  │                        │  cmd│    │┌───┐ ├───┤ ┌───┐
: └────┴─────┴────┴─────┴────────────────────────┴─────┴────┘└───┘ └───┘ └───┘

** Glyphs
:PROPERTIES:
:TABLE_EXPORT_FILE: ./apl-keys.csv
:TABLE_EXPORT_FORMAT: orgtbl-to-csv
:END:
| Key | Glyph |   | Key | Glyph |   | Key | Glyph |   | Key | Glyph |
|-----+-------+---+-----+-------+---+-----+-------+---+-----+-------|
| a   | ⍺     |   | A   | ⍶     |   | 1   | ¨     |   | !   | ⌶     |
| b   | ⊥     |   | B   | £     |   | 2   | ¯      |   | @   | ⍫     |
| c   | ∩     |   | C   | ⍧     |   | 3   | <     |   | #   | ⍒     |
| d   | ⌊      |   | D   |       |   | 4   | ≤     |   | $   | ⍋     |
| e   | ∊     |   | E   | ⍷     |   | 5   | =     |   | %   | ⌽     |
| f   | _     |   | F   | ⍫     |   | 6   | ≥     |   | ^   | ⍉     |
| g   | ∇     |   | G   |       |   | 7   | >     |   | &   | ⊖     |
| h   | ∆     |   | H   | ⍙     |   | 8   | ≠     |   | *   | ⍟     |
| i   | ⍳      |   | I   | ⍸     |   | 9   | ∨     |   | (   | ⍱     |
| j   | ∘     |   | J   | ⍤     |   | 0   | ∧     |   | )   | ⍲     |
| k   | '     |   | K   | ⌺     |   | `   | ◊     |   | ~   |       |
| l   | ⎕     |   | L   | ⌷     |   | -   | ×     |   | _   | !     |
| m   | \vert     |   | M   |       |   | =   | ÷     |   | +   | ⌹     |
| n   | ⊤     |   | N   |       |   | ,   | ⍝     |   | <   | ⍪     |
| o   | ○     |   | O   | ⍥     |   | /   | ⌿     |   | ?   | ⍠     |
| p   | ⋆     |   | P   | ⍣     |   | [   | ←     |   | {   | ⍞     |
| q   | ?     |   | Q   |       |   | ]   | →     |   | }   | ⍬     |
| r   | ⍴     |   | R   |       |   | ;   | ⍎     |   | :   | ≡     |
| s   | ⌈      |   | S   |       |   | '   | ⍕     |   | "   | ≢     |
| t   | ∼     |   | T   | ⍨     |   | \   | ⊢     |   | \vert   | ⊣     |
| u   | ↓     |   | U   |       |   | §   |       |   | ±   |       |
| v   | ∪     |   | V   |       |   | .   | .     |   | >   | ⍀     |
| w   | ⍵     |   | W   | ⍹     |   |     |       |   |     |       |
| x   | ⊃     |   | X   | χ     |   |     |       |   |     |       |
| y   | ↑     |   | Y   | ¥     |   |     |       |   |     |       |
| z   | ⊂     |   | Z   |       |   |     |       |   |     |       |

** Terminology
[[https://mastering.dyalog.com/Introduction.html#conventions][source]]

- Array :: generic word for any set of values, whatever the number of its
  dimensions (whatever its shape)
  - rank: n
  - Mixed Array :: array that contains scalar numbers /and/ scalar characters
  - Nested Array :: array that contains /sub-arrays/
  - Simple Array :: array that is not /nested/
- Scalar :: a single value, a number or a single character
  - rank: 0
- Vector :: a plain list of values, e.g. ~4 32.5 7~ or ~'my water bottle'~
  - rank: 1
- Matrix :: an array with 2 dimensions
  - rank: 2
- Table :: another common word used for 2D-arrays (matrices)
  - rank: 2
- Cube :: common word used for 3D-arrays
  - rank: 3

- Shape :: vector that specifies the number of elements for each dimension
  in an array
- Rank :: integer that specifies the number of dimensions of an array
- Axis :: integer that selects a specific dimensional axis of an array
  (as the corresponding index for its /shape/)

- Scalar Function :: function that applies to each scalar of an array and
  returns an array of the same shape as its input
  - if *dyadic*, either its arguments must be the same shape or one/both of
    them must be a single value, in which case the returned shape matches
    the non-singleton array (if not both are singleton)
    - for any /nested arrays/, their sub-arrays must also either be matched by
      shape or with a single value
  - pervasive :: permeates down through the structure of nested arrays,
    until it reaches the lowest-level items, and then applies itself at this
    level

** Conditionals

*If-statements*

Imperative if-statement in Dyalog APL:
: :If <condition>
:   <true-branch>
: :EndIf

Example ([[https://youtu.be/myoK22rq1jk?t=1026][source]]):
#+begin_src gnu-apl
∇vowels←JustVowels word
  vowels←''
  :For letter :In word
    :If letter∊'aeiou'
      vowels,←letter
    :EndIf
  :EndFor
∇
#+end_src

GNU APL does not support control structures, but this works:
: ∇ r←<function header>
:   →(<condition>)/error
:   r←<true-branch>
:   →0
: error:
:   r←<false-branch>
: ∇
- source: [[https://stackoverflow.com/a/37907592]]

Example: function to calculate binomial coefficients
- adapted from snippet A.3 in Iversons [[https://www.jsoftware.com/papers/tot.htm][“Notation as a Tool of Thought”]],
  which doesn’t work in GNU APL
#+begin_src gnu-apl
∇r←bc arg ;x
  →(arg=0)/error
  r←(x,0) + (0,x←bc arg-1)
  →0
error:
  r←1
∇
#+end_src

*Conditional expressions*

GNU APL doesn’t have guards for conditional expressions, so this will work
in Dyalog but NOT in GNU APL:
: {<b>:<b=1> ⋄ <b=0>}
- 1→true, 0→false

There are [[https://stackoverflow.com/questions/15752895/conditional-function-in-apl][various workarounds]], but they will evaluate both their true and
their false branch:
- Using *Index*:
: <i> ⌷ <i=1> <i=2>
- same with bracket notation:
: (<i=1> <i=2>)[<i>]
- Using *Pick*:
: <i> ⊃ <i=1> <i=2>
- index ~i~ acts as a “boolean”, with 1-indexed values 1→“false” and 2→“true”
- set index origin to 0 to avoid adding 1 to the boolean:
  : ⎕IO←0

** Loops

Imperative for-each loop in Dyalog APL:
: :For <name> :In <v>
:   <body>
: :EndFor

Example ([[https://youtu.be/myoK22rq1jk?t=821][source]]):
#+begin_src gnu-apl
∇t←Count array;element
  t←0
  :For element :In array
    t+←1
  :EndFor
∇
#+end_src

Count with a recursive approach (only in Dyalog):
#+begin_src gnu-apl
{⍺←0 ⋄ 0=⍴⍵:⍺ ⋄ (⍺+1)∇1↓⍵}
#+end_src

Count with higher-order function:
#+begin_src gnu-apl
{+/⍵=⍵}

⍝ even simplier:
{≢⍵}
{⍴⍵}
#+end_src

Count as a derived function (only in Dyalog):
#+begin_src gnu-apl
(+/=⍨)
#+end_src

** Definitions

To define a variable:
: <name> ← <x>
- values can be assigned to multiple variables in one expression, e.g.:
  : (g h j) ← 30 51 49
  - the parentheses can be left out, but this is highly discouraged

Variable names are case-sensitive and must not start with a digit.

The following letters are allowed for variable names:
#+begin_src text
0123456789
ABCDEFGHIJKLMNOPQRSTUVWXYZ_
abcdefghijklmnopqrstuvwxyz
ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝẞ
àáâãäåæçèéêëìíîïðñòóôõöøùúûüþ
∆⍙
#+end_src


Redefinition is not allowed! Erase the definition first:
: )ERASE <name>

*Direct function* (like a lambda)

Embedded in another expression:
: … { <body> } …
As an ad-hoc definition:
: <fn-name> ← { <body> }

~body~ may contain the following parameters:
- ~⍺~ for /left-hand/ argument
- ~⍵~ for /right-hand/ argument

*Explicit function definition*

: ∇<result-name> ← <?l-arg> <fn-name> <?r-arg> <? ;local-vars ;…>
:  <body>
:  …
: ∇

** Data Structures
*** Array

Sequence of zero or more items.

Arrays can be multi-dimensional, Dyalog APL supports up to 15 dimensions.
- ~<n m …>⍴<a>~ constructs a multi-dimensional array along axes ~n~, ~m~, …

**** Shape & Rank

- ~⍴<a>~ gets the /shape/ (axis-length for each dimension) of an array
- ~≢⍴<a>~ gets the /rank/ (number of dimensions) of an array
  - scalars have a rank of 0
  - note: ~1⍴42~ is an 1D-array (one item), while ~42~ is a scalar, or
    0D-array!

**** Index

Arrays/vectors are *1-indexed* by default.
- set index origin to 0 to avoid adding 1 to the boolean:
  : ⎕IO←0
  - ~⎕IO~ to see the current index origin

Get item(s) from /n/-dimensional array in the shape specified by /n/ indices:
: <arr>[i1;i2;…in]
Each index can be a vector of indices, selecting multiple parts from each
axis of the array:
: <arr>[i1 j1 …; … ;in jn …]
Selections can be independent of one specific row/column/… intersection by
specifying multiple vectors of length /n/:
: <arr>[(i1 … in)(j1 … jn)…]

Indices can repeat to get the same item multiple times
- instead of listing indices directly, they can be enumerated with ~⍳~

Get item(s) from /n/-dimensional array by /k ≤ n/ indices:
: <i1 i2 … ik> ⌷ <arr>
Equivalently:
: <(i1 i2 … ik)> ⌷ <arr>
- when not specifying all /n/ axes, /k/-dimensional sub-arrays are returned
  Each index can be a vector of indices, selecting multiple parts from
  each axis of the array:
: <(i1 j1 …) (i2 j2 …) … (ik jk …)> ⌷ <arr>
- *Note:* must specify at least two axes

Examples:
- ~xs[1 5 6;1 3]~ selects rows 1, 5 and 6 with columns 1 and 3 each
  - ~(1 5 6)(1 3)⌷xs~ is equivalent
- ~xs[3;]~ selects all cols from row 3, ~xs[;]~ returns the whole array


Set items at index/indices in array to the same number of values or a
single scalar:
: <arr>[i j k…] ← xi xj xk…
: <arr>[i j k…] ← x
- *Note:* the replacement array must have exactly the same shape as the
  array of indices it replaces

An index can be of any shape and the result will always match the shape of
the index, as if each item of the index had been replaced by the item it
designates.

**** Axis

*Axis Operator*

The square-bracket notation to select the axis on a function behaves
like an operator which produces a derived function, which is why it is
often called the /axis operator/.

*Dyadic scalar functions* normally apply to each scalar of its arguments,
but they can also be applied to a specific ~axis~ of an array. The axis of
the higher-dimensioned array gets selected, while the other argument
must be an array of the same length as that axis:
: <L> <f>[axis] <R>
- e.g. for a 3x2 matrix, ~mat×[1]2 3 4~ multiplies the first row by 2, the
  second by 3 and the third by 4, while ~mat×[2]5 6~ multiplies the first
  column by 5 and the second by 6

Some *dyadic non-scalar functions* and some *operators* can also be applied
to a given axis and may reduce (e.g. ~/~) or expand (e.g. ~,)~ the array
along that axis.

*** Character

A single character is a scalar (0-dimensional), a string of characters is a
character vector. Multiple strings are represented by a nested array.

To enter an apostrophe ~'~, it must be doubled, e.g.:
: 'It''s raining, isn''t it?'

Unicode characters of multiple bytes count as single characters.

#+begin_src gnu-apl
      ≢⍴'a'
0
      ≢⍴'ab'
1

      ≢'🙋'
1
      ≢'镕'
1
#+end_src

*** Number

*Scientific notation*

Positive exponent:
: <n>e<exp>
Negative exponent:
: <n>e¯<exp>

*Complex Numbers*

: <real>J<imag>

** Primitive Functions
List of all scalar (mon./dya.) functions:
- https://mastering.dyalog.com/Appendices.html#appendices-scalar-functions

Monadic/Dyadic:
: + - × ÷ | ⌊ ⌈ ⋆ ⍟ ○ ! 
Only Monadic:
: ~ ? ⊢ ⊣
Only Dyadic:
: ∧ ∨ ⍲ ⍱ < ≤ = ≥ > ≠

List of all operators:
- https://mastering.dyalog.com/Appendices.html#dyalog-apl-operators
  
*** General
**** ~◊~ → *Statement separator*

Display expressions separately on multiple lines:
: <expr1> ◊ <expr2> ◊  …

**** ~⍝~ → *Comment*

Add a comment:
: ⍝ <some comment>

**** ~←~ → *Assignment* (dya.)

Assign the value of an expression to a variable name:
: <name> ← <expr>

**** ~⍕~ → *Format* (mon./dya.)

Returns a character representation of its argument.

**** ~⊣~ / ~⊢~ → *Same* (mon.), *Left / Right* (dya.)

In the monadic case, returns its argument as is (identity function).
- can be used to display the value of a variable from an assignment

In the dyadic case, returns its /left/ (~⊣~) or /right/ (~⊢~) argument.

*** Arithmetics
**** ~¯~ → *Negative Number*

-/n/:
: ¯n

**** ~|~ → *Magnitude {Abs. value}* (mon.), *Residue {Remainder/Modulus}* (dya.)

/Absolute value/ (real number) or /magnitude/ (complex number) of ~n~:
: |<n>
- the magnitude of a complex number is the length of its diagonal on the
  complex plane

~n~ is a /divisor/ of ~m~ OR ~m~ /mod/ ~n~:
: <n>|<m>

Equivalence (see [[https://mastering.dyalog.com/Some-Primitive-Functions.html#residue][explanation]]):
: (<n>|<m>) ≡ (<m> - (<n> × (⌊(<m>÷<n>))))

**** ~+~ → *Conjugate* (mon.), *Addition* (dya.)

With no /imaginary/ part, the monadic form acts as the /identity function/,
as the complex conjugate of a real number is the number itself.
- this is also true for character input

Example:
- ~+ 0J1~ results in ~0J¯1~

**** ~-~ → *Negation* (mon.), *Subtraction* (dya.)

/Negation/ is not /logical negation/, which is “Not” (~~~). This will only
reverse the minus sign of any number.
- note that ~- 0~ is just ~0~

**** ~×~ → *Direction/Signum* (mon.), *Multiplication* (dya.)

For real numbers, /Direction/ simply returns the sign of the number:
- ~1~ for positive numbers
- ~0~ for zero
- ~¯1~ for negative numbers

For complex numbers, the number is scaled to have a /magnitude/ of 1.

Geometrically, complex numbers can be represented as triangles, which
reveals a relation between monadic ~×~ and ~|~:
- the “smaller triangle” (via ~×~) times the magnitude of the “original
  triangle” (via ~|~) returns the original triangle, as shown in:
  : v ≡ (×v)×|v

**** ~÷~ → *Reciprocal* (mon.), *Division* (dya.)

Reciprocal (1 / ~n~):
: ÷<n>

- division by 0 throws a domain error
- ~0÷0 = 1~ (this convention can be [[https://mastering.dyalog.com/Some-Primitive-Functions.html#some-primitive-functions-division-control-div-and-other-mathematical-subtleties][changed]])

**** ~⋆~ → *Exponential* (mon.), *Power* (dya.)

Exponential (/e/ to the power of ~n~):
: ⋆<n>

~n~ to the power of ~m~:
: <n>⋆<m>

- there is no special square-root function, so √2 is just ~2 * 0.5~
- also, the imaginary number is: ~¯1 ⋆ 0.5 = 0J1~

**** ~!~ → *Factorial* (mon.), *Combinations* (dya.)

Factorial of ~n~:
: !<n>

Number of ~k~-combinations out of ~n~ items (binomial coefficient function):
: <k>!<n>

Examples:
- ~2!6~ is the same as ~(!6)÷(!6-2)×!2~ (= 15)
- pascal’s triangle (with apex on the left): ~pas←{((⍳⍵)-1)∘.!(⍳⍵)-1}~

**** ~⍟~ → *Logarithm*

Natural logarithm of ~n~:
: ⍟<n>

Base ~b~ logarithm of ~n~:
: <b>⍟<n>

Equivalences:
: +/m⍴n ←→ n×m
: ×/m⍴n ←→ n*m
: +\m⍴n ←→ n×⍳m
: ×\m⍴n ←→ n*⍳m
: ×/v ←→ *+/⍟v

**** ~⌊~ / ~⌈~ → *Floor / Ceiling* (mon.), *Minimum / Maximum* (dya.)

Can be used to cap values in an array to upper/lower bounds.

To /round/ decimal values to the /nearest/ integer, two methods can be used:
- ~⌊v+0.5~ will round /up/ in case of x.5
- ~⌈v-0.5~ will round /down/ in case of x.5

Equivalences:
: ⌈/v ←→ -⌊/-v
: ⌊/v ←→ -⌈/-v

*** Scalars
**** ~⍬~ → *Empty numeric vector* (nil.)

#+begin_src gnu-apl
      ⍬≡⍳0
1
      ⍬≡0⍴0
1
      ⍬≡0 0⍴0
0
      ⍬≡''
0

      3 2⍴⍬ 1 2
   1 
2    
1  2 

      ⍬⍴5 3 6
5  ⍝ the vector collapses to a zero-dim. point, the first element
#+end_src

**** ~?~ → *Roll* (mon.), *Deal* (dya.)

Select random number from ~⍳n~:
: ?<n>
… for each integer in vector:
: ?<v>
- e.g. to roll 10 dices: ~?10⍴6~
- note that selecting from ~⍳n~ means 0 is not included!

Pick/deal ~n~ random integers from ~⍳m~ without repetition:
: <n>?<m>
- ~n~ must be ≤ ~m~

**** ~⊤~ → *Encode* (dya.)

Encode each number in vector in the number system with radices ~r~:
: <r …> ⊤ <v>
- the count of ~r~ determines the number of places in the resulting number
  - e.g. ~2 2 2 ⊤ 5~ represents the number 5 in 3 binary places: ~1 0 1~
  - with a vector, numbers are arranged as columns in the result

Example: boolean matrix function ~T←{(⍵⍴2)⊤(⍳2⋆⍵)-1}~
- adapted from snippet A.2 in Iversons [[https://www.jsoftware.com/papers/tot.htm][“Notation as a Tool of Thought”]],
  which doesn’t work in GNU APL
    
*** Logic
**** ~∼~ → *Not* (mon., bool.), *Without* (dya.)

Remove element(s) ~x~ from vector:
: <v>~<x>
- e.g. ~'apple'∼'p'~ ⇒ ~ale~
- the size and shape of ~x~ are irrelevant, only its items are used

**** ~∨~ ~∧~ → *Disjunction / Conjunction* (dya.), *GCD / LCM* (dya.)

Find the /greatest common divisor/ (GCD):
: <x>∨<y>
Find the /least common multiple/ (LCM):
: <x>∧<y>

Equivalences:
: ∧/b ←→ ~∨/~b
: ∨/b ←→ ~^/~b

**** ~⍱~ ~⍲~ → *Nor / Nand* (dya.)
**** ~=~ ~≠~ → *Equality / Not equal, *Equivalence / Exclusive-or* (dya.)

Element-wise (scalar) comparison, NOT a check for array equality!
- use ~≡~ and ~≢~ instead

Equivalences:
: ≠/b ←→ ~=/~b
: =/b ←→ ~≠/~b

**** ~≤~ → *Less than or equal* (dya.), *Material implication* (dya., bool.)
- /a ≤ b/  can be translated to  /a → b/  in logic.

**** ~≥~ → *Greater than or equal* (dya.), *Converse (implic.)* (dya., bool.)
- /a ≥ b/  can be translated to  /a ← b/  in logic.

**** ~<~ → *Less than* (dya.), *Material nonimplication* (dya., bool.)
- /a < b/  can be translated to  /a ↛ b/  in logic.

**** ~>~ → *Greater than* (dya.), *Converse nonimplication* (dya., bool.)
- /a > b/  can be translated to  /a ↚ b/  in logic.

**** Logical truth tables:
#+begin_src gnu-apl
      0 1∘.,0 1
0 0  0 1  ⍝  all pairs in a × b
1 0  1 1 

      0 1∘.=0 1
1 0  ⍝  a ⇔ b
0 1
      0 1∘.≠0 1
0 1  ⍝  a XOR b
1 0

      0 1∘.∨0 1
0 1  ⍝  a ∨ b
1 1
      0 1∘.∧0 1
0 0  ⍝  a ∧ b
0 1

      0 1∘.≤0 1
1 1  ⍝  a → b
0 1
      0 1∘.≥0 1
1 0  ⍝  a ← b
1 1

      0 1∘.<0 1
0 1  ⍝  a ↛ b
0 0
      0 1∘.>0 1
0 0  ⍝  a ↚ b
1 0
#+end_src

*** Arrays
**** ~≡~ → *Depth* (mon.), *Match* (dya.)

? Get the depth of an array:
: ≡ <arr>

Check if two arrays are equal:
: <arr> ≡ <arr>
- returns a boolean scalar

**** ~≢~ → *Tally* (mon.), *Not match* (dya.)

Get the number of elements of an array (main axis):
: ≢ <arr>

Check if two arrays are different:
: <arr> ≢ <arr>
- returns a boolean scalar

**** ~↑~ → *First* (mon.), *Take* (dya.)
**** ~↓~ → *Drop* (dya.)
**** ~⊂~ → *Enclose* (mon.), *Partitioned Enclose* (dya.)

Enclose/“zip” an array for nesting (returns a scalar):
: ⊂<arr>
- can be used to assign a nested array to an index in another array:
  - e.g. ~a ← 1 2 3 ⋄ a[2] ← ⊂15 20 25 ⋄ ⎕ ← a~ results in ~1 15 20 25 3~

**** ~⊃~ → *First* (mon.), *Pick* (dya.)

Extract the first item of an array (“unzips” an /enclosed array/):
: ⊃<arr>

Pick an item in ~arr~ by index/indices:
: <idx>⊃<arr>

**** ~, ⍪~ → *Ravel* (mon.), *Catenate {Join} / …first* (dya.)

Join (“ravel”) scalars of an array into a vector (“row-major” order):
: ,<arr>
- /sub-arrays/ are preserved

Catenate two arrays (along ~axis~):
: <arr>,<arr>
: <arr>,[axis]<arr>
- defaults to last axis/dimension of the array
- for /axis 1/, ~<arr>⍪<arr>~ is equivalent to ~<arr>,[1]<arr>~

Specifically:

Catenate two scalars to a vector:
: <s>,<s>

Catenate two vectors to an extended vector:
: <v>,<v>

Catenate scalar to matrix as new row (~i~ →1) or column (~i~ →2):
: <m>,[i]<s>
- creates copies of the scalar along the catenation axis

Catenate vector to matrix as new row (~i~ →1) or column (~i~ →2):
: <m>,[i]<v>
- vector length must match row/col count on catenation axis

Catenate matrix to matrix before/after first/last row (~i~ →1) or column
(~i~ →2):
: <m>,[i]<m>
- number of rows/columns on catenation axis must match between matrices

**** ~/~ ~⌿~ → *Replicate (Compress) / …first* (dya.)

Filter by boolean vector:
: <bv>/<v>
- e.g. ~0 1 0 1/'tesa'~ results in ~ea~
- e.g. ~'aeiou'{(⍵∊⍺)/⍵}~ will filter a word for vowels

Replicate elements in ~vr~ according integer counts in ~vl~:
: <vl>/<vr>
- e.g. ~1 2 3/'abc'~ results in ~abbccc~
- if ~vl~ is a single scalar, it will apply to all elements of ~vr~
- negative integers will use /n/ *fill items* instead
  - for numbers, the fill item is ~0~, for characters it is ~' '~

**** ~\~ ~⍀~ → *Expand / …first* (dya.)

**** ~∊~ → *Enlist* (mon.), *Membership* (dya.)

Check if elements in ~match~ array are members of ~arr~:
: <match>∊<arr>

Enlist all elements in the array (even nested ones):
: ∊<arr>

**** ~⍳~ → *Index generator* (mon.), *Index of* (dya.)

Generate a number sequence [ 1, ~n~ ]:
: ⍳<n>
Multi-dimensional:
: ⍳<n> <m> …

Index all items in vector by their index in search vector:
: <search>⍳<v>
- items not matched are indexed with last index of match vector + 1
  - this can be used beneficially as a “not found” item in another
    vector that matches the indices afterwards
- only the first match is listed for each item in search vector

Equivalences:
: +/⍳n ←→ ((n+1)×n)÷2

**** ~⌽~ ~⍉~ ~⊖~ → Reversal / Rotation / Transposition
- ~⌽~ → *Reversal* (mon.), *Rotation* (dya.)
- ~⊖~ → *Reverse first* (mon.), *Rotate first* (dya.)
- ~⍉~ → *Transpose* (mon.), *Dyadic transpose* (dya.)
- “first” meaning /first axis/ (e.g. vertical in a matrix)
  
? Equivalent for matrix ~m~ and rotation ~n~
: (⌽[1]<m>) = ⊖<m>    (<n>⌽[1]<m>) = <n>⊖<m>
: (⌽<m>) = ⊖[2]<m>    (<n>⌽<m>) = <n>⊖[2]<m>

Reverse array on last (rightmost) axis:
: ⌽<a>
Reverse array on first (leftmost) axis:
: ⊖<a>
Reverse array on specified axis:
: ⌽[i]<a>
: ⊖[i]<a>
- e.g. for matrix: /column/ order (~i~ →1), /row/ order (~i~ →2), …
- ? same for ~⌽~ and ~⊖~

Rotate array by ~n~ elements on last (rightmost) axis left-/upwards:
: <n>⌽<a>
Rotate array by ~n~ elements on first (leftmost) axis up-/leftwards:
: <n>⊖<a>
Rotate array by ~n~ elements on specified axis up-/leftwards:
: <n>⌽[i]<a>
: <n>⊖[i]<a>
- e.g. for matrix: /column/-wise (~i~ →1), /row/-wise (~i~ →2), …
- negative ~n~ rotates in the opposite direction
- ? same for ~⌽~ and ~⊖~

Swap rows and columns (→ /transpose/) on a matrix:
: ⍉<m>
Swap axes in specified order on array:
: <i j k…>⍉<a>
- ~2 1~ on a matrix is equivalent to the monadic transpose
- ~1 1~ takes the /leading diagonal/

**** ~⍴~ → *Shape* (mon.), *Reshape* (dya.)

Form a vector of /n/ elements:
: <n>⍴<x>
Form a matrix of /m/ rows and /n/ columns:
: <m> <n>⍴<x>

Note: elements will repeat if ~(≢x) < m×n~
- e.g. ~6⍴4~ results in ~4 4 4 4 4 4~

**** ~¨~ → *Each* (mon./dya.)

e.g. ~+/¨(1 2) (3 4)~ will take the sum for each subvector

**** ~⌹~ → *Matrix inverse* (mon.), *Matrix divide* (dya.)

**** ~⍋~ ~⍒~ → *Grade Up/Down* (mon.), *Dyadic Grade Up/Down* (dya.)

Return indices which would select items in ascending order:
: ⍋ <arr>

Can be used to sort an array via sort indices from a different array of
the same shape:
#+begin_src gnu-apl
      names←'Joe' 'Sue' 'Sam'
      ages←34 22 25
      names[⍋ages]
┌→──┬───┬───┐
│Sue│Sam│Joe│
└──→┴──→┴──→┘
      names[⍒ages]
┌→──┬───┬───┐
│Joe│Sam│Sue│
└──→┴──→┴──→┘
#+end_src
- [[https://help.dyalog.com/19.0/#Language/Symbols/Grade%20Up.htm][source]]

** Operators (higher-order functions)
Operators produce /derived functions/, given one or two functions as input
(their /operands/). For a monadic operator, the operand is its /left/ argument.
- e.g. ~+/~

*** ~/~ ~⌿~ → *Reduce {Fold, N-Wise Reduce} / …first* (mon.)

Apply ~f~ between each element of the array:
: <f>/<arr>
- by default applied along the last axis of the array
for /axis/ ~n~:
: <f>/[n]<arr>
- e.g. column (~n~ →1), row (~n~ →2), … of a matrix
- the resulting /shape/ is the shape of the array without its ~n~'th item,
  reducing its /rank/ by 1 (the origin of the term “reduce”)
- for /axis 1/, ~<f>⌿<arr>~ is equivalent to ~<f>/[1]<arr>~

~n~-wise reduction (calls ~f~ on ~n~ successive items of ~arr~):
: <n><f>/<arr>
- e.g. ~3,/⍳5~ ⇒ ~1 2 3  2 3 4  3 4 5~

---

If ~f~ is a *scalar function* …

… and the argument is a *nested array*, applies ~f~ between the /ith/ items of
each sub-array. Scalars are applied to all items. The result is a nested
array of the same length as the sub-arrays.
- e.g. ~+/ (1 2 3) (4 5 6) 10~ gets applied like:
  : ((1 + 4 + 10) (2 + 5 + 10) (3 + 6 + 10))
  : = (15 17 19)
- all sub-arrays must be of the same shape or scalars

… and the argument is a *matrix*, applies ~f~ between each element of each /row/
of the matrix.
- e.g. ~+/ 2 3⍴⍳6~ gets applies like:
  : 1 + 2 + 3  ⍝ 1st row
  : 4 + 5 + 6  ⍝ 2nd row
  : = 6 15

… and the argument is a *higher-dimensional array*, it will get reduced like
matrices: only the last (vector) axis gets reduced, the rest of the shape
stays the same.

*Note:* /non-commutative functions/ may produce counter-intuitive results!
This is because APL applies the function in /right-associative/ order.
- ~-/<v>~ produces an alternating sum, e.g. ~1 - 2 + 3 - 4 + …~
- ~÷/<v>~ produces an alternating product, e.g. ~1 ÷ 2 × 3 ÷ 4 × …~

---

*Non-scalar functions* get applied between each element of the first axis in
the array.
- e.g. ~,/0 (1 2) (3 4 5) (6 7 8 9)~ gets applied like:
  : ⊂ 0,(1 2),(3 4 5),(6 7 8 9)
  : = (0 1 2 3 4 5 6 7 8 9)

---

*** ~\~ ~⍀~ → *Scan / …first* (mon.)

Isolate the first “true” (~1~) value in a boolean vector:
: <\<b>
- e.g. ~<\0 0 1 1 0 1 1~ results in ~0 0 1 0 0 0 0~

Sum scan (vector of intermediate sums):
: +\<v>

_Note:_ for /non-associative/ functions like ~-~ or ~÷~, the right-to-left
evaluation rule of APL makes reductions and scans on these functions
behave in alternating ways with their right inverse functions (~+~ in case
of ~-~, ~×~ in case of ~÷~).
- e.g. ~⁠-/1 2 3 4~ evaluates like ~(1 - (2 - (3 - (4 - 5))))~, which, after
  sign inversion, is equivalent to ~1 - 2 + 3 - 4 + 5~.

_Note:_ the results from ~f\v~ on a /k/-element vector correspond to each
separate result of a /k/-prefix reduction ~f/v[1..k]~, NOT to intermediate
results of a single reduction!

*** ~.~ → *Product* (dya.): *Inner product* (~f.g~), *Outer product* (~∘.f~)

Inner product (generalised matrix product):
: <vl> <g>.<f> <vr>
-  applies function args like ~g/vl f vr~

Examples:
- dot product: ~+.×~
- multiplication table: ~(⍳10)∘.×⍳10~

Equivalences:
: p+.×q ←→ +/p×q

*** ~∘~ → *Beside and Bind* (dya.), *Compose {Jot}* (dya.)

~A∘B~ (matrix mult.) is essentially ~A +.× B~ optimized for space and speed.

Apply dyadic function ~f~ like ~XfY~ (swap arguments):
: (<f>∘<Y>)<X>
- e.g. ~(>∘0 1 4) 1 2 3~ results in ~1 1 0~

Compose two functions to apply them like ~g(f⍵):~
: <g>∘<f>
- in case of a left argument, applies ~g~ dyadically like ~⍺g(f⍵)~

*** ~⍨~ → *Commute/Switch* (mon., func.), *Constant* (mon.)
Swap arguments of a function:
: <f>⍨
- in case of a single argument to a dyadic function, passes the same
  argument twice, e.g. ~×⍨3~ is the same as ~3×3~

*** ~⌸~ → *Key* (mon.)

Take unique items from vector ~keys~ and match/associate them via the dyadic
function ~f~ with items at the same index in vector ~vals~:
: <keys> <f>⌸ <vals>

Example:
#+begin_src gnu-apl
      1 2 2 3 1 {⍺ ⍵}⌸ 'abede'
┌→┬──┐
↓1│ae│
├─┼─→┤
│2│be│
├─┼─→┤
│3│d │
└─┴─→┘
#+end_src

** System Functions
Write a vector of character vectors to a text file:
: <char-vecs> ⎕NPUT <path>

Example:
#+begin_src gnu-apl
⎕←(⊂'apple' 'pie') ⎕NPUT 'writing.txt'
#+end_src

* Patterns/Idioms
Also see:
- [[https://aplcart.info][APLcart]]

Rank of an array:
: ≢⍴ <arr>

Average:
: +⌿÷≢ <arr>

Check if all elements are equal in an array:
: ⊃∧.=⊢ <arr>

Catenate rows of totals to the bottom of a matrix ~m~:
: <m>,[1] +/[1]<m>

Flatten a nested array (joins sub-arrays):
: ,/ <nested-arr>

*Boolean masks* can be used to /count/ (~/+b~) or /select/ (~b/v~) corresponding true
elements from the original array.

* Dyalog implementation
https://www.dyalog.com

- based on APL2
- closed source, free for non-commercial use
- namespaces
- lexical scoping
- different paradigms like OOP, FP, etc.

Resources:
- [[https://help.dyalog.com/19.0/index.htm][Dyalog APL 19.0 Help]] (documentation on functions, etc.)
- https://www.dyalog.com/getting-started/tips.htm

** RIDE Editor

By default, ~`~ is used as a prefix key to enter symbols. Type ~``~ and a name
to have RIDE suggest the appropriate glyph.

*Input buffer:*
- press /Ctrl + Shift + Backspace/ to scroll backwards in input history
- press /Ctrl + Shift + Enter/ to scroll forwards in input history

*Session log:*
- press /Enter/ on a line in session log to re-execute it
- change a previous line in the session log to mark it for re-execution
  - the line will be marked with a tiny red dot and text color
  - pressing /Enter/ anywhere will execute all marked lines top to bottom
  - execution will copy the changed lines and keep the log unmodified
  - any error will prevent the next lines from executing
  - /Shift + ESC/ removes the mark
- press /Shift + Enter/ to edit a name/variable

*Note:* lines in the session log cannot be deleted from within RIDE on macOS

** System Functions

Dyalog built-in functions which provide services related to both the APL and
the external environment.
- case-insensitive names beginning with the ~⎕~ symbol.
- implicitly available in a clear workspace
- see ch. 4 “System Functions” in =Dyalog APL Language Reference Guide.pdf=

** System Commands

*Not* executable APL expressions that provide services or infos associated
with the workspace and the external environment.
- case-insensitive names beginning with the ~)~ symbol.
- see ch. 5 “System Commands” in =Dyalog APL Language Reference Guide.pdf=

A Dyalog workspace may contain objects, namely classes, namespaces,
operators, functions and variables defined by the user.

Workspaces & Sessions:
- ~)OFF~ saves the Session log before closing APL
  - workspaces will not be saved
- ~)SAVE <wsname>~ to save the /active workspace/ to a file named ~wsname~
  - without an explicit path, Dyalog uses the /workspace search path/
- ~)LOAD <wsname>~ to load workspace named ~wsname~
  - *replaces* the /active workspace/ in memory, unsaved changes are lost!
  - without an explicit path, Dyalog searches in /workspace search path/
  - when there are spaces in a name/path, must be wrapped in dquotes ~"~
  - the extension ~.dws~ can be omitted
- ~)DROP <wsname>~ to delete workspace named ~wsname~ from disk
- ~)WSID~ shows the name of the current workspace
  - this is the WS most recently loaded/saved, not necessarily identical to
    the /active workspace/ in memory
- ~)LIB <? path>~ to list all available workspaces (optionally from ~path~)
- ~)CONTINUE~ saves a temporary workspace named ~continue~ and terminates APL
  - type ~)LOAD continue~ to retrieve the workspace later on
- ~)COPY <wsname> <? x y …>~ to copy object(s) ~x y …~ from workspace ~wsname~ to
  the /active workspace/
  - *replaces* objects with the same name!
    - use ~)pcopy~ instead, which does not replace objects with the same name
    - replacing can be useful to revert changes made in the /active WS/
  - omit the object names to copy all objects
- ~)CLEAR~ clears the workspace
- ~)ERASE <x y …>~ erases object(s) ~x y …~ from workspace
- ~)ED <x>~ opens the editor to change defined object ~x~
- ~2⎕NQ⎕SE'FileWrite'~ makes display settings permanent
- =View > Show Workspace Explorer= shows a tree view of the current workspace

Files:
- ~)ED "<path>"~ to edit plain text files in Dyalog

** System Variables
Other than with [[System Commands]], these can be used as part of APL
expressions.

- ~⎕WSID~ → like ~)WSID~

** User Commands

Dyalog-specific user commands to access various utilities and functionality
within the Dyalog environment.
- case-insensitive names beginning with the ~]~ symbol.
- see ch. 1 “Display of Arrays” in =Dyalog Programming Reference Guide.pdf=

General:
- ~]Help~ opens the online documentation
- ~] -?~ to see a list of all available user commands
- ~]<cmd> -?~ to get help for ~cmd~ (~-??~ for more details and examples)
- ~]<cmd>~ shows the current state of ~cmd~ (append ~?~ for the full state)

Row processing:
: ]Rows [on|off|reset|?] [-style=<s>] [-fold=<f>] [-fns[=on|off]] [-dots=<c>]
- will cut, wrap, fold or extend the display of output lines to fit the
  Session window
- ~]Rows on~ enables row-processing
- ~]Rows off~ restores native ⎕PW block-wrapping

Boxing:
: ]Box [on|off|reset|?] [-style={non|min|mid|max}] [-view={non|min|mid|max}]
:      [-trains={box|tree|parens|def}] [-fns[=off|on]]
- ~]Box on~ to draw boxes for clearer visual separation in nested arrays
- ~-style=max~ for verbose boxes incl. hints on axes and data types
- ~-trains=tree~ to display function trains with a tree structure
- ~-fns=on~ to have boxes display in nested arrays even if they are printed to
  the session from within functions

Utilities:
- ~]Map~ displays the content and structure of the current workspace
- ~]Plot <data>~ draws simple graphs (see ~]Plot -??~)
- ~]Open <filename>~ opens a target file or web address in its default app
- ~]CD <dir>~ to change directory inside the APL session
- ~]Get <src>~ to import data/code in various formats from local/remote src
- ~]Repr <arr>~ to generate an expression for (almost) any given array

** Namespaces
Namespaces can be nested and are separated by a ~.~ (dot).
- relative name: ~NS1.NS2.OBJ~
- absolute name: ~#.NS.OBJ~
- ~#~ → top level or “Root” namespace
- ~##~ → parent or space containing the current namespace
- ~⎕SE~ → session namespace, preserved across workspace ~load~ and ~clear~

Create a namespace:
: )NS <nsname>
: ⎕NS <nsname>

Change current/relative namespace (similar to changing a directory):
: )CS <nsname>
: ⎕CS <nsname>

** Script Files
For functions/operators/objects.

Script files can be loaded into a Dyalog session:
: 2⎕FIX'/path/to/myscript.dyalog'

Example file:
#+begin_src gnu-apl
:Namespace MyNamespace
    
    ⍝ Variables
    SomeVar ← 42
    
    ⍝ Functions
    ∇ result ← Add(x y)
        result ← x + y
    ∇
    
    ⍝ Nested namespace
    :Namespace Nested
        InnerVar ← 100
    :EndNamespace
    
:EndNamespace
#+end_src

** Libraries
*DISPLAY*
Like ~]box on.~

Load:
: )copy DISPLAY
Use:
: DISPLAY <x>

* GNU APL implementation
- based on APL2
- free and open source
- slow compared to Dyalog
- no lexical scoping
- no namespaces
- no control structures

Emacs package ~gnu-apl-mode~:
- http://www.gnu.org/software/apl/

* J implementation
https://www.jsoftware.com

- open source
- performant
- ASCII-compatible syntax

References:
- [[https://code.jsoftware.com/wiki/NuVoc][The NuVoc Portal]] (J primitives)
- [[https://www.jsoftware.com/help/dictionary/vocabul.htm][J vocabulary]]

Getting started:
- [[https://code.jsoftware.com/wiki/Vocabulary/HowNuVoc][Overview]]
- [[https://olegykj.sourceforge.net/jbyeg/jbyeg.htm][J by example]]
- [[https://code.jsoftware.com/wiki/Vocabulary/JayTaster][A taste of J]]
- [[https://code.jsoftware.com/wiki/Vocabulary/ArrayProcessing][How do you process an array?]]

Introductions:
- [[https://www.jsoftware.com/help/primer/start_here.htm][J primer]]
- [[http://www.jsoftware.com/help/learning/contents.htm][Learning J]]
- [[http://www.jsoftware.com/help/jforc/contents.htm][J for C programmers]]

** Installation
Follow instructions on:
- https://code.jsoftware.com/wiki/System/Installation/J9.4/Zips

Run MacOS fix (Terminal needs permissions for app management):
: ./macos-fix.command

Install dependencies for ~jqt.app~ to work:
: ./updatejqt.sh

Now ~jqt~ and ~jcon~ can be used.

** Usage
Exit jconsole:
: exit 0

Exit JHS: ~ctrl+\~

* BQN
- no complex numbers (yet, there is a [[https://mlochbaum.github.io/BQN/spec/complex.html][spec]])
