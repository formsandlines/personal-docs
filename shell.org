#+title: Docs/Shell

* How to
Tutorials/Overviews:
- https://missing.csail.mit.edu/2020/course-shell/
- https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Command_line
- https://gist.github.com/bradtraversy/cc180de0edee05075a6139e42d5f28ce
- https://www.computerhope.com/unix.htm

** Restart shell session
: $ exec "$SHELL"
- can also replace ~$SHELL~ with ~bash~ or ~zsh~

** Navigate scrollable output (less pager)

| Shortcut     | Action         |
|--------------+----------------|
| ~page-up/down~ | Scroll up/down |
| ~fn~ + ~up/down~ | (same?)        |
| ~q~            | Exit           |
| ~h~            | Help           |

Can also use Vim shortcuts.

** Text Navigation (?)

| Shortcut | Action                     |
|----------+----------------------------|
| ~ctrl-A~   | get to the beginning       |
| ~alt-F~    | move forward, word by word |
| ~ctrl-E~   | go the end                 |
| ~alt-B~    | go backward                |

** Break a command into multiple lines
Use ~\~ at the end of each line.
** Multi-line strings in shell
Heredocs retain indentation and avoid having to escape quotation marks, etc.:
#+begin_src shell
var=$(cat <<EOF
(let [x $foo]
  (str x "bar"))
EOF
)
echo $var
#+end_src

More infos:
- https://dev.to/awwsmm/elegant-multi-line-shell-strings-2lja

** Fixes
*** How to fix homebrew error: “invalid active developer path” after upgrade to
OS X El Capitan?:
- https://apple.stackexchange.com/questions/209624/how-to-fix-homebrew-error-invalid-active-developer-path-after-upgrade-to-os-x#209625

Check if user exists:
: $ sudo nano /etc/passwd

Change owner for all your Kirby files and folders: ~root &gt; www-data~ (I
suppose ~www-data~ is your web user):
: $ sudo chown -R www-data:www-data *

Change right on all your Kirby files and folders:
: $ sudo find myfolder -type d -exec chmod 755 {} \;
: $ sudo find myfolder -type f -exec chmod 644 {} \;

Remove quarantine attribute:
: $ sudo xattr -r -d com.apple.quarantine <path>

* Concepts
** User
- ~#~ before commands means “run this as root”

** Environment Variables

To print all env. variables:
: $ printenv

To print the contents of an env. variable:
: $ echo $[varname]
- e.g. ~$ echo $PATH~ to inspect the ~PATH~ env. variable
- to insert it into a string, use /double quotes/: ~$ echo "I am a $foo."~

To create a new env. variable:
: $ [varname]=[value]
- cannot have spaces in between!

To store the output of a command in an env. variable:
: $ [varname]=$([cmd])
: $ [varname]=`[cmd]`

Examples:
#+begin_src bash
$ foo="hello"
$ echo $foo
# > hello world!
$ echo "$foo world!"  # inserts variable value into the string
# > hello world!
$ echo '$foo world!'  # doesn’t work with single quotes in zsh!
# > $foo world!

$ foo=$(pbpaste)  # stores command output in variable
$ foo=`pbpaste`   # same
#+end_src

More infos:
- https://www.geeksforgeeks.org/environment-variables-in-linux-unix/
- https://phoenixnap.com/kb/set-environment-variable-mac

** PATH

~PATH~ is an environment variable.

Print ~PATH~:
: $ echo "$PATH"
: $ echo "${PATH//:/$'\n'}"  : human readable

Add to ~PATH~:
: $ export PATH=~/bin:/home/koen/.local/bin:$PATH
Or:
: $ path+=('~/bin')
: $ path+=('/home/koen/.local/bin')
: $ export PATH

To make a file available on the ~PATH~ system-wide (in ~sh~, ~zsh~, etc.):
1. symlink file to =/usr/local/bin/= (absolute pathname for hidden dirs!)
   - =/usr/bin/= is immutable even for root in OSX!
2. make symlink executable
3. restart shell

If you have an ~!~ in a quoted string it will end with ~`dquote>`~. Use single
quotes in this case.
- use ~ctrl-g~ to escape ~`dquote>`~ (aborts the command)

More infos:
- https://koenwoortman.com/zsh-add-directory-to-path/

** stdin / stdout / stderr

All Unix shell applications have 3 standard IO streams, each represented by
a numeric *file descriptor* (a number representing an open file):
- ~0~ -> *stdin*, the /standard input/ stream.
- ~1~ -> *stdout*, the /standard output/ stream.
- ~2~ -> *stderr*, the /standard error/ stream.

Keyboard commands in input streams:
- ~ctrl-c~ to cancel input
- ~ctrl-d~ to send(?) input (e.g. in ~sort~)

To tell a command to use /stdin/ / /stdout/ rather than a given file, type ~-~ .
- might not work on all commands

More infos:
- https://www.howtogeek.com/435903/what-are-stdin-stdout-and-stderr-on-linux/
- https://www.baeldung.com/linux/pipes-redirection

** Redirecting from stdin/out

Symbols:
- ~`>`~ redirects the output stream to a file instead of the terminal.
- ~`>>`~ appends to the file instead of replacing its contents.
- ~`<`~ reads the files content and takes it as the input stream.
- ~`2>`~ redirects the standard error (stderr) to a file

Patterns:
: <cmd>[stdout] >  <file(s)>  : write/replace in file(s)
: <cmd>[stdout] >> <file(s)>  : append to file(s)
: <cmd>[stdin]  <  <file(s)>  : read from file(s)

The ~tee~ command takes its input and writes it to a file or just to stdout,
so it can be used to wrap a file in a command for pipeing.
- this is useful to e.g. apply ~sudo~ while using ~`>`~
- can also be used to write stdin to both a file and the terminal

The syntax ~<([cmd])~ writes the output of a command in a temporary file and
passes the file handle to another command.
- this is useful for commands that only take files as input

In Unix, everything written to =/dev/null= will be discarded.

Examples:
#+begin_src bash
$ ls -la > myFiles.txt  # writes `ls -la` output in `.txt` file

$ wc < /usr/share/dict/words  # counts words from `words` file

$ python3 file.py < input.txt  # directs input from input.txt to file.py

$ python3 file.py > output.txt  # directs output from file.py to output.txt

$ echo 'Hallo' > hallo.txt  # writes output from echo cmd to file

$ cat < hello.txt > hello2.txt  # copies the file like cp

$ cat <(ls) <(ls ..)  # concatenates the output of `ls` and `ls ..`

$ diff <(ls foo) <(ls bar)  # can show the difference between two directories

$ cat x.txt 2> error.txt  # if x.txt is missing, error shows up in error.txt
#+end_src

More infos:
- https://linuxize.com/post/bash-redirect-stderr-stdout/

** here strings / here documents

Symbols:
- ~`<<<`~ denotes a 'here string'
- ~`<<[word]`~ denotes a 'here document'

Patterns:
: <cmd>[stdin] <<< <string>
: <cmd>[stdin] <<[word]

Examples:
#+begin_src bash
$ cat <<< 'hi there'  # reads `hi there` as a string

$ cat <<EOF  # reads from stdin until `EOF`
hi
there
EOF
# > hi
# > there

$ read first second <<< "hello world"
$ echo $second $first
# > world hello
#+end_src

Wrapped in single quotes will not interpret variables in text:
: $ cat <<'EOF'

To write the heredoc into a file:
: $ tee foo.txt <<EOF
: $ tee -a foo.txt <<EOF           : to append instead
: $ tee foo.txt <<EOF > /dev/null  : to prevent output display

Alternative:
: $ cat <<EOF > foo.txt

More infos:
- https://unix.stackexchange.com/questions/80362/what-does-mean

** Pipeing

Combines ~`<`~ and ~`>`~.

Takes output of the first (left) command and inserts it as input in the second (right) command.

Pattern:
: <cmd>[stdout] | <cmd>[stdin]

Examples:
: $ ls -la | awk '{print $7}'
- passes ~ls -la~ output to ~awk~ command (filters 7. text row)

** Reading input
: $ read <varname>
: $ read -p <prompt string> <varname>  : does not work in zsh
: $ read <varname>\?<prompt string>    : use this instead

Prompts the user interactively to enter a value that will be stored in a
variable. An optional prompt string can be given after a ~`?`~ character.

From ~man zshbuiltins~: “If the first argument contains a ~`?`~, the remainder
of this word is used as a prompt on standard error when the shell is
interactive.”

Examples:
: $ read "name?what's your name? "  : can be a single quoted string
: > what's your name?
: < Bob
: $ echo $name
: > Bob

In shell scripts, combine with ~echo~ for prompts:
#+begin_src bash
#!/bin/bash

echo "Enter a number"
read a

echo "Enter a number"
read b

var=$((a+b))
echo $var
#+end_src
** Pager
A pager is a covenient way to display and navigate large amounts of text in
the Terminal. It is opened with commands like ~less~ or ~man~.

* Shells
** Bash
*B*ourne *A*gain *SH*ell

Install Bash 4 using homebrew:
: $ brew install bash

Add the new shell to the list of legit shells:
: $ sudo bash -c "echo /usr/local/bin/bash >> /private/etc/shells"

Change the shell for the user:
: $ chsh -s /usr/local/bin/bash

** zshrc vs zprofile

- https://apple.stackexchange.com/questions/388622/zsh-zprofile-zshrc-zlogin-what-goes-where
* Terminal emulators
** iTerm2

| Shortcut | Action                      |
|----------+-----------------------------|
| ~ctrl-l~   | clear window                |
| ~ctrl-d~   | close window                |
| ~ctrl-r~   | search command history      |
| ~ctrl-c~   | cancel/delete input/command |

* Scripting
** shebang
/shebang/ -> combination of bash ~#~ and bang ~!~ followed by the bash shell path
: #! /bin/bash

Most portable way to reference bash in scripts:
: #!/usr/bin/env bash

Using the ~env~ command, the environment variable for a different scripting
runtime can be looked up in a script to be executed with that runtime:
: #!/usr/bin/env bb
: #!/usr/bin/env python

** Executing scripts
Run scripts with:
: $ ./<myscript.sh>
or
: $ bash <myscript.sh>

Script must have execution permissions
: $ chmod +x <myscript.sh>

The ~exit~ command can stop a script.

** Variables
See [[Environment Variables]]

Variables of function arguments:
- ~$0~ -> name of the function
- ~$1-$9~ -> arguments 1 … 9
- ~$@~ -> returns all arguments in a list
  - useful for iteration over each arg in a ~for~ loop
- ~$#~ -> number of args given to cmd

Other variables:
- ~$?~ -> error code of the previous command
  - returns ~0~ for no errors, otherwise ~1~
  - ~true~ always returns ~0~, ~false~ always returns ~1~
  - can be queried in terminal after a command was called to see if it worked
  - can be used in scripts for error handling
- ~$_~ -> last argument of the previous command
  - can be used in the terminal prompt to reuse the argument of the last cmd
- ~$$~ -> PID (process ID of the command that is running)

Looping through arguments:
#+begin_src bash
for arg in "$@"; do
  echo "$arg"
done
#+end_src

** Logical operators

| Operator | Description          |
|----------+----------------------|
| x ~&&~ y   | logical AND          |
| x ~\vbar\vbar~ y   | logical OR           |
| x ~;~ y    | concatenate commands |

- logical operators short-circuit like in e.g. JavaScript
- ~;~ will execute concatenated commands one after the other

** Control structures

*** *for*-loops:
: for <item-var> in <items…>; do
:   …
: done

- ~<items…>~ can be an index range with ~{from..to}~ such as ~{1..5}~
*** while-loops

*** *if*-conditionals
: if [[[ <condition> ]]]
: then
:   …
: elif [[[ <condition> ]]]; then
:   …
: else
:   …
: fi

- ~if … then~ can  be written in one line separated by a semicolon
- ~[ … ]~ is a posix shell compliant condition test
  - use if script should be portable across shells
- ~[[ … ]]~ is an extension of ~[ … ]~ and supports extra operations, e.g. ~||~
  instead of ~-o~ and regex matching with ~=~~
  - inspired from Korn shell
  - list of differences: [[http://www.gnu.org/software/bash/manual/bashref.html#Conditional-Constructs][bash manual section on conditional constructs]]
  - also see: https://stackoverflow.com/a/13542854/1204047
*** case statements
: case <expression> in
:   <pattern-1>)
:     …
:     ;;
:   …
:   <pattern-N>)
:     …
:     ;;
:   *)
:     …
:     ;;
: esac

- only the statements in the matched clause are executed
- the ~;;~ terminate a clause
- the ~*~ denotes the default pattern

More infos:
- https://www.howtogeek.com/766978/how-to-use-case-statements-in-bash-scripts/

*** *test* expressions
: test <expression>
: [ <expression> ]
- can be used in conditionals
- returns exit code ~0~ if true and ~1~ if false or ~>1~ if error occurred
- the ~-a~ operator has a higher precedence than the ~-o~ operator
- comparators for *test* expressions (from ~man test~):
  | Operator  | Operand Types | Evaluates true if …                     |
  |-----------+---------------+-----------------------------------------|
  | ~-b~ f      | file          | exists and is a block special file      |
  | ~-c~ f      | file          | exists and is a character               |
  | ~-d~ f      | file          | exists and is a directory               |
  | ~-e~ f      | file          | exists (regardless of type)             |
  | ~-f~ f      | file          | exists and is a regular file            |
  | ~-g~ f      | file          | exists and its set group ID flag is set |
  | ~-k~ f      | file          | exists and its sticky bit is set        |
  | ~(~ e ~)~     | expression    | is true                                 |
  | ~!~ e       | expression    | is false                                |
  | e1 ~-a~ e2  | expressions   | are both true (/and/)                     |
  | e1 ~-o~ e2  | expressions   | either one is true (/or/)                 |
  | s         | string        | is not the null string                  |
  | ~-n~ s      | string        | length is non-zero                      |
  | ~-z~ s      | string        | length is zero                          |
  | s1 ~=~ s2   | strings       | are identical                           |
  | s1 ~!=~ s2  | strings       | are not identical                       |
  | s1 ~<~ s2   | strings       | lower binary value of chars than        |
  | s1 ~>~ s2   | strings       | higher binary value of chars than       |
  | n1 ~-eq~ n2 | integers      | algebr. equal                           |
  | n1 ~-ne~ n2 | integers      | not algebr. equal                       |
  | n1 ~-gt~ n2 | integers      | algebr. greater than                    |
  | n1 ~-ge~ n2 | integers      | algebr. greater than or equal           |
  | n1 ~-lt~ n2 | integers      | algebr. less than                       |
  | n1 ~-le~ n2 | integers      | algebr. less than or equal              |

*** Examples:
Can be used in a one-liner:
: $ echo $(if [ 2 -gt 0 ]; then; echo 'yes'; else echo 'no'; fi)
: > yes

Counting from 1 to 5 with for:
#+begin_src bash
#!/usr/bin/env bash

for i in {1..5}; do
  echo $i
done
#+end_src

Counting from 1 to 5 with while:
#+begin_src bash
#!/usr/bin/env bash

i=1
while [[ $i -le 5 ]] ; do
  echo "$i"
  (( i += 1 ))
done
#+end_src

Comparing two input numbers:
#+begin_src bash
#!/usr/bin/env bash

echo 'Pick a number X'
read x
echo 'Pick a number Y'
read y

if [ $x -gt $y ]
  then
    echo 'X is greater than Y'
  elif [ $x -lt $y ]
  then
    echo 'X is less than Y'
  elif [ $x -eq $y ]
  then
    echo 'X is equal to Y'
fi
#+end_src

Checking for a word in multiple input files and adding it if not found:
#+begin_src bash
#!/usr/bin/env bash

for file in "$@"; do  # for each file in all the arguments
    grep foobar "$file" > /dev/null 2> /dev/null
    # When pattern is not found, grep has exit status 1
    # We redirect STDOUT and STDERR to a null register
    #   since we do not care about them
    if [[ "$?" -ne 0 ]]; then  # if error code is not equal to `0`
        echo "File $file does not have any foobar, adding one"
        echo "# foobar" >> "$file"
    fi
done
#+end_src

** Bash functions

To store a function in the env:
#+begin_src bash
mcd () {
  mkdir -p "$1"
  cd "$1"
}
#+end_src
: $ source <mcd.sh>
: $ mcd foo  : calls the `mcd` function with `foo` as `$1` arg

** Debugging
External tools:
- [[shellcheck]]

** Common operations
*** Get string length
Best way:
: $ foo="abcde"
: $ echo "Length is ${#foo}"
: > Length is 5

Alternatives:
: $ echo 'abcde' | awk '{print length}'
: > 5
: $ echo -n 'abcde' | wc -c
: >        5
*** Parse options

Simple solution through ~if~-statements and [[Variables]]:
#+begin_src bash
if [[ $1 = "-o" ]]; then
  echo "Option -o turned on"
else
  echo "You did not use option -o"
fi
#+end_src

Using the built-in ~getopts~:
#+begin_src bash
while getopts 'ab:c:' OPTION; do
  case "$OPTION" in
    a)
      echo "Option a used"
      ;;
    b)
      argB="$OPTARG"
      echo "Option b used with: $argB"
      ;;
    c)
      argC="$OPTARG"
      echo "Option c used with: $argC"
      ;;
    ?)
      echo "Usage: $(basename $0) [-a] [-b argument] [-c argument]"
      exit 1
      ;;
  esac
done
#+end_src
- to prevent errors on invalid options, prepend ~:~ on the options string
  - e.g. ~':abc'~
- to use option arguments, append ~:~ after the resp. option character
  - e.g. ~'ab:c:'~ to have ~b~ and ~c~ receive arguments

Using ~getopt~:

More infos:
- https://www.howtogeek.com/778410/how-to-use-getopts-to-parse-linux-shell-script-options/
- https://wiki.bash-hackers.org/howto/getopts_tutorial
- https://linux.die.net/man/1/getopt

** Guides:
- https://www.freecodecamp.org/news/shell-scripting-crash-course-how-to-write-bash-scripts-in-linux/
* Commands
** echo
Prints its args to stdout.
: -n  # no trailing newline char

** Source / .
: source <file> [args]
: . <full path to file> [args]

Reads and executes commands from specified ~<file>~ . Useful to load
functions, variables and config files into shell scripts.
- with ~.~ , a full (relative or absolute) path must be supplied

More infos:
- https://linuxize.com/post/bash-source-command/

** Command information
*** Manual
Open man-page for a command:
: $ man <cmd>

How to read usage notes:
: ls [OPTION]... [FILE]...
- square brackets mean optional
- ~...~ means one or more

How to read argument notes:
- anything that doesn’t take a value is called a *flag*
- anything that takes a value is an *option*

Search man-pages for a ~term~:
: $ man -k <term>
- navigation is similar to Vim:
  - ~q~: exit
  - ~space/f~: next page
  - ~w~: previous page
  - ~enter/e~: move 1 line
  - ~/[word]~ : search for ~[word]~ (~n~ for next occurrence)

For built-in commands in ~zsh~:
: $ man zshbuiltins

*** Command History
Print command history:
: $ history
: $ history 1  : from the beginning (1. command)

Use ~ctrl-r~ to backward-search in command history and insert a previous
command into the prompt.

Repeat command with ~id~ (retrieved from history):
: $ !<id>

Repeat previous command:
: $ !!


Examples:

Show all previous uses of the ~touch~ command:
: $ history 1 | grep touch

*** Show executable associated with a command
: $ which <cmd>

*** Undo/correct commands
External tools:
- [[thefuck]] can correct syntax errors of executed commands
*** Construct arg list for a command and execute
: xargs

Examples:

To pipe a sequence of arguments as lines of text from /stdin/ into a
function call:
: … | xargs <command>

: $ echo 'foo.txt\nbar.txt\nbaz.txt' | xargs touch
: (creates files foo.txt, bar.txt and baz.txt)

** User
*** Current user
Who is the current user?
: $ whoami

Print real user id + various other details related to account:
: $ id

*** Logins
Who logged in using which terminal/session at what time?
: $ who

Only this login/session:
: $ who am i

*** Switch user
: $ su <username>

*** Superuser
Execute as superuser (“Super user do”):
: $ sudo <cmd>

Get superuser shell:
: $ sudo su
- type ~exit~ to return to previous shell

To write to a permission-locked file using pipes:
: $ sudo <cmd> > <file>      : permission denied!
: $ <cmd> | sudo tee <file>  : this works
- in the first case, only ~cmd~ will be executed by ~sudo~ and it doesn’t know
  about ~file~, so ~sudo~ will not apply to ~file~

** Shell
*** Show default shell of user
What is the default shell of the user?
: $ echo $0

*** Show available shells
: $ cat /etc/shells

*** Show current shell
: $ echo $SHELL

*** Switch shell
Just name the shell executable:
: $ sh
: $ bash

More infos:
- https://www.cyberciti.biz/faq/how-to-change-shell-to-bash/

*** Exit shell
: $ exit

*** Clear (tidy up) shell
: $ clear

** Terminal interface
Print arguments to stdout:
: $ echo <text>

Set options for terminal interface (?)
: $ stty

** File system
*** Paths
To get the file part of a path:
: $ basename <path>

To get the directory part of a path:
: $ dirname <path>

*** Directories
**** Working directory
/print working/ (current) /directory/:
: $ pwd

**** Change directory
: $ cd /  : root directory
: $ cd ~  : home directory
: $ cd    : ^
: $ cd .  : current directory (no-op)

: $ cd /dir    : absolute path
: $ cd ~/dir   : path from home
: $ cd ./dir   : relative path (without leading /)
: $ cd dir     : ^
: $ cd ../dir  : previous/parent directory (also returns to symlink dir)

: $ cd -  : back to previous directory

External tools:
- auto jump (?)

**** Create directory
: $ mkdir <path/name …>
- ~-p~ (/parent/ directories) creates folders in between (if needed)
- can create multiple at once

**** Remove directory
: $ rmdir <dir>
- can only remove empty directories!

**** List directory items
: $ ls
: -a   : shows hidden items too
: -l   : (long list) detailled list with permissions, file sizes, etc.
: -r   : reverse listing
: -t   : sort by time modified (most recent first) before lexicographic
: -u   : use time of last access
: -U   : use time of file creation
: -S   : sort files by size
: -ld  : only details for specified directory
: -h   : human readable -> sizes with unit suffixes
: -R   : recursive -> shows subfolders
: -F   : shows directories with `/`, executable with `*`, links with `@`
: -i   : shows serial number of file
: -s   : shows number of file system blocks used by the file
: -G   : colorized output
: -lisa  : detailled list with exact specs
: -alt   : detailled list of all last modified files

Format of ~-l~: permissions | number of files (dirs) or hardlinks
(files) | owner | group | size | modification date | file name

List ~n~ items:
: $ ... | head -<n>

List only <filename>:
: $ ls -la | grep <filename>

External tools:
- [[tree]] lists items and subdirectories in a tree
- [[broot]] like ~tree~ but hides files in “unlisted” and enables fuzzy
  keyboard-navigation within listed directories
- [[nnn]] is like a mini file-explorer with keyboard-navigation

**** Finder
Open files (like double click in finder)
: $ open <path>  : open directory/file in finder (MacOS)
:        <url>   : open URL
: -a  : specifies application to open (otherwise uses default)

Open every text file:
: $ open *.txt

**** Search files/directories
Find location of files/directories (recursively searches in subdirs):
: $ find <starting dir>
: -name "<path/pattern>"  : file names to search for
: -type <t>  : type of files to search for
: -mtime <offset-time>  : find all files modified within <offset-time>
: -print
: -empty   : only empty files
: -delete  : delete found files
: -exec <cmd> <?>  : execute command on found files

Possible types for ~-type~:
| Symbol | Meaning           |
|--------+-------------------|
| ~b~      | block special     |
| ~c~      | character special |
| ~d~      | directory         |
| ~f~      | regular file      |
| ~l~      | symbolic link     |
| ~p~      | FIFO              |
| ~s~      | socket            |

Examples:

Find all =src/= directories in current working dir:
: $ find . -name src -type d

Find all Python files in a =test/= dir with any number of parent dirs:
: $ find . -path '**/test/*.py' -type f

Find all files modified within the last 24h:
: $ find . -mtime -1

Delete all files with name ~"file-"~:
: $ find . -name "file-*" -delete  #

Find all files with ~.tmp~ extension and call command ~rm~ on them:
: $ find . -name "*.tmp" -exec rm {} \;

Write found paths to =output.txt=:
: $ find . -name "file-*" > output.txt

More infos:
- https://kb.iu.edu/d/admm

External tools:
- [[fzf]] fuzzy finder
- [[fd]] like ~find~ but defaults to regex, respects =.gitignore=, color-codes
  output and has better unicode support
- [[ripgrep]] searches directories for a regex pattern respecting =.gitignore=

**** Search filesystem via database
~locate~ searches a (periodically updated) indexed database for all
pathnames which match a ~pattern~.
- much faster than e.g. ~find~

: $ locate <pattern>

The ~updatedb~ command is running through ~cron~ to keep the database
up-to-date.

*** Files
**** Create files
: $ touch <filename>
: -m 01120322  : change modification date (month/day/hour/min)
: -a 01120322  : change access date (format same as above)

Examples:

Create 100 files named ~"file-001.txt"~, etc.:
: $ touch file-{001..100}.txt

**** Copy files
: $ cp <source> <target>
: -i  : (interactive) ask before overwriting
: -r  : recursive (copies directories and subdirectories)
: -p  : keep user permissions
- write ~/*~ in source to copy only the content, but not the directory itself

**** Move/rename files
: $ mv <source> <target/renamed>
: -i  : (interactive) ask before overwriting
- move to directories with ~foo/~, since otherwise a file could be overwritten

Examples:

To move all files to parent dir:
: $ mv foo/* .
: $ mv foo/*(DN) .  : add (DN) for hidden files

External tools:
- [[rename]] can rename multiple files at once with patterns

**** Remove files
: $ rm datei
: -i  : (interactive) asks before deleting
: -r  : (rekursiv) also removes directories and subdirectories
: -f  : (force) deletes without asking

Examples:

Remove everything in the current folder:
: $ rm ./*
**** Clear file contents
To make a file completely empty:
: : > <file>
- ~:~ is the shell no-op command

**** Concatenate and print files
: $ cat <file …>  : prints <file> (concatenation if multiple files)
: -n  : line numbers

Create ~foo.txt~ with following lines as content:
: $ cat > foo.txt
: $ >  foo.txt  : equivalent
- finish with new line + ~ctrl-d~

Append to ~foo.txt~ (or create, if not exists):
: $ cat >> foo.txt
: $ >> foo.txt  : equivalent

Replace contents of ~otherFile.txt~ with ~file.txt~:
: $ file.txt >  otherFile.txt  #

Append contents of ~file.txt~ to ~otherFile.txt~:
: $ file.txt >> otherFile.txt

More infos:
- https://superuser.com/questions/15100/difference-between-lam-and-paste

// paste

?
// lam

?

**** View file contents
***** With a pager
: $ less <file>  : view whole file with linewise navigation (like vim)
: $ more <file>  : same?

? what is that:
- -c  # ???
- +3 foo.txt  # erst ab Zeile 3 anzeigen lassen
- +/Begriff foo.txt  # erst ab Begriff anzeigen lassen

**** File stats
View file status, creation date, last modification date, etc.:
: $ stat <file>

**** File change monitor
External tools:
- [[fswatch]] receives notifications when contents of files/dirs change

**** Search in files
Search contents of text files with regex:
: $ grep <regex-str> <file-path/pattern>
: -i, --ignore-case  : case-insensitive matching
: -C[num]            : print `num` lines of leading & trailing
:                    : context sorrounding match
: --color=[when]     : mark up matching text
:                    : `when`: `never` | `always` | `auto`
: -R                 : recursively searches for files
- use ~*~ to search in all files from current directory

Examples:

Searches for ~foobar~ in =mcd.sh=:
: $ grep foobar mcd.sh

Recursively search for ~foobar~ in all files from the current directory:
: $ grep -R foobar .

Search for ~'foo'~ in git log with colored matches + context:
: $ git log | grep 'foo' -C 10 --color="always"

Print any common files between directory ~'foo'~ and directory ~'bar'~:
: $ grep -Ff <(ls -l 'foo' | tr '\t' '\n') <(ls -l 'bar' | tr '\t' '\n')

External tools:
- [[ripgrep]] searches directories for a regex pattern respecting =.gitignore=
- [[fzf]] fuzzy finder

*** Logs
~log~ enables access to system wide log messages created by ~os_log~, ~os_trace~
and other logging systems.

To stream the whole log (can be huge):
: $ log show

*** Symlink

*CAUTION:* relative pathnames in the target will be interpreted as relative
to the parent directory of the symlink that is to be created

*CAUTION:* hidden paths will be ignored if not provided as absolute pathname
- e.g. use =/Users/name/.dir/= instead of =~/.dir/=

**** Softlink
Ordinary alias, used 99% of the time.

: $ ln -s <source> <target>
: -s  : (symbolic link / softlink)

**** Hardlink
Source and target files both point to the same content.
- same Inode ~xxxx~, same datablock
- almost NEVER need to use this

: $ ln <source> <target>

*** Alias

: $ alias w='cd /full/path/to/the/dir/I/always/work/on'
- can change to directory with ~w~

Saved alias:
: $ printf "%s\n" "alias foo='cd /bar/baz'" >> ~/.zshrc

Show type and path of the shortcut/command:
: $ type -a <cmd>

More infos:
- https://unix.stackexchange.com/questions/215948/how-to-make-an-alias-permanent

*** Permissions
Change permissions:
: $ chmod <change> <file>
: +x  : make executable (e.g. for scripts)
: u=rw,g=x,o=---  : absolute description
: 644             : octal description

: drwxr-xr-x
- ~d~: directory | =-=: file | ~l~: symlink
- ~rwx~ (1): owner
- ~rwx~ (2): group
- ~rwx~ (3): all else

Semantics are a bit different for directories:
- *read* means you are allowed to see the dir. contents
- *write* means you are allowed to rename, create or move files within the dir.
- *execute* means you are allowed to enter/open the dir.
  - to enter a dir., you must have ~x~ permission for it, and all its parents

Octal values:
- from ~4~: read / ~2~: write / ~1~: execute
: 7 rwx
: 6 rw-
: 5 r-x
: 4 r--
: 3 -wx
: 2 -w-
: 1 --x
: 0 ---

Add user:
: $ useradd <name> -p <pwd> -g <group> -d /home/myhomedir -s /bin/false
: -s  : change shell-access, e.g. /sbin/nologin  or  /bin/false

Add group:
: $ groupadd <name>

Delete group:
- (CAUTION: first, add all contained members to other groups!)
: $ groupdel <name>

Delete user:
- see https://www.cyberciti.biz/faq/linux-remove-user-command/
: $ userdel <name>
: -r  : delete user directory

Change user:
: $ usermod <name>
: -s  : change shell-access, e.g. /sbin/nologin  or  /bin/false

Change user password:
: $ passwd <username>

Add user to sudo group:
: $ usermod -aG sudo <user>

Inspect user details:
: $ grep <username> /etc/passwd

Change owner:
: $ chown …
- example: ~$ sudo chown -R yourusename:admin /usr/local/bin~

List all files of a user:
: $ find <dir> -user <user>

*** Compression

**** zip

https://www.tutorialspoint.com/unix_commands/unzip.htm

: $ zip <package.zip> <file …>

: $ unzip <package.zip>
: -l  : lists files inside zip
: -d ./other-dir  : unzip to different directory

Only unzip specified files:
: $ unzip <package.zip> <file …>
: $ unzip <package.zip> "file*.t?"  : wildcards
- ~*~ for mult. chars, ~?~ for single char in wildcards

Unzip everything except specified files:
: $ unzip <package.zip> -x <file …>

**** tarball
: $ tar
: -c  : Creates Archive
: -x  : Extract the archive
: -f  : creates archive with given filename
: -t  : displays or lists files in archived file
: -u  : archives and adds to an existing archive file
: -v  : Displays Verbose Information
: -A  : Concatenates the archive files
: -z  : zip, tells tar command that creates tar file using gzip
: -j  : filter archive tar file using tbzip
: -W  : Verify a archive file
: -r  : update or add file or directory in already existed .tar file

: -czvf <name>.tar.gz <input-dir>  : create tarball from input dir
: -xzvf <name>.tar.gz              : unpack tarball into current dir
: -tzvf <name>.tar.gz              : print contents

*** Encryption
Basic (weak) encryption:
: $ cksum <filename>

Calculate and verify 128-bit MD5 hashes:
- see https://en.wikipedia.org/wiki/Md5sum
: $ md5sum <filename>
Alternative:
: $ openssl md5sum <filename>

Calculate and verify SHA-1 hashes:
- see https://en.wikipedia.org/wiki/Sha1sum
: $ sha1sum <filename>

Calculate and verify SHA-2 hashes:
- see https://en.wikipedia.org/wiki/SHA-2
: $ sha256sum <filename>
Alternative:
: $ function sha256sum() { openssl sha256 "$@" | awk '{print $2}'; }
: $ sha256sum <filename>

External tools:
- [[gnupg]] uses GPG (open source version of PGP) to encrypt files

** String formatting
Formatted text output with variable ~%s~:
: $ printf "Hello %s.\n" George

Insert text in (new) file
: $ printf "%s\n" "Hello test" >> test.txt

More infos:
- https://www.computerhope.com/unix/uprintf.htm

** Network

*** File transfer
**** scp

For single files:
: scp <file to upload> <username>@<hostname>:<destination path>
- *Warning:* will replace existing file with the same name without asking!

For directories:
: scp -r <dir to upload> <username>@<hostname>:<destination path>
- *Warning:* will replace existing dir with the same name without asking!
- the ~dir~ will not replace the ~destination path~ directory but will be
  uploaded inside of it

More infos:
- https://stackoverflow.com/a/1894479/1204047

**** Curl
Curl transfers data from and to servers, via one of the protocols: HTTP,
HTTPS, FTP, FTPS, SCP, SFTP, TFTP, DICT, TELNET, LDAP or FILE
- to transfer multiple files use ~wget~ or FTP

: $ curl <options> <URL …>
: -o  : output file

More infos:
- https://www.tutorialspoint.com/unix_commands/curl.htm

*** SSH (Secure Shell Protocol)

**** SSH keys
List all ssh key files:
: $ ls -la ~/.ssh

Common names for ssh keys:
- ~id_rsa.pub~
- ~id_ecdsa.pub~
- ~id_ed25519.pub~

To start the ssh-agent:
: $ eval "$(ssh-agent -s)"

To add a key to the agent;
: $ ssh-add --apple-use-keychain <my-key-path>

To delete a key from agent:
: $ ssh-add -d "<my-key-path>.pub"
: $ ssh-add -D  : delete all keys

To change passphrase of a key or add a new passphrase:
: $ ssh-keygen -p -f <my-key-path>

**** SSH service
Restart SSH:
: $ service ssh restart

*** HTTPS Certification
External tools:
- [[certbot]] can create certifications for web domains

** Data manipulation
*** Reshape a data array
e.g. a column of numbers into a table

: $ pbpaste | rs <row-n>     : reshape to n rows, linewise
: $ pbpaste | rs -t <row-n>  : reshape to n rows, columnwise (transpose)
: -j     : right-adjust
: -g<n>  : gutter (space-chars between columns)
- combine options like ~-tj~

Examples with ~rs~:

: $ echo "a\nb\nc\nd" | rs 2
: > a  b
:   c  d

: $ seq 20 | rs 4
: > 1   2   3   4   5
:   6   7   8   9   10
:   11  12  13  14  15
:   16  17  18  19  20

: $ seq 20 | rs -t 5
: > 1   6   11  16
:   2   7   12  17
:   3   8   13  18
:   4   9   14  19
:   5   10  15  20

Examples with ~pr~:

: $ seq 20 | pr -5ats
: > 1   2   3   4   5
:   6   7   8   9   10
:   11  12  13  14  15
:   16  17  18  19  20

: $ seq 20 | pr -4ts
: > 1   6   11  16
:   2   7   12  17
:   3   8   13  18
:   4   9   14  19
:   5   10  15  20

More infos:
- https://leancrew.com/all-this/2022/09/reshaping-text/

*** Print sequential or random data
// jot

?
** Text manipulation
*** Word count
Count newlines, words and bytes of a file:
: $ wc foo.txt
: -l -w -c  : number of lines / words / chars

To count chars in a string (stdin):
: $ echo -n 'hallo welt' | wc
- use ~-n~ option in ~echo~ to not count the trailing newline char

*** Replace/trim chars
~tr~ replaces or trims chars from stdin.

: $ tr A-Z a-z          : replace uppercase with lowercase
: $ tr -cs A-Za-z '\n'  : trim multiple newline chars to a single one

Examples:

Map each character of the first set to the corresponding character of the
second set:
: $ echo 'hello, world' | tr 'ewol' 'ane.'
: > ha..e, ner.d

Delete all occurrences of the specified set of characters from the input:
: $ echo 'hello, world' | tr -d 'le'
: > ho, word

Compress a series of identical characters to a single character:
: $ echo 'feeding apple tree seeds' | tr -s 'ep'
: > feding aple tre seds

Lower to upper case:
: $ echo 'foo bar' | tr "[:lower:]" "[:upper:]"
: > FOO BAR

Strip out non-printable characters:
: $ echo 'n\na\tsa' | tr -cd "[:print:]"
: > nasa%

Split ~PATH~ into lines:
: $ echo $PATH | tr ':' '\n'

Split ~ls~ output into line:
: $ ls . | tr '\t' '\n'

*** Sort lines
~sort~ sorts lines from stdin
: $ sort <text>
: -n  : numeric sort
: -r  : reverse order
: -u  : unique keys
: -f, --ignore-case
: -k<start,stop>  : select a whitespace-separated column to sort by
: -t <delim>  : to specify a different delimiter for `-k`
- confirm input with ~ctrl-d~

Examples:

To start and stop ~sort~ at the first column of the input:
: $ sort -nk1,1

To sort numerically in reverse order:
: $ sort -rn

*** Filter unique lines
~uniq~ takes a sorted list of lines and prints only those that are unique.
: $ uniq <text>
: -c  : display count of duplicate lines

Examples:
: $ echo 'hello\nhello\nworld\nworld\nworld' | uniq -c
: > 2 hello
:   3 world

*** Filter n lines from head/tail
: $ head <file>  : filter first 10 lines of file
: $ tail <file>  : filter last  10 lines of file
: -n x  : `x` number of lines (e.g. `head -n 1 foo.txt`)
: -x    : ^ (-n can be omitted)
: -c x  : `x` bytes (characters?)

Examples:

Show only the 4. line:
: foo.txt | head -4 | tail -1

? what is that:
- -5
- +5  # Ab Zeile 5 alle weiteren Zeilen (plus unsichtbare Zeichen wie Zeilenumbruch/Dateiende)
- -3c  # letzte 3 Zeichen

*** Cut out parts of text
: $ cut -b <list> [-n] …  : byte positions
: $ cut -c <list> …       : char positions
: $ cut -f <list> [-w | -d <delim>] [-s] …  : fields (separated by delimiter)
- ~list~: comma or whitespace separated set of numbers and/or ranges

Examples:

To extract a specific (whitespace-separated) column from a tabular text:
: $ ls -l | cut -f <col-num> -w

To extract whitespace/tab-separated parts of a string:
: $ echo 'hallo welt' | cut -f 2 -w
: > welt

To cut out portions of a file:
: $ cut --delimiter=' ' -f 2 <file>

*** sed (stream editor)
Applies a regular expression find/replace pattern on each input line.

: $ sed <command/pattern> [file …]
: -E  : use extended (modern) rather than basic regular expressions (BRE’s)
Used to make changes to the contents of a stream.
- modification of an earlier programm called ~ed~.
- matches patterns and applies replacement only once per line
- the ~-E~ flag is recommended since ~sed~ is very old and often matches
  special symbols literally
  - e.g. without the flag groups ~(…)~ would have to be escaped: ~\(…\)~

Use ~\n~ to reference capture groups in the replace pattern.

Modifiers:
| Symbol | Description                          |
|--------+--------------------------------------|
| ~g~      | global (try multiple times per line) |
|        |                                      |

Examples:

: $ echo 'bba' | sed 's/[ab]//'  : > ba
: $ echo 'bba' | sed 's/[ab]//g'  : >
: $ echo 'abcababc' | sed -E 's/(ab|bc)*//g'  : > cc
: $ echo 'abcabbc' | sed -E 's/(ab|bc)*//g'  : > c
: $ echo 'Disconnected from invalid user Disconnected from 84.211' | sed 's/.*Disconnected from //'  : > 84.211

More infos:
- https://www.regular-expressions.info

External tools:
- regular expression debugger:
  - https://regex101.com

*** awk (column-based pattern-directed scanning and processing)
- ~awk~ is a whole programming language for data processing
- it can express what many specialized command-line tools are able to do
- by default parses input in whitespace-separated columns

Special patterns (in order):
- ~BEGIN { <expr> }~ -> matches line 0
- ~<regex-ptn> { <expr> }~ -> matches every line with ~<regex-ptn>~
- ~END { <expr> }~ -> matches after the last line

Examples:

Print a specific column:
: $ echo 'hello foo\nworld bar' | awk '{print $1}'
: > hello
:   world
: $ echo 'hello foo\nworld bar' | awk '{print $2}'
: > foo
:   bar

Print whole lines where in column 1 each entry is a '1' and in column 2
each entry starts with a 'c' and ends with an 'e':
: $ awk '$1 == 1 && $2 ~ /^c.*e$/ {print $0}'

Print the number of lines where in column 1 each entry is a '1':
- on line 0, set variable ~rows~ to ~0~
- on every line that matches ~$1 == 1~, increment ~rows~
- after the last line is matched, print the value of ~rows~
: $ awk 'BEGIN { rows = 0 } $1 == 1 {rows += 1} END { print rows }'
- this is the same as running ~wc -l~ afterwards

*** Concatenate multiple lines
: $ paste <file …>
: -s         : concatenate all lines of each input file
: -d <list>  : use one or more of given chars to replace newline
- replaces all but the last /newline/ character
- by default, replaces /newlines/ with a single /tab/ character
- use ~-~ to specify the /stdin/ instead of a file

Examples:

: $ paste -sd, <(seq 20)
: $ seq 20 | paste -sd, -  : same, but with pipeing
: > 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20

*** Tabular display
~column~ can format text into multiple columns, its purpose is to fit data
into the terminal for display. Use ~rs~ or ~pr~ to actually transform text
into a tabular format.

: $ column <file …/stdin>
: -c <column>  : fit input lines into n columns determined by `column` chars
: -t  : create table from separation by whitespace or delim chars (see `-s`)
: -s  : specify a set of chars to delim columns for the `-t` option
- formats input into multiple columns
- empty lines are ignored
- by default, fills all available space with columns
- rows are filled before columns

Examples:

: $ echo "header1 header2\nbar foo\n" | column -t
: > header1  header2
:   bar      foo

: input.txt:
: No.|Country|Yes/No
: 01|India|Y
: 02|US|Y
: 03|Australia|Y
: 04|China|N
: 05|Russia|Y
: 06|Japan|Y
: 07|Singapore|Y
: 08|South Korea|N
: 09|Finaland|Y
: 10|Ireland|Y

: $  column -t -s '|' input.txt
: > No.  Country      Yes/No
:   01   India        Y
:   02   US           Y
:   03   Australia    Y
:   04   China        N
:   05   Russia       Y
:   06   Japan        Y
:   07   Singpaore    Y
:   08   South Korea  N
:   09   Finaland     Y
:   10   Ireland      Y

More infos:
- https://www.howtoforge.com/linux-column-command/

*** Line-oriented text editor
: $ ed [<filename>]
: -p<char>  : use prompt `char`
: -s        : suppress diagnostics (good for scripts)
- commands are single characters on a line and may have parameters
- regular expressions in addresses or commands interpret /POSIX Basic
  Regular Expressions (BRE)/

**** Line addresses
Many commands use line addresses (relative to the current line)
- 0, 1 or 2 addresses followed by the command
- the address ~0~ does not represent a line, but the beginning of the buffer
  - only valid in some commands
: <cmd>   : uses default address
: n<cmd>  : uses address `n`

Commands often have default addresses if no address is given
- if not specified otherwise, the default is the current address
- when a file is first read, current address is the last line in buffer

Special address symbols:
| Symbol | Meaning                |
|--------+------------------------|
| ~.~      | current line in buffer |
| ~$~      | last line in buffer    |

*Address ranges* are 2 addresses separated by a ~,~ or ~;~ .
:  , <cmd>  : from first to last address (both incl.)
:  ; <cmd>  : from current to last address (both incl.)
:  ,m<cmd>  : from first to `m` address (both incl.)
:  ;m<cmd>  : from current to `m` address (both incl.)
: n, <cmd>  : same as just `n<cmd>`
: n; <cmd>  : same as just `n<cmd>`
: n,m<cmd>  : addresses from `n` to `m` (both incl.)
: n;m<cmd>  : same, but … (?)

*Regex patterns* can be given to find specific lines:
: /<re>/[I]  : next line containing pattern `re`
: ?<re>?[I]  : previous line containing pattern `re`
- ~/~ searches downwards from start of buffer to (if necessary) current line
- ~?~ searches upwards from end of buffer to (if necessary) current line
- ~I~ -> case-insensitive match
- can be repeated for next matches

**** Commands
General operations
: w [filename]  : write buffer to (a new / the loaded) file
: h     : show help (in case of `?`)
: H     : show help by default
: P     : show a prompt symbol (or use `-p` option)
: q     : exit the editor

Line Editing
: [.]a     : begin append new lines after (current) line (0-address valid)
: [.]i     : begin insert new lines before (current) line (0-addr. valid)
: [.,.]c   : begin change (current) line(s) (possibly add new ones after)
: [.,.]d   : delete (current) line(s)
: .        : end editing (return to prompt)
: <n>t<m>  : (?) copy from line `n` to line `m`
: <n>m<m>  : (?) move line `n` to line `m`
- ~a~, ~i~ and ~c~ put the editor in input mode, which can be exited via ~.~ cmd

Line Navigation
: [.,.]p   : print (current) line(s) (moves current line)
: [.,.]n   : same as `p`, but includes the line number
: <n>      : go to line number `n`
: -[n]     : jump to previous/`n` lines relative to current line
: +[n]     : jump to next/`n` lines relative to current line

Run unix shell commands by prepending a ~!~ :
: !date
: > Sat Mar  4 02:36:30 CET 2023
: !for s in hello world; do echo $s; done
: > hello
:   world
:   !

Opening an existing text file by specifying a ~filename~ argument appends
new lines to the file when insert mode is active.

**** Scripting
- use the ~-s~ flag to make it less verbose
- commands need to be separated by ~\n~ for new lines
- remember to add ~w~ command at the end to write to the file

For debugging:
- always add ~H~ at the beginning for debugging information
- make a dry run first by appending the command ~,p~ instead of ~w~ to see
  how the new text looks like

~ed~ can be piped through ~stdin~ (no need to exit with ~q~):
: $ echo '<ed commands>' | ed <file>

With Here-strings:
: $ ed <file> <<< '<ed commands>'

With Here-documents:
: $ ed <file> <<EOF
: <ed commands>
: EOF

**** Examples
: $ echo 'a\nHallo Welt\nNeue Zeile\n.\nw' | ed edtest.txt
: > t
:   0
:   22
: $ cat edtest.txt
: > Hallo Welt
:   Neue Zeile

**** More infos
Documentation:
- https://linux.die.net/man/1/ed
- https://www.gnu.org/software/ed/manual/ed_manual.html

Tutorials:
- https://www.howtoforge.com/linux-ed-command/
- https://wiki.bash-hackers.org/howto/edit-ed

** Numeric expressions
*** Calculate
**** Integer arithmetic
: $ expr <expression>
: $ echo $(( <expression> ))  : auto-escaped!
- expression symbols like ~*~ and ~**~ must be escaped with ~expr~
- uses signed integer math with a range according to the C ~intmax_t~ data type
- fractions will be truncated

Examples:
: $ expr 2 + 5
: > 7
: $ expr 13 - 9
: > 4
: $ expr 5 \* 3      : `*` needs to be escaped!
: $ echo $((5 * 3))  : no need to escape with shell arithmetic
: > 15
: $ expr 16 / 3
: > 5                : cuts off decimals
: $ echo $((5 ** 3))
: > 125
: $ echo $((5 % 3))  : modulus operator
: > 2

To store calculation results in variables:
: $ foo=$((3+9))
: $ echo $foo
: > 12

**** Decimal arithmetic (arbitrary precision)
: $ bc  : enters a REPL-like environment
: -i, --interactive  : force interactive mode
: -l, --mathlib      : uses extended math library
: -h, --help         : print usage
- ~bc~ stands for “bash calculator”
- always use ~-l~ flag to get full features
- the ~scale~ of an expression is the number of digits in the decimal part

Examples:
: $ bc -l
: >>> scale=2  : to set number of decimal places to 2
: >>> 22/7
: 3.14
: >>> scale=4
: >>> 22/7
: 3.1428
: >>> quit  : to exit the REPL

To directly input a sequence of commands without entering the REPL:
: $ echo "scale=2;22/7" | bc
: > 3.14

Concatenate single-number lines with ~+~ into an arithmetic sum expression
and evaluate it:
: $ seq 9 | paste -sd+ - | bc -l
: > 45

*** Convert from/to number bases
- ~ibase~: input base
- ~obase~: output base

MUST be ~obase~ first, because ~ibase~ changes the interpretation of the
following input numbers!
- see https://unix.stackexchange.com/a/199620

Input patterns:
: obase=[base]; [num]                : decimal -> obase
: ibase=[base]; [num]                : ibase -> decimal
: obase=[base]; ibase=[base]; [num]  : ibase -> obase

Examples:
: $ bc <<< "obase=2;ibase=16;F0F0"

*** Print sequence of numbers
~seq~ prints a sequence of numbers.
: $ seq <n>

** Clipboard

~pbcopy~ / ~pbpaste~ for macOS clipboard
- see https://gainsec.com/2022/02/17/terminal-to-clipboard/

Copy current path to clipboard:
: $ pwd | pbcopy

Paste/print from clipboard:
: $ pbpaste

** Date
Display current date/time:
: $ date

Display a calendar for current date:
: $ cal
: $ cal 07 2017  : for a specific month

** Execution time
Measure execution time:
: $ time <cmd>

** Disk space
Query disk space:
: $ df -h

** Images
*** Vector graphics
External tools:
- [[Inkscape]] can convert between vector formats
- [[epstopdf]] can convert ~eps~ to ~pdf~ files

** Scripting runtimes
External tools:
- [[Babashka]] as an interface between Clojure and the shell
- [[rlwrap]] is a wrapper for REPLs to navigate command history

** Mail

: $ mail         : check mails
: $ mail <user>  : send a mail to <user>

Mail CLI commands:
: ? list     : list all commands
: ? <n>      : mail with number [n]
: ? +        : next mail (or just press ENTER)
: ? -        : previous mail
: ? [r]eply  : reply to a mail
: ? [s]ave ?<msg-list> ?<filename>
:            : appends each message in turn to the end of the file
:            : - <msg-list> is the current message if not specified
:            : - <filename> is mbox if not specified
:            : - mail is NOT saved in mbox after saving it elsewhere
: ? [co]py ?<msg-list> ?<filename>
:            : same as `save` but does not mark the messages for
:            : deletion on quit
: ? [ho]ld ?<msg-list>
:            : marks each message to be saved in users system mailbox
:            : instead of mbox
:            : - does not override delete command
: ? e[x]it   : abort mail sessions without modifying users system mailbox
: ? [q]uit   : end mail session
:            : - examined messages go to mbox file unless deleted or
:            :   already saved in which case they are discarded
:            : - unexamined messages or those marked with `hold` or
:            :   `preserve` go back to the users system mailbox

Delete mails:
: ? d[elete]
: ? d <n>      : delete mail number [n]
: ? d <n> <m>  : delete mail [n] and [m]
: ? d <n>-<m>  : delete mails from [n] to [n]
: ? d *        : delete all mails
** Music
External tools:
- [[coltrane]]

* External applications
** tree
Command-line tool for tree-view of directory
- http://mama.indstate.edu/users/ice/tree/

: $ brew install tree

: $ tree <path>
: -L [num]  : restrict to max recursion depth [num]
: -a        : also hidden files
: -d        : only directories
: -f        : show full path
: -s        : add size information
: -P [ptn]  : list those that match the wild card [ptn]
: -I [ptn]  : do not list those that match the wild card [ptn]
- e.g. ~-I 'node_modules|lib'~ to ignore =node_modules= and =lib= directories

** rename
rename(1) multiple files at once
- https://stackoverflow.com/a/1086509/1204047

: $ brew install rename

Examples:

Substitute =.cljc= extension with =.clj= for all files beginning with ~"day"~:
: $ rename -s .cljc .clj day*

** Inkscape

CLI path:
=/Applications/Inkscape.app/Contents/Resources/bin/inkscape=
or:
=/usr/local/bin/inkscape=

SVG to PDF:
: $ inkscape mySVGinputFile.svg --export-area-drawing --batch-process --export-type=pdf --export-filename=output.pdf

** epstopdf

: $ epstopdf myEPSinputFile.eps

** thefuck
https://github.com/nvbn/thefuck

: $ brew install thefuck

** Babashka

Clojure for shell
- https://babashka.org
- https://github.com/babashka/babashka
- https://github.com/babashka/babashka/blob/master/examples/README.md
- https://book.babashka.org
- https://nextjournal.com/try/babashka

: $ bb
: -e <expr>  : evaluates an expression (default, option not needed)
: -f <path>  : evaluates a file
: -m <ns|var> : calls the `-main` function from a namespace
:             : or calls a fully qualified var
: -i  : bind *input* to a lazy seq of lines from stdin
: -I  : bind *input* to a lazy seq of EDN values from stdin
: -o  : write lines to stdout
: -O  : writes EDN values to stdout

To start a Babashka REPL:
: $ bb repl

Examples:

Evaluate an expression:
: $ bb -e '(+ 1 2)'

Bind input of ~ls~ to ~*input*~ in evaluation:
: $ ls | bb -i '(take 2 *input*)'

*** Libs
File system utilities: https://github.com/babashka/fs

** certbot

- https://certbot.eff.org
- https://www.howtoforge.com/how-to-manage-lets-encrypt-ssl-tls-certificates-with-certbot/
- https://wiki.ubuntuusers.de/certbot/

List certificates:
: $ certbot certificates

Create certificate(s) for domain(s):
: $ sudo certbot --nginx -d my-domain.de -d www.my-domain.de

If this doesn’t work:
: $ sudo certbot --authenticator webroot --installer nginx

** fswatch

file change monitor
- https://github.com/emcrisostomo/fswatch

: $ brew install fswatch

** rlwrap

Wrapper for REPL to get history (arrow up/down)

: $ brew install rlwrap

e.g. with CommonLisp:
: $ rlwrap ros run

** gnupg

GPG (GNU Privacy Guard) is a free open source version of PGP (Pretty Good Privacy) encryption software.
- https://blog.ghostinthemachines.com/2015/03/01/how-to-use-gpg-command-line/

: $ brew install gnupg

** ripgrep

- https://github.com/BurntSushi/ripgrep

: $ brew install ripgrep

: $ rg <pattern>    : fuzzy-search for a <pattern> in current directory
: -l                : list only filenames
: -i                : ignore case
: -., --hidden      : don’t ignore hidden files
: -C <n>            : adds `n` lines of context around the matching line
: -t <type>         : only files matching `type` (see `--type-list`)
: --type-list       : show all supported file types
: --files-without-match
:                   : print paths that contain zero matches and suppress match
: --no-require-git  : needs no git initialization to respect .gitignore rules
: --debug           : info for debugging
: --stats           : prints statistics about matches
- by default, skipps hidden files or directories
  - (might not always be true?)
- files whitelisted in ignore files will show up, even if they are hidden
  and the ~--hidden~ flag is not set

Respects =.gitignore= by default, IF git repo is initialized!

Examples:

Find ~"import requests"~ occurrences in Python files within the =~/scratch= dir
and add 5 lines of context around results:
: $ rg "import requests" -t py -C 5 ~/scratch

Find all (incl. hidden) shell files that don’t have a /shebang/:
: $ rg -u --files-without-match "^#\!" -t sh

** fzf
Fuzzy find (fzf)
- https://github.com/junegunn/fzf

: $ brew install fzf

: $ find <dir / *> -type f | fzf > selected
- type ~esc~ to stop

Examples:

To fuzzy-search in =foo.txt=:
: $ cat foo.txt | fzf

Takes any list from stdin:
: $ echo 'apple\nbanana\npeach\norange' | fzf

Type ~ctrl-r~ to fuzz-search the command history.

Type ~esc c~ (Mac) or ~alt-c~ to fuzzy-search and ~cd~ into directories.

To fuzzy-search from current directory and open in editor:
: $ nvim $(fzf)

To search all recently (last 24h) created files:
: $ find / -type f -ctime -1 -ls | fzf

More infos:
- https://andrew-quinn.me/fzf/

** shellcheck
Used to debug shell scripts.
- https://github.com/koalaman/shellcheck

: $ brew install shellcheck

** tldr
Community-created usage examples for common shell commands.
- https://tldr.sh

: $ brew install tldr
** fd
A simple, fast and user-friendly alternative to 'find'
- https://github.com/sharkdp/fd

: $ brew install fd
** journalctl
Log analyzer on Linux.
** ffmpeg
To encode and decode videos and (to some extend) images.
** convert
Image manipulation
** coltrane
https://github.com/pedrozath/coltrane

Utilities for music theory
: $ gem install coltrane

* Shell services
** Weather
: $ curl wttr.in/Mainz
