#+title: Docs/Uiua

- https://www.uiua.org
- https://github.com/uiua-lang/

Online REPL: https://www.uiua.org/pad

Docs: https://www.uiua.org/docs/
- [[https://www.uiua.org/docs/combinators][Combinators]]

/Array-oriented/ programming language with a /stack-based/ execution model and a
/flat array/ model.
- arrays must be rectangular and cannot have mixed types
- mixed or deep arrays can be emulated using [[Boxes]]
- array functions use the /Leading Axis/ model

Subscripts can be added to some functions/modifiers by typing ~,~ followed by the
subscript number.
- e.g. ~?,2~ results in ~?₂~

Editor support:
- Emacs: [[https://github.com/crmsnbleyd/uiua-mode][uiua-mode]]

Install the interpreter from the latest [[https://github.com/uiua-lang/uiua/releases][GitHub release]].

Extensions:
- [[https://github.com/uiua-lang/uiua-modules][Curated list of Uiua Modules]]

* Definitions
To assign a name to a value:
: x ← <v>
- names are case-sensitive, can only contain letters
- ~=~ will be converted to ~←~ by the formatter

~←~ pops the first thing off the stack and assigns it to the name on the left:
#+begin_src uiua
×2 [2 3 4]
x ←
x  #=> [4 6 8]
#+end_src

To assign a name to a function:
: x ← <f>
where ~f~ does not have enough arguments to run.

#+begin_src uiua
F ← +1
F5
#=> 6

👋 ← ⊂"Hello, "
👋"World"
#=> "Hello, World"
#+end_src

* Arrays
An array is a rectangular collection of elements arranged along some number of
axes. Nesting creates arrays of higher rank, not nested arrays (like in APL),
so all nested arrays must be of the same length.
- Uiua supports arrays with an arbitrary number of /axes/

/rows/ are the groups of elements along the /leading axis/ of an array.
- for /lists/, this is just individual elements
- in the /shape/ ~△~ of an array, the first element is the number of /rows/, which
  is also the /length/ ~⧻~ of the array

Arrays are /0-indexed/.

/Stack notation/:
: [1 2 3 4]

/Strand notation/:
: 1_2_3_4

#+begin_src uiua
[1_2_3 [4 5 6] 7_8_9]
# =>
╭─       
╷ 1 2 3  
  4 5 6  
  7 8 9  
        ╯
#+end_src

Arrays can have arbitrary code inside brackets, which is evaluated just like
any other code:
#+begin_src uiua
[×3. 4_5_6]
# =>
╭─          
╷ 12 15 18  
   4  5  6  
           ╯
#+end_src

For /pervasive functions/, the /shape/ of one array must be the /prefix/ of the
/shape/ of the other. So e.g. ~[2]~ and ~[2 3]~ are prefixes of ~[2 3 4]~, but ~[3 2]~
and ~[3]~ are not.

If shapes don’t match, a /fill item/ can be used with the /fill/ ~⬚~ modifier to
fill in the given value in missing places.

Example:
#+begin_src uiua
a ← ↯2_3 ⇡6
b ← ↯2_3_4 ⇡24
a b
### ╭─                         
### ╷ 0 1  2  3  12 13 14 15   
### ╷ 4 5  6  7  16 17 18 19   
###   8 9 10 11  20 21 22 23   
###                          ╯ 
### ╭─                         
### ╷ 0 1 2                    
###   3 4 5                    
###         ╯                  
+
## ╭─                           
## ╷  0  1  2  3  15 16 17 18   
## ╷  5  6  7  8  20 21 22 23   
##   10 11 12 13  25 26 27 28   
##                            ╯ 
#+end_src

Note: in APL, pervasive functions only apply between arrays of the same rank
or if one or both are scalar. For the example above one would have to use the
/rank/ operator: ~a (+⍤0 1) b~

Adding incompatible shapes using 100 as a /fill item/:
#+begin_src uiua
a ← ↯3_2 ⇡6
b ← ↯2_3_4 ⇡24
a b
### ╭─                         
### ╷ 0 1  2  3  12 13 14 15   
### ╷ 4 5  6  7  16 17 18 19   
###   8 9 10 11  20 21 22 23   
###                          ╯ 
### ╭─                         
### ╷ 0 1                      
###   2 3                      
###   4 5                      
###       ╯                    
⬚100+
## ╭─                                                    
## ╷   0   1   2   3   14  15  16  17  104 104 104 104   
## ╷   5   6   7   8   19  20  21  22  105 105 105 105   
##   108 109 110 111  120 121 122 123  200 200 200 200   
##                                                     ╯ 
#+end_src

* Boxes
Array elements with different shapes can be put into /boxes/ to emulate
nested/deep arrays:
: [□x □y …]

Instead of calling ~□~ on each item, the curly brace syntax automatically box
each item in the array:
: {x y …}

To /unbox/ the contents of a boxed array, use /un/ + /boxed/ ~°□~:
: °□boxed_x

/Pervasive functions/ work on /boxed/ elements without the need to /unbox/ them.

For other functions, the /inventory/ ~⍚~ modifier can be used to operate on
temporarily /unboxed/ values in /boxed/ arrays.

#+begin_src uiua
□42    # => □42

□[]     # => □[]
°□□[]  # => []
□1_2    # => □[1 2]
°□□1_2 # => [1 2]

[□1 □2_3_4 □5_6] # => [∙1│2 3 4│5 6]
{1 2_3_4 5_6}    # => [∙1│2 3 4│5 6]
#+end_src

Unbox

* Comments
A comment ~#~ with additional ~#~'s is an /output comment/. Each additional ~#~ prints
the next item from the top of the stack on /format/. This is useful for
debugging.

#+begin_src uiua
# Normal comments

1 2 # inline

# Output comments

1 2 3
####

+ 3 4 ##

# the formatter turns it into:
1 2 3
#### 3
#### 2
#### 1

+ 3 4 ## 12
#+end_src

* Constants
- ~η~ eta (pi/2; tau/4)
- ~π~ pi (2 eta; tau/2)
- ~τ~ tau (2 pi; 4 eta)
- ~∞~ infinity
- ~i~ imaginary number

* Functions
** Stack Functions
*** ~?~ stack [noa., 0-out] & ~ₙ~
Prints all stack values at insertion, without popping them.

With a /subscript/, will print only that number of values from the stack.

*** ~.~ duplicate [mon., 2-out]
Duplicates the top value on the stack.

Can be used to square a number, e.g. ~×.4~ results in ~16~.

*** ~∘~ identity [mon.] {id}
Does nothing with one value (monadic).

#+begin_src uiua
∘ 5
# =>
5
#+end_src

*** ~◌~ pop [mon., 0-out] {po} & ~°~
Discards the top stack value.

** Monadic Pervasive
*** ~¬~ not
Logical /not/ operation.
- equivalent to ~-⊙1~ → subtracts the number from 1

*** ~¯~ negate {neg}
Negates a number.
- like monadic ~-~ (negate) in APL
- backtick ~`~ will be converted to a /negate/ ~¯~ by the formatter
*** ~±~ sign {sig}
Returns the numeric sign (~1~, ~¯1~ or ~0~).

On a *complex number*, /normalizes/ it to magnitude 1.

On a *character*, gets its case:
- ~¯1~ for /lowercase/
- ~1~ for /uppercase/
- ~0~ for /caseless/

#+begin_src uiua
± "A new WORLD" ## [1 0 ¯1 ¯1 ¯1 0 1 1 1 1 1] 
#+end_src
*** ~⌵~ absolute value {abs}
Returns the /absolute value/ of the number.

With *complex numbers*, converts them to their /magnitude/.

With *characters*, /capitalizes/ them.
*** ~√~ sqrt {sqr}
Returns the /square root/ of the number.
- with a /subscript n/, returns the *nth root*
- ~√¯1~ = ~NaN~, but ~√ℂ0¯1~ = ~i~
*** ~ₑ~ exponential {exp} & ~°~ logarithm {log} & ~ₙ~
Returns the exponential /e^x/ for the number /x/:
: ₑ x
- set the base /b/ per /subscript/ to get /b^x/
  - same as ~ⁿ x b~

The /un/ ~°~ modifier returns the /natural logarithm/ instead:
: °ₑ x
- set the base /b/ per /subscript/ to get /log_b(x)/

*** ~∿~ sine {sin} & ~°~
Returns the /sine/ of the number.

~∿+η~ gets the /cosine/ instead.

~°∿~ gets the /arcsine/, ~˜-η°∿~ gets the /arccosine/.

Also see /un-atangent/ ~°∠~ to get both /sine/ and /cosine/ together. Note that
for ~η~, there are tiny differences between the two methods that may lead to
inconsistent results:
#+begin_src uiua
TrigA ← ⊂⊃∿ (∿+η) # sin cos
TrigA η ## [1 0.00…012246467991473532] 
TrigA π ## [0.00…012246467991473532 ¯1] 
TrigA τ ## [¯0.00…024492935982947064 1] 

TrigB ← ⊂°∠
TrigB η ## [1 0.00…06123233995736766] 
TrigB π ## [0.00…012246467991473532 ¯1] 
TrigB τ ## [¯0.00…024492935982947064 1] 

≍ ⊃TrigA TrigB η ## 0 
≍ ⊃TrigA TrigB π ## 1 
≍ ⊃TrigA TrigB τ ## 1 
#+end_src
*** ~⌊~ ~⌈~ ~⁅~ floor {flr}, ceil {cei}, round {rou} & ~ₙ~
Rounds to the nearest integer /(round)/: towards ~¯∞~ /(floor)/ or towards ~∞~
/(ceil)/.

/round/ with fraction ~0.5~ will round away from 0
- e.g. ~⁅2.5 = 3~ and ~⁅¯2.5 = ¯3~

/round/ with a /subscript/ rounds to that many decimal places.

** Dyadic Pervasive
*** ~+~ ~-~ add, subtract {sub}
*** ~×~ ~÷~ multiply {mul, ~*~} & ~°~, divide {div} & ~°~

Division by 0 results in infinity ~∞~.

*** ~ⁿ~ power {pow}
Raises the second value to the /power/ of the first.

/anti-backward-power/ (~⌝˜ⁿ)~ or /un-exponential/ (~°ₑ~) can be used to get the
*logarithm* of a number.

*** ~◿~ modulo {mod}
Returns the remainder of dividing the second by the first argument.

Use ~⍜⊙⌵◿~ to get /negative modulo/ instead of /remainder/:
#+begin_src uiua
x ← ˜-↻1⊂⟜⇡×2 .5
x
◿ 3 x
⍜⊙⌵◿ 3 x
# =>
[¯5 ¯4 ¯3 ¯2 ¯1 0 1 2 3 4 5]
[1 2 0 1 2 0 1 2 0 1 2]
[¯2 ¯1 ¯0 ¯2 ¯1 0 1 2 0 1 2]
#+end_src
*** ~∠~ atangent {ata} & ~°~
Returns the /arctangent/ of two numbers.

The /inverse/ ~°∠~ puts both, the /cosine/ and /sine/ (in that order) of the input
angle onto the stack. Therefore, ~˜÷°∠~ gets the /tangent/ of the angle.

#+begin_src uiua
a ← ⊞˜∠ ⇌.[¯ 1 0 1]
a # angle
## ╭─
## ╷  3τ/8  η  τ/8
##       π  0    0
##   ¯3τ/8 ¯η ¯τ/8
##                 ╯
∩⁅₂ °∠ a # cos(a) | sin(a)
### ╭─
### ╷ ¯0.71 0 0.71
###   ¯1    1 1
###   ¯0.71 0 0.71
###                ╯
### ╭─
### ╷  0.71  1  0.71
###    0     0  0
###   ¯0.71 ¯1 ¯0.71
###                  ╯
⁅₂ ˜÷°∠ a # tan(a)
## ╭─
## ╷ ¯1  16331239353195368  1
##   ¯0                  0  0
##    1 ¯16331239353195368 ¯1
##                            ╯
#+end_src
*** ~=~ ~≠~ equals {eq}, not equals {~!=~ / ne / neq}
Compare for equality/inequality.
- Uiua has no boolean type. Comparison operators return ~0~ for /false/ and ~1~
  for /true/.

*** ~<~ ~>~ less than {lt}, greater than {gt}
Compares for less/greater than.
- ~< x y~ means ~y < x~
- ~> x y~ means ~y > x~

*** ~≤~ ~≥~ less or equal {~<=~ / le / leq}, greater or equal {~>=~ / ge / geq}
Compares for less/greater than or equal.
- ~≤ x y~ means ~y ≤ x~
- ~≥ x y~ means ~y ≥ x~

*** ~↥ ↧~ maximum {max}, minimum {min}
Takes the max./min. of two arrays.
- like dyadic ~⌈~ (maximum) / ~⌊~ (minimum) in APL
*** ~ℂ~ complex {com} & ~°~
Creates a complex number from an /imaginary/ and a /real/ part on the stack.
- stack order: 1. /imaginary/ 2. /real/
- equivalent to ~+×i~

/un-complex/ ~°ℂ~ pushes the /imaginary/ and /real/ parts back on the stack (in
the same order as the input to /complex/).

#+begin_src uiua
ℂ 3 5 ## 5+3i
[°ℂ] i ## [1 0]
= 5 ℂ0 5 ## 1
#+end_src

See also:
- /absolute value/ ~⌵~ → get the magnitude
- /sign/ ~±~ → normalize to magnitude 1

** Monadic Array
*** ~⧻~ length {len} & ~(°⊸)ₙ~
Returns the number of items along the first axis of the array.
- like monadic ~≢~ (tally) in APL

*** ~△~ shape {sha} & ~°ₙ⍜~
Returns the dimensions of the array.
- like monadic ~⍴~ (shape) in APL

#+begin_src uiua
△5               #=> []
△[]              #=> [0]
△[9 1 6]         #=> [3]
△[4_π_9 1_5_∞]   #=> [2 3]
△[[1_2_3 3_4_5]] #=> [1 2 3]
#+end_src

/un-shape/ ~°△~ takes a /shape/ as input and returns an array of that shape.

#+begin_src uiua
°△ 2_3_4
## ╭─                         
## ╷ 0 1  2  3  12 13 14 15   
## ╷ 4 5  6  7  16 17 18 19   
##   8 9 10 11  20 21 22 23   
##                          ╯ 
#+end_src

*** ~♭~ deshape {flat / des}
Flattens the array to /rank 1/.
- like monadic ~,~ (ravel) in APL

With a /subscript/, flattens it to /rank n/.
- /negative subscripts/ flatten to rank /m-n/ (relative to rank /m/ of the arr.)
- if the subscript rank is greater than the rank of the array, /length-1/
  axes are added to the front of the shape
- if the subscript is 0, returns the first scalar in the array

#+begin_src uiua
△ ♭ °△2_3_4_5  ## [120] 
△ ♭₂ °△2_3_4_5 ## [24 5] 
△ ♭₃ °△2_3_4_5 ## [6 4 5]

△ ♭₋₁ °△2_3_4_5 ## [6 4 5] 
△ ♭₋₂ °△2_3_4_5 ## [24 5] 
△ ♭₋₃ °△2_3_4_5 ## [120] 
#+end_src

*** ~⊢~ ~⊣~ first {fir} & ~⍜ₙ~, last {las} & ~⍜ₙ~
Returns the first/last /row/ (first axis) of an array.
- like dyadic ~1↑~ / ~¯1↑~ (take) in APL

*** ~⇌~ reverse {rev}
Reverses the array along the first axis.
- like monadic ~⊖~ (reverse first) in APL
- ~≡⇌~ behaves like monadic ~⌽~ (reverse) in APL
  
*** ~⍉~ transpose {tra} & ~°~
Transposes/rotates the axes of the array.
- like ~⍉~ in APL

*** ~□~ box & ~°(⍜°)ₙ~
See [[Boxes]].

*** ~⋯~ bits & ~°⍜ₙ~
Encode a number/array as bits (LSB-first).
- “LBS” means /least significant bit/
- always results in an array 1 rank higher than the input
- with /subscript/, forces the number of bits to be used (extends or
  truncates the bits)

/un-bits/ ~°⋯~ decodes bits back to numbers.

*Warning:* conversion (~⋯~ / ~°⋯~) on large numbers (> 53 bits long) may give
incorrect results due to floating point imprecision.

/under-bits/ ~⍜⋯~ performs /bit-wise operations/.

** Dyadic Array
*** ~↯~ reshape {res} & ~⬚~
Reshape the array to fit the given shape.
- like ~⍴~ (reshape) in APL
- repeats elements when overcounting the input array (like in APL)

*** ~↙~ ~↘~ take {tak} & ~⬚(°⬚)~, drop {dro} & ~⬚⌝~
Takes/drops /n/ elements along the first axis of the array.
- like dyadic ~↑~ (take) / ~↓~ (drop) in APL

/antidrop/ pads an array with fill elements.

*** ~⊏~ select {sel} & ~⬚°⍜⌝~
Selects items from an array using an index vector.

#+begin_src uiua
⊏ [1 2 5] "abcdef" #=> "bcf"
⬚@-⌝⊏ [1 2 5] "bcf" #=> "-bc--f"
#+end_src

*** ~▽~ keep {kee} & ~⊸⬚°ₙ⍜⌝~
Discards or copies items in an array:
: ▽ <mask> <arr>
- like dyadic /replicate first/ ~⌿~ in APL

Example:
#+begin_src uiua
▽ [0 1 0 1] [1_2 3_4 5_6 7_8]
#=>
╭─     
╷ 3 4  
  7 8  
      ╯
#+end_src

~⍜▽~ modifies part of an array according to a mask:
: ⍜▽<f> <mask> <arr>

Example:
#+begin_src uiua
⍜▽(×.) [0 1 1 0 1] [1 2 3 4 5]
#=>
[1 4 9 4 25]
#+end_src

*** ~⊂~ join {joi} & ~⬚°ₙ~
Concatenates two arrays/scalars.
- like dyadic ~⍪~ (catenate first) in APL
- ~≡⊂~ behaves like dyadic ~,~ (catenate) in APL

*** ~⊟~ couple {cou} & ~⬚°ₙ~
Combine two arrays as /rows/ of a new array (increases the rank).

The *inverse* ~°⊟~ separates combined arrays.

Use /fill/ ~⬚~ if shapes don’t match:
#+begin_src uiua
⬚@ ⊟ "Apple" "Pie"
## ╭─          
## ╷ "Apple"   
##   "Pie  "   
##           ╯ 
#+end_src

** Misc
*** ~&ims~ image - show
Shows an image, depending on the system backend.

*Note:* In the (Ghostty) terminal, the image does not always shows up with
lower row/column lengths (bug?).
- better use /window mode/ ~-w~ for graphic output
*** ~&gifs~ gif - show
*** ~&ap~ audio - play
*** ~&s~ show
Prints a nicely formatted representation of a value to stdout.

Array axes are layed out in an alternating horizontal→vertical→… pattern.
The elements of the last axis are always layed out horizontally
(column-wise), the ones on the next axis vertically (row-wise), for the
next axis it is horizontally again, etc.
- this is different to APL, where every axis before the last one is layed
  out vertically in rows

*** ~&p~ print with newline
Print a value to stdout followed by a newline.
* Modifiers (→Operators)
** Stack Modifiers
*** ~˜~ backward [mon.] {bac}
Swaps the arguments of a dyadic function.
- like monadic operator ~⍨~ (commute) in APL

: ˜ -3 10  =  -10 3  =  -7

*** ~⊃~ fork [dya.] {for}
Calls two functions on the same values and puts both outputs on the stack.
- the functions can be of any arity

#+begin_src uiua
⊃⇌⧻ 1_2_3_4
# =>
4
[4 3 2 1]

⊃↧↥ ⇡4 ⇌⇡4
# =>
[3 2 2 3]
[0 1 1 0]
#+end_src

*** ~∩~ both [mon.] {bot} & ~ₙ~
Calls the /n/-ary function on two sequences of the next top /n/ values on the
stack.
- just the top 2 values in case of a unary function
- for a dyadic function ~f~ on ~a b c d~, calls ~f a b~ and ~f c d~

#+begin_src uiua
∩⇡ 4 6
# =>
[0 1 2 3 4 5]
[0 1 2 3]

∩+ 1 2 3 4
# =>
7
3
#+end_src

*** ~⊙~ dip [mon.]
Temporarily pops the top value off the stack and calls the function.
- stacking multiple /dips/ enables operating on lower stack values without
  touching the top ones

#+begin_src uiua
⊙+ 1 2 3 4
# =>
4
5
1

[⊙⊙+ 1 2 3 4]
# =>
[1 2 7]

⊙(/↥) 1_2_3 4_5_6
# =>
6
[1 2 3]
#+end_src

Combines well with /fork/ ~⊃~ to keep values on the stack after/before
operating on them:
- use /gap/ ~⋅~ to drop subsequent stack values
#+begin_src uiua
[⊃⊙⊙∘(++) 3 5 10]
# =>
[3 5 10 18]

[⊃⊙⋅∘(++) 3 5 10]
# =>
[3 10 18]
#+end_src

*** ~⋅~ gap [mon.]
Discards the top stack value before calling the function.
- also see the function /pop/ ~◌~

#+begin_src uiua
⋅+ 3 5 10
# =>
15
#+end_src

*** ~˙~ self [mon.] {slf}
Calls a function with the same array as all arguments.

#+begin_src uiua
˙+ 5
# =>
10

˙⊞+ 1_2_3
# =>
╭─       
╷ 2 3 4  
  3 4 5  
  4 5 6  
        ╯
#+end_src

** Iterating Modifiers
*** ~≡~ rows {row}
Applies the function to each /row/ of the array(s).
: ≡<f> <arr …>

*** ~⊞~ table {tab}
Applies ~f~ on all combinations of rows from arrays ~a~ and ~b~:
: ⊞<f> <a> <b>
- there seems to be no analog in APL, /outer product/ only works scalar-wise

#+begin_src uiua
⊞(⊂⇌) [1_2 3_4] [5 6 7]
#=>
╭─              
╷ 2 1 5  4 3 5  
╷ 2 1 6  4 3 6  
  2 1 7  4 3 7  
               ╯
#+end_src
*** ~⍚~ inventory
Applies the function to each /unboxed/ row of an array and re-/boxes/ the
result.
: ⍚<f>

** Aggregating Modifiers
*** ~/~ reduce {red}
Applies reducing function ~f~ to the array (“between” its items):
: /<f> <arr>
- reduces along the /first/ axis (across columns in a matrix)
- like monadic op. ~⌿~ (reduce first) in APL

** Inversion Modifiers
*** ~°~ un
Inverts the behaviour of a function.
- e.g. for unboxing: ~°□~

*** ~⌝~ anti
Inverts the behaviour of a function, treating its first argument as a
constant(?)

*** ~⍜~ under
Operates (~g~) on a transformed (~f~) array, then reverses the transformation.
: ⍜<f><g>
- more powerful version of /un/ ~°~

** Other Modifiers
*** ~⬚~ fill {fil}
Fill missing values of an array that has mismatched shapes with ~fill-value~
so it becomes a valid array:
: ⬚<fill-value> <arr/f>
- partially like monadic ~↑~ (mix) in APL, but not with nested arrays and with
  function argument

#+begin_src uiua
⬚0[1 2_3_4 5_6]
#=>
╭─       
╷ 1 0 0  
  2 3 4  
  5 6 0  
        ╯

⬚π↙ 5 [1 2 3]
#=>
[1 2 3 π π]
#+end_src
