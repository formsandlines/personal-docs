#+title: Docs/Uiua

- https://www.uiua.org
- https://github.com/uiua-lang/

Online REPL: https://www.uiua.org/pad

Docs: https://www.uiua.org/docs/
- [[https://www.uiua.org/docs/combinators][Combinators]]

/Array-oriented/ programming language with a /stack-based/ execution model and a
/flat array/ model.
- arrays must be rectangular and cannot have mixed types
- mixed or deep arrays can be emulated using [[Boxes]]
- array functions use the /Leading Axis/ model

Subscripts can be added to some functions/modifiers by typing ~,~ followed by the
subscript number.
- e.g. ~?,2~ results in ~?â‚‚~

Editor support:
- Emacs: [[https://github.com/crmsnbleyd/uiua-mode][uiua-mode]]

Install the interpreter from the latest [[https://github.com/uiua-lang/uiua/releases][GitHub release]].

Extensions:
- [[https://github.com/uiua-lang/uiua-modules][Curated list of Uiua Modules]]

* Bindings
/Bindings/ are global names that can be assigned to values:
: x â† <v>
- binding names are /case-sensitive/, they can only contain letters
- no numbers or underscores are allowed, but /subscript/ numbers at the end of
  the name (e.g. ~Foo,123~ / ~Fooâ‚â‚‚â‚ƒ~) are possible
- to indicate related bindings, names can end with multiple ~â€²~ characters
  (typed with apostrophe ~'~)
- it is recommended to use /PascalCase/ for binding names with 2+ characters to
  avoid name clashes with built-in functions and their abbreviations
- ~=~ will be converted to ~â†~ by the formatter

~â†~ pops the first thing off the stack and assigns it to the name on the left,
therefore it can also bind to values on previous lines:
#+begin_src uiua
Ã—2 [2 3 4]
x â†
x  #=> [4 6 8]
#+end_src

Bindings can only bind a single value once for the entire lifetime of the
program. However, a name can be bound to another value/function:
#+begin_src uiua
X â† 42
X ## 42 
X â† @a
X ## @a 
#+end_src

But names cannot refer back to their previous values (which will be
interpreted as a recursive function):
#+begin_src uiua
X â† 12
X ## "3:1: Recursive function `X` must have a signature declared after the â†." 
X â† Ã—2 X
X
#+end_src


Functions can also be bound to names. If the right side of ~â†~ requires more
than 0 values to be on the stack, it doesnâ€™t get evaluated right away but will
instead be bound as a function:
: x â† <f>
- to create a 0-arity function, sorround the right side with ~()~

#+begin_src uiua
F â† +1
F5 ## 6

ğŸ‘‹ â† âŠ‚"Hello, "
ğŸ‘‹"World"
## "Hello, World"

F â† âš‚ # a value, not a function!
F ## 0.8136374781735876 
F ## 0.8136374781735876 

Fâ€² â† (âš‚) # 0-arity function
Fâ€² ## 0.8018080663476463 
Fâ€² ## 0.5432016624161957 
#+end_src

* Inline Functions
/Inline functions/ are defined in parentheses and are evaluated like any other
expression after being applied to their arguments. They can be broken up into
multiple lines, running from top to bottom:
#+begin_src uiua
âŠ¸â‰¡(+âŠ¸â‡Œ) [2_5_3 0_2_1 0_0_2]

X â† (
  Ë™âŠ=â‡¡ # First this line runs
  â†¥âŠ¸â‡Œ  # Then this one
)
#+end_src

* Arrays
An array is a rectangular collection of elements arranged along some number of
axes. Nesting creates arrays of higher rank, not nested arrays (like in APL),
so all nested arrays must be of the same length.
- Uiua supports arrays with an arbitrary number of /axes/

/rows/ are the groups of elements along the /leading axis/ of an array.
- for /lists/, this is just individual elements
- in the /shape/ ~â–³~ of an array, the first element is the number of /rows/, which
  is also the /length/ ~â§»~ of the array

Arrays are /0-indexed/.

/Stack notation/:
: [1 2 3 4]

/Strand notation/:
: 1_2_3_4

#+begin_src uiua
[1_2_3 [4 5 6] 7_8_9]
# =>
â•­â”€       
â•· 1 2 3  
  4 5 6  
  7 8 9  
        â•¯
#+end_src

Arrays can have arbitrary code inside brackets, which is evaluated just like
any other code:
#+begin_src uiua
[Ã—3. 4_5_6]
# =>
â•­â”€          
â•· 12 15 18  
   4  5  6  
           â•¯
#+end_src

For /pervasive functions/, the /shape/ of one array must be the /prefix/ of the
/shape/ of the other. So e.g. ~[2]~ and ~[2 3]~ are prefixes of ~[2 3 4]~, but ~[3 2]~
and ~[3]~ are not.

If shapes donâ€™t match, a /fill item/ can be used with the /fill/ ~â¬š~ modifier to
fill in the given value in missing places.

Example:
#+begin_src uiua
a â† â†¯2_3 â‡¡6
b â† â†¯2_3_4 â‡¡24
a b
### â•­â”€                         
### â•· 0 1  2  3  12 13 14 15   
### â•· 4 5  6  7  16 17 18 19   
###   8 9 10 11  20 21 22 23   
###                          â•¯ 
### â•­â”€                         
### â•· 0 1 2                    
###   3 4 5                    
###         â•¯                  
+
## â•­â”€                           
## â•·  0  1  2  3  15 16 17 18   
## â•·  5  6  7  8  20 21 22 23   
##   10 11 12 13  25 26 27 28   
##                            â•¯ 
#+end_src

Note: in APL, pervasive functions only apply between arrays of the same rank
or if one or both are scalar. For the example above one would have to use the
/rank/ operator: ~a (+â¤0 1) b~

Adding incompatible shapes using 100 as a /fill item/:
#+begin_src uiua
a â† â†¯3_2 â‡¡6
b â† â†¯2_3_4 â‡¡24
a b
### â•­â”€                         
### â•· 0 1  2  3  12 13 14 15   
### â•· 4 5  6  7  16 17 18 19   
###   8 9 10 11  20 21 22 23   
###                          â•¯ 
### â•­â”€                         
### â•· 0 1                      
###   2 3                      
###   4 5                      
###       â•¯                    
â¬š100+
## â•­â”€                                                    
## â•·   0   1   2   3   14  15  16  17  104 104 104 104   
## â•·   5   6   7   8   19  20  21  22  105 105 105 105   
##   108 109 110 111  120 121 122 123  200 200 200 200   
##                                                     â•¯ 
#+end_src

* Array Boxing
Array elements with different shapes can be put into /boxes/ to emulate
nested/deep arrays:
: [â–¡xs â–¡ys â–¡z â€¦]

In the output, the elements of the boxed arrays are separated by ~|~:
: [x1 x2â€¦|y1 y2â€¦|âˆ™z|â€¦]
- scalars are marked with a ~âˆ™~ to be distinguished from single-row lists

Instead of calling ~â–¡~ on each item, the curly brace syntax automatically box
each item in the array:
: {x y â€¦}

To /unbox/ the contents of a boxed array, use /un/ + /boxed/ ~Â°â–¡~:
: Â°â–¡boxed_x

#+begin_src uiua
â–¡42 ## â–¡42 

â–¡[]    ## â–¡[] 
Â°â–¡â–¡[]  ## [] 
â–¡1_2   ## â–¡[1 2] 
Â°â–¡â–¡1_2 ## [1 2] 

[â–¡1 â–¡2_3_4 â–¡5_6] ## [âˆ™1â”‚2 3 4â”‚5 6] 
{1 2_3_4 5_6}    ## [âˆ™1â”‚2 3 4â”‚5 6] 
#+end_src

/Pervasive functions/ work on /boxed/ elements without the need to /unbox/ them.
They preserve the maximum /box depth/ of their arguments:
#+begin_src uiua
+1 4    ## 5 
+1 â–¡4   ## â–¡5 
+1 â–¡â–¡4  ## â–¡â–¡5 
+â–¡â–¡1 â–¡4 ## â–¡â–¡5 

Ã—10 {1_2_3 4_5 6} ## [10 20 30â”‚40 50â”‚âˆ™60]
#+end_src

As an exception, /comparison functions/ lexicographically compare boxed arrays
as a whole:
#+begin_src uiua
= [1 2 3] [1 2 5]   ## [1 1 0] 
= â–¡[1 2 3] â–¡[1 2 5] ## 0 
= â–¡[1 2 3] â–¡[1 2 3] ## 1 
#+end_src

For /non-pervasive/ functions, the arguments often have to be /unboxed/. The
/inventory/ ~âš~ modifier can be used to operate on temporarily /unboxed/ values.

Unboxing each boxed element in an array generally requires a way to homogenize
the elements so that the array can stay rectangular and flat.

The /content/ ~â—‡~ modifier takes a function and calls it on the unboxed arguments.
It can be combined with /reduce/ ~/~ to join all elements into a normal array:
#+begin_src uiua
/â—‡âŠ‚{@a @b @c} ## "abc" 
/â—‡âŠ‚{1 2 3} ## [1 2 3] 
#+end_src

To decompose a list of boxed elements into individual stack items, /un-box/ ~Â°â–¡~
can be /subscripted/ with the exact number of elements in the list, which will
then appear one-by-one on the stack:
#+begin_src uiua
Â°â–¡â‚ƒ {@a @b @c}
#### @c 
#### @b 
#### @a 
#+end_src

* Types
There are four types of arrays:
- Number
  - IEEE-754 double-precision floating-point format
  - can be written as integers, with decimals, as fractions (e.g. ~3Ï€/2~)
  - scientific notation (e.g. ~6e3~ = ~6000~) is supported
  - can contain numeric constants like ~Ï€~, ~Ï„~, ~Î·~, ~e~, and ~âˆ~
- Complex
  - printed like ~5+3i~
  - can be written as literals by suffixing the real part with ~r~ and/or the
    imaginary part with ~i~ (e.g. ~5r3i~)
  - support the same math operations as normal numbers
- Character
  - represented as 32-bit Unicode codepoints
  - character literals marked with ~@~ denote rank-0 (scalar) char arrays
  - string literals delimited by ~"â€¦"~ denote rank-1 char arrays (strings)
  - some chars must be escaped, e.g. newline ~@\r~, null ~@\0~, but not space
  - /raw string literals/ marked with ~$~ (followed by a space) need no escaping
    - the string runs to the end of the line
    - if the next line is another raw string literal, a newline gets inserted
  - chars can also be specified with 2 (e.g. ~@\x41~) or 4 (e.g. ~@\u2665~) hex
    digits by using escape codes
    - longer/shorter sequences must be wrapped in ~{â€¦}~ (e.g. ~@\u{1f600}~)
    - escape sequences do not work in /raw strings/
  - ~&p~ can be used for pretty-printing
- Box

The ~type~ function gets the /type/ of an array on the stack, encoded as an
integer:
- ~0~: real numbers
- ~1~: characters
- ~2~: boxes
- ~3~: complex numbers

#+begin_src uiua
type [1 2]   ## 0 
type "ab"    ## 1 
type {@a @b} ## 2 
type [i 2r1] ## 3 
#+end_src

An empty array always has the /shape/ ~[0].~ It can have different types:
#+begin_src uiua
type [] ## 0 
type "" ## 1 
type {} ## 2 
#+end_src

/Format strings/ are created by prefixing a string with ~$~. It is a special kind
of function that takes an argument for each ~_~ in the string and replaces it
with the stringified version.
- a ~_~ can be inserted by escaping it with ~/_~
- /raw strings/ can be turned into format strings with an additional ~$~.
- being functions, format strings can be used with modifiers like /reduce/

#+begin_src uiua
Oracle â† $"The meaning of _ is _!"
Oracle "life" 42
## "The meaning of life is 42!" 
Oracle @Ï€ Ï€
## "The meaning of Ï€ is 3.141592653589793!"

3 2 1
$$ Explosion in _,
$$ _,
$$ _â€¦
$$ BOOM!
## "Explosion in 3,\n2,\n1â€¦\nBOOM!"

/$"_ _" {"Separated" "by" "spaces"}
## "Separated by spaces" 
#+end_src

Characters and numbers exist in an /affine space/ (like in BQN):
- ~+n c~ / ~+c n~ returns another character
- ~-n c~ returns another character
- ~-c c~ returns a number
- ~Ã—n c~ / ~Ã—c n~ or ~Ã·n c~ toggles the case of some characters, if ~n~ is negative
  - see /sign/ ~Â±~ to /get the case/ of a character as a number
  - see /negate/ ~Â¯~ to /toggle the case/ of a character
  - see /absolute value/ ~âŒµ~ to /uppercase/ (/lowercase/ with  ~Â¯âŒµ~) a character
- no other dyadic arithmetic operations are possible with characters

* Signatures
[[Bindings]] and [[Inline Functions]] can have a /signature/ declared like:
: â€¦ = |<input #>.<output #> â€¦  <- for bindings
: (|<input #>.<output #> â€¦)    <- for inline functions
- e.g. ~|2.1~ means the function takes 2 arguments and returns one
- the second number is optional and defaults to 1 if not given

A /declared/ signature always overrides the /inferred/ signature. If they donâ€™t
match, there will be a warning.

* Modules

Import a function from a local module:
: ~ "<filename>" ~ <fn-name>
and call it like this:
: <fn-name> â€¦

Import the local module as a namespace, using an alias:
: <alias> ~ "<filename>"
and call a function from it like this:
: <alias>~<fn-name>

* Comments
A comment ~#~ with additional ~#~'s is an /output comment/. Each additional ~#~ prints
the next item from the top of the stack on /format/. This is useful for
debugging.

#+begin_src uiua
# Normal comments

1 2 # inline

# Output comments

1 2 3
####

+ 3 4 ##

# the formatter turns it into:
1 2 3
#### 3
#### 2
#### 1

+ 3 4 ## 12
#+end_src

Output comments inside [[Inline Functions][inline functions]] will show the values for each time the
function is called.
#+begin_src uiua
F â† (
  ## 5 6
  + 1 ## 6 7 
)
F 5
F 6

#+end_src

* Constants
- ~Î·~ eta (pi/2; tau/4)
- ~Ï€~ pi (2 eta; tau/2)
- ~Ï„~ tau (2 pi; 4 eta)
- ~âˆ~ infinity
- ~i~ imaginary number

* Functions
** Stack Functions
*** ~?~ stack [noa., 0-out] & ~â‚™~
Prints all stack values at insertion, without popping them.

With a /subscript/, will print only that number of values from the stack.

*** ~âˆ˜~ identity [mon.] {id / i(â†’planet)}
Does nothing with one value (monadic).

#+begin_src uiua
âˆ˜ 5
# =>
5
#+end_src

*** ~â—Œ~ pop [mon., 0-out] {po / p(â†’planet)} & ~Â°~
Discards the top stack value.

** Monadic Pervasive
*** ~Â¬~ not
Logical /not/ operation.
- equivalent to ~-âŠ™1~ â†’ subtracts the number from 1

*** ~Â¯~ negate {neg}
Negates a number.
- like monadic ~-~ (negate) in APL
- backtick ~`~ will be converted to a /negate/ ~Â¯~ by the formatter
*** ~Â±~ sign {sig / sgn}
Returns the numeric sign (~1~, ~Â¯1~ or ~0~).

On a *complex number*, /normalizes/ it to magnitude 1.

On a *character*, gets its case:
- ~Â¯1~ for /lowercase/
- ~1~ for /uppercase/
- ~0~ for /caseless/

#+begin_src uiua
Â± "A new WORLD" ## [1 0 Â¯1 Â¯1 Â¯1 0 1 1 1 1 1] 
#+end_src
*** ~âŒµ~ absolute value {abs}
Returns the /absolute value/ of the number.

With *complex numbers*, converts them to their /magnitude/.

With *characters*, /capitalizes/ them.
*** ~âˆš~ sqrt {sqr}
Returns the /square root/ of the number.
- with a /subscript n/, returns the *nth root*
- ~âˆšÂ¯1~ = ~NaN~, but ~âˆšâ„‚0Â¯1~ = ~i~
*** ~â‚‘~ exponential {exp} & ~Â°~ logarithm {log} & ~â‚™~
Returns the exponential /e^x/ for the number /x/:
: â‚‘ x
- set the base /b/ per /subscript/ to get /b^x/
  - same as ~â¿ x b~

The /un/ ~Â°~ modifier returns the /natural logarithm/ instead:
: Â°â‚‘ x
- set the base /b/ per /subscript/ to get /log_b(x)/

*** ~âˆ¿~ sine {sin} & ~Â°~
Returns the /sine/ of the number.

~âˆ¿+Î·~ gets the /cosine/ instead.

~Â°âˆ¿~ gets the /arcsine/, ~Ëœ-Î·Â°âˆ¿~ gets the /arccosine/.

Also see /un-atangent/ ~Â°âˆ ~ to get both /sine/ and /cosine/ together. Note that
for ~Î·~, there are tiny differences between the two methods that may lead to
inconsistent results:
#+begin_src uiua
TrigA â† âŠ‚âŠƒâˆ¿ (âˆ¿+Î·) # sin cos
TrigA Î· ## [1 0.00â€¦012246467991473532] 
TrigA Ï€ ## [0.00â€¦012246467991473532 Â¯1] 
TrigA Ï„ ## [Â¯0.00â€¦024492935982947064 1] 

TrigB â† âŠ‚Â°âˆ 
TrigB Î· ## [1 0.00â€¦06123233995736766] 
TrigB Ï€ ## [0.00â€¦012246467991473532 Â¯1] 
TrigB Ï„ ## [Â¯0.00â€¦024492935982947064 1] 

â‰ âŠƒTrigA TrigB Î· ## 0 
â‰ âŠƒTrigA TrigB Ï€ ## 1 
â‰ âŠƒTrigA TrigB Ï„ ## 1 
#+end_src
*** ~âŒŠ~ ~âŒˆ~ ~â…~ floor {flr}, ceil {cei}, round {rou} & ~â‚™~
Rounds to the nearest integer /(round)/: towards ~Â¯âˆ~ /(floor)/ or towards ~âˆ~
/(ceil)/.

/round/ with fraction ~0.5~ will round away from 0
- e.g. ~â…2.5 = 3~ and ~â…Â¯2.5 = Â¯3~

/round/ with a /subscript/ rounds to that many decimal places.

** Dyadic Pervasive
*** ~+~ ~-~ add, subtract {sub}
Adds/subtracts two values.

/un-add/ ~Â°+~ splits a number into fractional and integer parts:
#+begin_src uiua
[Â°+ 1/3]   ## [0.333â€¦ 0] 
[Â°+ 3/2]   ## [0.5 1] 
[Â°+ 2.5]   ## [0.5 2] 
[Â°+ Â¯5.25] ## [0.75 Â¯6] 
#+end_src

*** ~Ã—~ ~Ã·~ multiply {mul, ~*~} & ~âœÂ°~, divide {div} & ~Â°~

Division by 0 results in infinity ~âˆ~.

*** ~â¿~ power {pow}
Raises the second value to the /power/ of the first.

/anti-backward-power/ (~âŒËœâ¿)~ or /un-exponential/ (~Â°â‚‘~) can be used to get the
*logarithm* of a number.

*** ~â—¿~ modulo {mod}
Returns the remainder of dividing the second by the first argument.

Use ~âœâŠ™âŒµâ—¿~ to get /negative modulo/ instead of /remainder/:
#+begin_src uiua
x â† Ëœ-â†»1âŠ‚âŸœâ‡¡Ã—2 .5
x
â—¿ 3 x
âœâŠ™âŒµâ—¿ 3 x
# =>
[Â¯5 Â¯4 Â¯3 Â¯2 Â¯1 0 1 2 3 4 5]
[1 2 0 1 2 0 1 2 0 1 2]
[Â¯2 Â¯1 Â¯0 Â¯2 Â¯1 0 1 2 0 1 2]
#+end_src
*** ~âˆ ~ atangent {ata} & ~Â°~
Returns the /arctangent/ of two numbers.

The /inverse/ ~Â°âˆ ~ puts both, the /cosine/ and /sine/ (in that order) of the input
angle onto the stack. Therefore, ~ËœÃ·Â°âˆ ~ gets the /tangent/ of the angle.

#+begin_src uiua
a â† âŠËœâˆ  â‡Œ.[Â¯ 1 0 1]
a # angle
## â•­â”€
## â•·  3Ï„/8  Î·  Ï„/8
##       Ï€  0    0
##   Â¯3Ï„/8 Â¯Î· Â¯Ï„/8
##                 â•¯
âˆ©â…â‚‚ Â°âˆ  a # cos(a) | sin(a)
### â•­â”€
### â•· Â¯0.71 0 0.71
###   Â¯1    1 1
###   Â¯0.71 0 0.71
###                â•¯
### â•­â”€
### â•·  0.71  1  0.71
###    0     0  0
###   Â¯0.71 Â¯1 Â¯0.71
###                  â•¯
â…â‚‚ ËœÃ·Â°âˆ  a # tan(a)
## â•­â”€
## â•· Â¯1  16331239353195368  1
##   Â¯0                  0  0
##    1 Â¯16331239353195368 Â¯1
##                            â•¯
#+end_src
*** ~=~ ~â‰ ~ equals {eq}, not equals {~!=~ / ne / neq}
Compare for equality/inequality.
- Uiua has no boolean type. Comparison operators return ~0~ for /false/ and ~1~
  for /true/.

*** ~<~ ~>~ less than {lt}, greater than {gt}
Compares for less/greater than.
- ~< x y~ means ~y < x~
- ~> x y~ means ~y > x~

*** ~â‰¤~ ~â‰¥~ less or equal {~<=~ / le / leq}, greater or equal {~>=~ / ge / geq}
Compares for less/greater than or equal.
- ~â‰¤ x y~ means ~y â‰¤ x~
- ~â‰¥ x y~ means ~y â‰¥ x~

*** ~â†¥ â†§~ maximum {max}, minimum {min}
Takes the max./min. of two arrays.
- like dyadic ~âŒˆ~ (maximum) / ~âŒŠ~ (minimum) in APL
*** ~â„‚~ complex {com} & ~Â°~
Creates a complex number from an /imaginary/ and a /real/ part on the stack.
- stack order: 1. /imaginary/ 2. /real/
- equivalent to ~+Ã—i~

/un-complex/ ~Â°â„‚~ pushes the /imaginary/ and /real/ parts back on the stack (in
the same order as the input to /complex/).

#+begin_src uiua
â„‚ 3 5 ## 5+3i
[Â°â„‚] i ## [1 0]
= 5 â„‚0 5 ## 1
#+end_src

See also:
- /absolute value/ ~âŒµ~ â†’ get the magnitude
- /sign/ ~Â±~ â†’ normalize to magnitude 1

** Monadic Array
*** ~â§»~ length {len} & ~(Â°âŠ¸)â‚™~
Returns the number of items along the first axis of the array.
- like monadic ~â‰¢~ (tally) in APL

*** ~â–³~ shape {sha} & ~Â°â‚™âœ~
Returns the dimensions of the array.
- like monadic ~â´~ (shape) in APL

#+begin_src uiua
â–³5               #=> []
â–³[]              #=> [0]
â–³[9 1 6]         #=> [3]
â–³[4_Ï€_9 1_5_âˆ]   #=> [2 3]
â–³[[1_2_3 3_4_5]] #=> [1 2 3]
#+end_src

/un-shape/ ~Â°â–³~ takes a /shape/ as input and returns an array of that shape.

#+begin_src uiua
Â°â–³ 2_3_4
## â•­â”€                         
## â•· 0 1  2  3  12 13 14 15   
## â•· 4 5  6  7  16 17 18 19   
##   8 9 10 11  20 21 22 23   
##                          â•¯ 
#+end_src

*** ~â™­~ deshape {flat / des} & ~âœ~
Flattens the array to /rank 1/.
- like monadic ~,~ (ravel) in APL

With a /subscript/, flattens it to /rank n/.
- /negative subscripts/ flatten to rank /m-n/ (relative to rank /m/ of the arr.)
- if the subscript rank is greater than the rank of the array, /length-1/
  axes are added to the front of the shape
- if the subscript is 0, returns the first scalar in the array

#+begin_src uiua
â–³ â™­ Â°â–³2_3_4_5  ## [120] 
â–³ â™­â‚‚ Â°â–³2_3_4_5 ## [24 5] 
â–³ â™­â‚ƒ Â°â–³2_3_4_5 ## [6 4 5]

â–³ â™­â‚‹â‚ Â°â–³2_3_4_5 ## [6 4 5] 
â–³ â™­â‚‹â‚‚ Â°â–³2_3_4_5 ## [24 5] 
â–³ â™­â‚‹â‚ƒ Â°â–³2_3_4_5 ## [120] 
#+end_src

/under-deshape/ ~âœâ™­<f>~ flattens the array, applies a function and puts it
back to its original shape. This can be useful to reverse higher-ranked
arrays:
#+begin_src uiua
âŠ¸âœâ™­â‡Œ â†¯3_4â‡¡12
### â•­â”€            
### â•· 0 1  2  3   
###   4 5  6  7   
###   8 9 10 11   
###             â•¯ 
### â•­â”€            
### â•· 11 10 9 8   
###    7  6 5 4   
###    3  2 1 0   
###             â•¯ 
#+end_src

*** ~âŠ¢~ ~âŠ£~ first {fir} & ~âœâ‚™~, last {las} & ~âœâ‚™~
Returns the first/last /row/ (first axis) of an array.
- like dyadic ~1â†‘~ / ~Â¯1â†‘~ (take) in APL

*** ~âŠš~ where {whe} & ~Â°~
Returns an array of indices where array values are not equal to ~0~.
- like monadic ~â¸~ (where) in APL
- e.g. to get indices from a binary mask
- works with multi-dimensional arrays (result is always rank 2)
- on a list it is equivalent to ~Ëœâ–½Â°âŠ~
- for boolean masks, /select where/ ~âŠâŠš~ is equivalent to /keep/ ~â–½~

#+begin_src uiua
âŠ¸âŠš > 4 [2 8 3 9 1 7 2]
### [0 1 0 1 0 1 0] 
### [1 3 5]         

âŠ¸âŠš > 4 [2_8_3 9_1_7]
### â•­â”€        
### â•· 0 1 0   
###   1 0 1   
###         â•¯ 
### â•­â”€        
### â•· 0 1     
###   1 0     
###   1 2     
###       â•¯   
#+end_src

/un-where/ ~Â°âŠš~ takes an array of indices (can be unordered) and returns an
array of counts at the position each index indicates.
#+begin_src uiua
Â°âŠš [3 2 8 2 2 5]
## [0 0 3 1 0 1 0 0 1] 

Â°âŠš [3_4 2_1 0_3]
## â•­â”€            
## â•· 0 0 0 1 0   
##   0 0 0 0 0   
##   0 1 0 0 0   
##   0 0 0 0 1   
##             â•¯ 
#+end_src

/under-where/ ~âœâŠš~ allows for manipulation of the index array from /where/
before it is inverted (via /un-where/) to an array of positions based on
these indices.
#+begin_src uiua
[1_1_0 0_1_1 0_1_1]
âœâŠš(â–½â‰¡/Ã—Â¬âŠ¸â—¿2)
## â•­â”€        
## â•· 1 0 0   
##   0 0 0   
##   0 0 1   
##         â•¯ 
#+end_src

*** ~â‡¡~ range {ran} & ~â‚™~
Creates an array of all natural numbers less than /n/.
- like monadic /index generator/ (iota) ~â³~ in APL

/range/ with /subscript/ changes the /offset/ of the range:
#+begin_src uiua
â‡¡â‚ 5 ## [1 2 3 4 5] 
â‡¡â‚‚ 5 ## [2 3 4 5 6] 
#+end_src

*** ~â‡Œ~ reverse {rev}
Reverses the array along the first axis.
- like monadic ~âŠ–~ (reverse first) in APL
- ~â‰¡â‡Œ~ behaves like monadic ~âŒ½~ (reverse) in APL
  
*** ~â‰~ transpose {tra} & ~Â°~
Transposes/rotates the axes/shape of the array so that the /leading axis/
will become the /last axis/ of the shape.
- like monadic ~â‰~ (transpose) in APL
- e.g. the shape of ~â‰Â°â–³5_4_3_2_1~ will become ~[4 3 2 1 5]~

#+begin_src uiua
â‰ [1_2_3
   4_5_6]
## â•­â”€
## â•· 1 4
##   2 5
##   3 6
##       â•¯
#+end_src

/un-transpose/ ~Â°â‰~ instead rotates the /last axis/ to become the /leading axis/
of the shape.
- e.g. the shape of ~Â°â‰Â°â–³5_4_3_2_1~ will become ~[1 5 4 3 2]~

#+begin_src uiua
X â† Â°â–³2_3_4
X # 2Ã—3Ã—4
## â•­â”€
## â•· 0 1  2  3  12 13 14 15
## â•· 4 5  6  7  16 17 18 19
##   8 9 10 11  20 21 22 23
##                          â•¯
â‰ X # 3Ã—4Ã—2
## â•­â”€
## â•· 0 12  4 16   8 20
## â•· 1 13  5 17   9 21
##   2 14  6 18  10 22
##   3 15  7 19  11 23
##                     â•¯
Â°â‰ X # 4Ã—2Ã—3
## â•­â”€
## â•·  0  4  8   1  5  9   2  6 10   3  7 11
## â•· 12 16 20  13 17 21  14 18 22  15 19 23
##                                          â•¯
#+end_src

*** ~Â¤~ fix {fx / f(â†’planet)}
Adds a /length-1/ axis to the array.

*** ~â–¡~ box {bx} & ~Â°(âœÂ°)â‚™~
See [[Array Boxing]].

*** ~â‹¯~ bits & ~Â°âœâ‚™~
Encode a number/array as bits (LSB-first).
- â€œLBSâ€ means /least significant bit/
- always results in an array 1 rank higher than the input
- with /subscript/, forces the number of bits to be used (extends or
  truncates the bits)

/un-bits/ ~Â°â‹¯~ decodes bits back to numbers.

*Warning:* conversion (~â‹¯~ / ~Â°â‹¯~) on large numbers (> 53 bits long) may give
incorrect results due to floating point imprecision.

/under-bits/ ~âœâ‹¯~ performs /bit-wise operations/.

** Dyadic Array
*** ~â†¯~ reshape {res} & ~â¬š~
Reshape the array to fit the given shape.
- like ~â´~ (reshape) in APL
- repeats elements when overcounting the input array (like in APL)
*** ~â†»~ rotate {rot} & ~â¬šâœ~
Rotates the elements of the array by /n/ places /left-//upwards/.
- like dyadic ~âŒ½~ (rotate) in APL

/under-rotate/ ~âœâ†»<f>~ rotates the array, applies a function to it and
reverses the rotation:
#+begin_src uiua
âœ(â†»3|âŠ‚0) [1 2 3 4 5] ## [1 2 3 0 4 5] 
#+end_src

*** ~â¤¸~ orient {ori} & ~â¬š(âœâŒ)Â°âŒ~
Changes the order of the axes of the array given a list of unique /axis
indices/.
- ~â¤¸Â¯1~ is equivalent to /un-transpose/ ~Â°â‰~

*** ~â†™~ ~â†˜~ take {tak} & ~â¬š(Â°â¬š)~, drop {dro} & ~â¬šâŒ~
Takes/drops /n/ elements along the first axis of the array.
- like dyadic ~â†‘~ (take) / ~â†“~ (drop) in APL

With a given /fill/ ~â¬š~ item, any excess amount /taken/ will add that many fill
items to the array:
#+begin_src uiua
â¬š@.â†™10 "Iverson"  ## "Iverson..." 
â¬š@.â†™Â¯10 "Iverson" ## "...Iverson" 
#+end_src

Similarly, /anti-drop/ ~âŒâ†˜~ pads an array with /n/ fill elements:
- uses a default fill item, when no /fill/ ~â¬š~ modifier is given
#+begin_src uiua
â¬š@.âŒâ†˜Â¯3 "Iverson" ## "Iverson..." 
â¬š@.âŒâ†˜3 "Iverson"  ## "...Iverson" 

â†˜2 [1 2 3 4 5]        ## [3 4 5] 
âŒâ†˜2 [1 2 3 4 5]       ## [0 0 1 2 3 4 5] 

â†˜ 1_2 [1_2_3_4
       5_6_7_8]
## â•­â”€
## â•· 7 8
##       â•¯
âŒâ†˜ 1_2 [1_2_3_4
        5_6_7_8]
## â•­â”€
## â•· 0 0 0 0 0 0
##   0 0 1 2 3 4
##   0 0 5 6 7 8
##               â•¯
#+end_src

/under-take/ / /under-drop/ ~âœâ†™<f>~ ~âœâ†˜<f>~ takes/drops items from the array,
calls a function on them and puts them back into the array:
#+begin_src uiua
âœ(â†™2)/Ã— [3 5 4 2] ## [15 4 2] 
#+end_src

*** ~âŠ¡~ pick {pic} & ~Â°âœâŒ~
Picks a /row/ or /element/ of the array, given a single index or a list of
indices (to reach into higher-ranked arrays).

If the index array is /rank 2/ or greater, multiple rows or elements will be
picked:
#+begin_src uiua
âŠ¡ 1 [1_2_3 4_5_6]         ## [4 5 6] 
âŠ¡ 1_1 [1_2_3 4_5_6]       ## 5 
âŠ¡ [1_2 0_1] [1_2_3 4_5_6] ## [6 2] 
#+end_src

/anti-pick/ ~âŒâŠ¡~ inserts the elements of an array at their corresponding
indices:
- requires a /fill/ ~â¬š~ value if not all indices are present
#+begin_src uiua
â¬š@-âŒâŠ¡ 3 @a ## "---a" 
â¬š0âŒâŠ¡ 2 [1 2 3 4]
## â•­â”€
## â•· 0 0 0 0
##   0 0 0 0
##   1 2 3 4
##           â•¯
â¬š@XâŒâŠ¡ [1 2] ["cat" "eye"]
## â•­â”€
## â•· "XXX"  "XXX"  "XXX"
## â•· "XXX"  "XXX"  "XXX"
## â•·
##   "XXX"  "XXX"  "cat"
##   "XXX"  "XXX"  "eye"
##                       â•¯
â¬š@XâŒâŠ¡ [1_1 0_3] ["cat" "eye"]
## â•­â”€
## â•· "XXX"  "XXX"
## â•· "XXX"  "cat"
##   "XXX"  "XXX"
##   "eye"  "XXX"
##                â•¯
âŒâŠ¡ 0_0_0 "ab"
## â•­â”€       
## â•·        
## â•· "ab"   
## â•·        
##        â•¯ 
#+end_src

/un-pick/ ~Â°âŠ¡~ enumerates the indices of the array:
- equivalent to /range-by-shape/ ~â‡¡âŠ¸â–³~
#+begin_src uiua
Â°âŠ¡ "wow"
### "wow"
### â•­â”€
### â•· 0
###   1
###   2
###     â•¯
Â°âŠ¡ ["pow" "wow"]
### â•­â”€
### â•· "pow"
###   "wow"
###         â•¯
### â•­â”€
### â•· 0 0  1 0
### â•· 0 1  1 1
###   0 2  1 2
###            â•¯
#+end_src

/under-pick/ ~âœâŠ¡<f>~ picks an item from the array, applies a function on it
and puts it back into the original array:
- if the values passed to /under/ are not constants, they can be put
  outside, in a different order
- to replace the value at the index, use /pop/ ~â—Œ~ or /gap/ ~â‹…~
#+begin_src uiua
âœ(âŠ¡2|Ã—10) [1 2 3 4] ## [1 2 30 4]
âœâŠ¡Ã— 2 [1 2 3 4] 10 ## [1 2 30 4]

âœ(âŠ¡2)â‹…âˆ [1 2 3 4] ## [1 2 âˆ 4] 
âœâŠ¡â—Œ 2 [1 2 3 4] âˆ ## [1 2 âˆ 4] 
#+end_src

*** ~âŠ~ select {sel} & ~â¬šÂ°âœâŒ~
Selects /rows/ from an array according to an index vector.

/anti-select/ ~âŒâŠ~ creates an array where each element of the input array is
arranged according to the given index vector:
- a /fill/ ~â¬š~ modifier can be attached to fill empty positions
- without a /fill/, it is essentially a permutation

#+begin_src uiua
âŠ [2 0 1 1] "abc"   ## "cabb" 
â¬š@-âŒâŠ [5 2 1] "bcf" ## "-fc--b" 
âŒâŠ [2 0 1] "abc"    ## "bca" 
#+end_src

/un-select/ ~Â°âŠ~ produces an array of indices for the rows of the input array
while leaving it on the stack:
#+begin_src uiua
Â°âŠ "enumerate"
### "enumerate"         
### [0 1 2 3 4 5 6 7 8] 

â‰¡Â°âŠ ["hello" "world"]
### â•­â”€            
### â•· "hello"     
###   "world"     
###           â•¯   
### â•­â”€            
### â•· 0 1 2 3 4   
###   0 1 2 3 4   
###             â•¯ 
#+end_src

/under-select/ ~âœâŠ<f>~ selects items from the array, applies a function on
them and puts them back into the original array.
- works similar to /under-pick/

*** ~â–½~ keep {kee} & ~âŠ¸â¬šÂ°â‚™âœâŒ~
Discards or copies items in an array:
: â–½ <mask> <arr>
- like dyadic ~âŒ¿~ (replicate first) in APL

Example:
#+begin_src uiua
â–½ [0 1 0 1] [1_2 3_4 5_6 7_8]
#=>
â•­â”€     
â•· 3 4  
  7 8  
      â•¯
#+end_src

~âœâ–½~ modifies part of an array according to a mask:
: âœâ–½<f> <mask> <arr>

Example:
#+begin_src uiua
âœâ–½(Ã—.) [0 1 1 0 1] [1 2 3 4 5]
#=>
[1 4 9 4 25]
#+end_src

*** ~âŒ•~ find
Returns a boolean array that marks (the start of) each occurrence of the
first array in the second.
- like dyadic ~â·~ (find) in APL

*** ~â¦·~ mask
*** ~âˆŠ~ memberof {mem / elem}
Checks if each row in the second array exists in the first one and returns
an array of boolean numbers.
- like dyadic ~âˆŠ~ (membership) in APL (arg. order swapped!)

#+begin_src uiua
âˆŠ [1 2 3] 2           ## 1 
âˆŠ [1 2 3] 4           ## 0 
âˆŠ [0 3 4 5 1] [1 2 3] ## [1 0 1] 
âˆŠ [3 4 5] [1_2_3 4_5_6]
## â•­â”€
## â•· 0 0 1
##   1 1 0
##         â•¯
#+end_src

/keep-by-memberof/ ~â–½âŠ¸âˆŠ~ gets the /intersection/ of two arrays/sets.

*** ~âŠ—~ indexin {idx / ind} & ~â¬š~
Finds the first index in the first array of each row of the second array.
- like dyadic ~â³~ (index of) in APL, except that this only applies to /major
  cells/ for higher-ranked arrays, while /indexin/ applies to each /k-cell/ of
  the first arg. for a second arg. of rank /k/
- returns the /length/ of the searched-in array if the index cannot be found
  or a /fill-item/ if the /fill/ ~â¬š~ modifier is specified

#+begin_src uiua
â¨‚ [1 2 3] 2     ## 1 
â¨‚ [1 2 3] [2 3] ## [1 2] 

â¨‚ [[1_2 3_4] [5_6 7_8]] 4
## â•­â”€
## â•· 2 1
##   2 2
##       â•¯
â¨‚ [[1_2 3_4] [5_6 7_8]] [3 4]
## [1 2]
#+end_src

*** ~â‰~ match
*** ~âŠ‚~ join {joi} & ~â¬šÂ°â‚™~
Concatenates two arrays or appends a new /row/ in case of a scalar.
- like dyadic ~âª~ (catenate first) in APL
- ~â‰¡âŠ‚~ behaves like dyadic ~,~ (catenate) in APL

*** ~âŠŸ~ couple {cou} & ~â¬šÂ°â‚™~
Combine two arrays as /rows/ of a new array (increases the rank).
- with a /subscript/, more than 2 arrays can be coupled
- can be combined with /rows/ ~â‰¡~ to couple pairs of rows from both arrays

#+begin_src uiua
âŠŸ 1 2       ## [1 2] 
âŠŸâ‚ƒ @f @u @n ## "fun" 
âŠŸ [1 2 3] [4 5 6]
## â•­â”€
## â•· 1 2 3
##   4 5 6
##         â•¯
â‰¡âŠŸ [1 2 3] [4 5 6]
## â•­â”€
## â•· 1 4
##   2 5
##   3 6
##       â•¯
#+end_src

/un-couple/ ~Â°âŠŸ~ separates combined arrays:
#+begin_src uiua
Â°âŠŸ [1 2]
### 2 
### 1 

Â°âŠŸ [0_1_2
    3_4_5]
### [3 4 5] 
### [0 1 2] 

â‰¡Â°âŠŸâ‚ƒ [0_1_2
      3_4_5]
#### [2 5] 
#### [1 4] 
#### [0 3] 
#+end_src

/fill/ ~â¬š~ completes the coupled array when shapes donâ€™t match:
#+begin_src uiua
â¬š@ âŠŸ "Apple" "Pie"
## â•­â”€          
## â•· "Apple"   
##   "Pie  "   
##           â•¯ 
#+end_src

*** ~âŠ¥~ base
Returns the base digits of the number in the second argument, given a
single base or a list of bases for each digit in the first argument.
- like binary ~âŠ¤~ (encode) in APL, except that the shape of the output shape
  is reversed and each number reads from left to right instead rtl. So
  prepending ~â‡Œâ‰~ makes them equal
- digits are listed /least-significant/ to /most-significant/ and are
  represented by integers only (no letters)
- with a list of bases, any unlisted remaining digit will be truncated
  - an ~âˆ~ at the end of the list collects the remainder in that â€œdigitâ€

#+begin_src uiua
âŠ¥ 2 38       ## [0 1 1 0 0 1] 
âŠ¥ [2 2 2] 38 ## [0 1 1] 
âŠ¥ [2 2 âˆ] 38 ## [0 1 9] 

âŠ¥ 16 18      ## [2 1] 

âŠ¥ 2 â‡¡â¿2 3
## â•­â”€
## â•· 0 0 0 0
##   1 0 0 0
##   0 1 0 0
##   1 1 0 0
##   0 0 1 0
##   1 0 1 0
##   0 1 1 0
##   1 1 1 0
##   0 0 0 1
##           â•¯
#+end_src

** Misc
*** ~repr~ {rpr}
Converts a value to its code representation.

*** ~&ims~ image - show
Shows an image, depending on the system backend.

*Note:* In the (Ghostty) terminal, the image does not always shows up with
lower row/column lengths (bug?).
- better use /window mode/ ~-w~ for graphic output
*** ~&gifs~ gif - show
*** ~&ap~ audio - play
*** ~&s~ show
Prints a nicely formatted representation of a value to stdout.

Array axes are layed out in an alternating horizontalâ†’verticalâ†’â€¦ pattern.
The elements of the last axis are always layed out horizontally
(column-wise), the ones on the next axis vertically (row-wise), for the
next axis it is horizontally again, etc.
- this is different to APL, where every axis before the last one is layed
  out vertically in rows

*** ~&p~ print with newline
Print a value to stdout followed by a newline.
* Modifiers (â†’Operators)
** Stack Modifiers
*** ~Ëœ~ backward [mon.] {bac}
Swaps the arguments of a dyadic function.
- like monadic operator ~â¨~ (commute) in APL

: Ëœ -3 10  =  -10 3  =  -7

*** ~Ë™~ self [mon.] {slf}
Calls a function with the same array as all arguments.

#+begin_src uiua
Ë™+ 5
# =>
10

Ë™âŠ+ 1_2_3
# =>
â•­â”€       
â•· 2 3 4  
  3 4 5  
  4 5 6  
        â•¯
#+end_src

*** ~âŠ™~ dip [mon.] {d(â†’planet)}
Temporarily pops the top value off the stack and calls the function.
- stacking multiple /dips/ enables operating on lower stack values without
  touching the top ones

#+begin_src uiua
âŠ™+ 1 2 3 4
# =>
4
5
1

[âŠ™âŠ™+ 1 2 3 4]
# =>
[1 2 7]

âŠ™(/â†¥) 1_2_3 4_5_6
# =>
6
[1 2 3]
#+end_src

Combines well with /fork/ ~âŠƒ~ to keep values on the stack after/before
operating on them:
- use /gap/ ~â‹…~ to drop subsequent stack values
#+begin_src uiua
[âŠƒâŠ™âŠ™âˆ˜(++) 3 5 10]
# =>
[3 5 10 18]

[âŠƒâŠ™â‹…âˆ˜(++) 3 5 10]
# =>
[3 10 18]
#+end_src

*** ~â‹…~ gap [mon.] {ga / g(â†’planet)}
Discards the top stack value before calling the function.
- also see the function /pop/ ~â—Œ~

#+begin_src uiua
â‹…+ 3 5 10
# =>
15
#+end_src

*** ~âŠƒ~ fork [dya.] {for / f(â†’planet)}
Calls two functions on the same value(s) and puts both outputs on the
stack.
- the functions can be of any arity; if one function takes fewer
  arguments, it just uses that many arguments from the top of the stack
- important for threading data through a program and for /planet notation/

#+begin_src uiua
âŠƒâ‡Œâ§» 1_2_3_4
# =>
4
[4 3 2 1]

âŠƒâ†§â†¥ â‡¡4 â‡Œâ‡¡4
# =>
[3 2 2 3]
[0 1 1 0]
#+end_src

With a /function pack/, /fork/ can take any number of functions instead of
just two:
#+begin_src uiua
[âŠƒ(+|-|Ã—|Ã·) 2 5]
## [7 3 10 2.5] 
#+end_src

*** ~âˆ©~ both [mon.] {bot} & ~â‚™âŒâŒŸ~
Calls the /n/-ary function on two sequences of the next top /n/ values on the
stack.
- just the top 2 values in case of a unary function
- for a dyadic function ~f~ on ~a b c d~, calls ~f a b~ and ~f c d~

#+begin_src uiua
âˆ©â‡¡ 4 6
### [0 1 2 3 4 5]
### [0 1 2 3]
[âˆ©+ 1 2 3 4] ## [3 7] 
#+end_src

With /numbered subscripts/, /both/ calls its function on /n/ sets of arguments:
#+begin_src uiua
[âˆ©â‚ƒâŠŸ 1 2 3 4 5 6]
## â•­â”€      
## â•· 1 2   
##   3 4   
##   5 6   
##       â•¯ 
#+end_src

/both/ can be used with /sided subscripts/ to apply the /left-most/ ~âŒ~ or
/right-most/ ~âŒŸ~ argument twice:
#+begin_src uiua
[âˆ©âŠŸ @a @b @c @d]
## â•­â”€       
## â•· "ab"   
##   "cd"   
##        â•¯ 
[âˆ©âŒâŠŸ @a @b @c]
## â•­â”€       
## â•· "ab"   
##   "ac"   
##        â•¯ 
[âˆ©âŒŸâŠŸ @a @b @c]
## â•­â”€       
## â•· "ac"   
##   "bc"   
##        â•¯ 
#+end_src

/sided/ and /numeric subscripts/ can also be mixed.

*** ~âŠ“~ bracket [dya.] {bra} & ~âŒâŒŸ~
Calls two /n/-ary functions on two sequences of the next top /n/ values on the
stack.
- just the top 2 values in case of a unary function
- for dyadic functions ~f~ and ~g~ on ~a b c d~, calls ~f a b~ and ~g c d~

Like /fork/, /bracket/ can take any number of functions instead of just two
when using a /function pack/:
#+begin_src uiua
[âŠ“(+|-|Ã—|Ã·) 10 20 5 8 3 7 2 5]
## [30 3 21 2.5] 
#+end_src

/bracket/ (like /both/) can be used with /sided subscripts/ to apply the
/left-most/ ~âŒ~ or /right-most/ ~âŒŸ~ argument twice:
#+begin_src uiua
{âŠ“âŠŸâ–¡â‚‚ @a @b @c @d}
## ["ab"â”‚[@câ”‚@d]] 
{âŠ“âŒâŠŸâ–¡â‚‚ @a @b @c}
## ["ab"â”‚[@aâ”‚@c]] 
{âŠ“âŒŸâŠŸâ–¡â‚‚ @a @b @c}
## ["ac"â”‚[@bâ”‚@c]] 

âŠ“âŒŸâ‰¥â‰¤5 8 [6 2 5 9 6 5 0 4]
### [1 1 1 0 1 1 1 1] 
### [1 0 1 1 1 1 0 0] 
#+end_src

*** ~âŸœ~ ~â¤š~ on, off
Keeps the first argument before /(on)/ / behind /(off)/ the output.

*** ~âŠ¸~ ~â¤™~ by, with
Keeps the last argument behind /(by)/ / before /(with)/ the output.

With /with/, multiple dyadic functions can be called with the same last
argument:
#+begin_src uiua
+1â¤™Ã—2 5
### 10 
### 6  
#+end_src

Combined with /planet notation/, /with/ can copy or move items lower in the
stack to the top:
#+begin_src uiua
[â¤™âŠ™âŠ™âŠ™âˆ˜ 1 2 3 4] ## [4 1 2 3 4] 
[â¤™âŠ™âŠ™âŠ™â—Œ 1 2 3 4] ## [4 1 2 3] 
[â¤™âŠ™âŠ™âˆ˜ 1 2 3 4]  ## [3 1 2 3 4] 
[â¤™âŠ™âŠ™â—Œ 1 2 3 4]  ## [3 1 2 4] 
#+end_src

*** ~â— ~ ~â—¡~ above, below

** Iterating Modifiers
*** ~â‰¡~ rows {row} & ~â‚™âŒâŒŸ~
Applies the function to /each row/ of the array(s).
: â‰¡<f> <arr â€¦>
- similar to monadic operator ~Â¨~ (each) in APL

Using a /numeric subscript/ specifies the /rank/ of the subarrays the function
operates on:
- this is equivalent to stacking multiple ~â‰¡~
- positive subscripts count from bottom to top
- negative subscripts count from top to bottom, like normal/stacked ~â‰¡~
#+begin_src uiua
â‰¡â‚€â–¡ Â°â–³ 2_3_4 # Scalars <=> â‰¡â‚‹â‚ƒâ–¡ <=> â‰¡â‰¡â‰¡â–¡
## â”Œâ”€
## â•· âˆ™0â”‚âˆ™1â”‚âˆ™2 â”‚âˆ™3 â•‘âˆ™12â”‚âˆ™13â”‚âˆ™14â”‚âˆ™15
## â•· â”€â”€â”¼â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â•«â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€
##   âˆ™4â”‚âˆ™5â”‚âˆ™6 â”‚âˆ™7 â•‘âˆ™16â”‚âˆ™17â”‚âˆ™18â”‚âˆ™19
##   â”€â”€â”¼â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â•«â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€
##   âˆ™8â”‚âˆ™9â”‚âˆ™10â”‚âˆ™11â•‘âˆ™20â”‚âˆ™21â”‚âˆ™22â”‚âˆ™23
##                                 â”˜
â‰¡â‚â–¡ Â°â–³ 2_3_4 # Vectors <=> â‰¡â‚‹â‚‚â–¡ <=> â‰¡â‰¡â–¡
## â”Œâ”€
## â•· 0 1 2 3    â”‚4 5 6 7    â”‚8 9 10 11
##   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
##   12 13 14 15â”‚16 17 18 19â”‚20 21 22 23
##                                       â”˜
â‰¡â‚‚â–¡ Â°â–³ 2_3_4 # Matrices <=> â‰¡â‚‹â‚â–¡ <=> â‰¡â–¡
## â”Œâ”€
##   0 1  2  3â”‚12 13 14 15
##   4 5  6  7â”‚16 17 18 19
##   8 9 10 11â”‚20 21 22 23
##                         â”˜
â‰¡â‚ƒâ–¡ Â°â–³ 2_3_4
##  â•­â”€
##  â•· 0 1  2  3  12 13 14 15
## â–¡â•· 4 5  6  7  16 17 18 19
##    8 9 10 11  20 21 22 23
##                           â•¯
#+end_src

With a /sided subscript/, either the first ~âŒ~ or the last ~âŒŸ~ argument will be
/fix/'ed ~Â¤~:
- can be followed by a number to specify how many arguments to fix
- can be combined with a /numeric subscript/ before the /sided subscr./
#+begin_src uiua
â‰¡âŒâŠ‚ "ro" "wt" # reuses "ro" 
## â•­â”€
## â•· "row"
##   "rot"
##         â•¯
â‰¡âŒŸâŠ‚ "cm" "at" # reuses "at"
## â•­â”€
## â•· "cat"
##   "mat"
##         â•¯

â‰¡âŒâ‚‚(âŠ‚âŠ‚) 1_2 3_4 5_6
## â•­â”€            
## â•· 1 2 3 4 5   
##   1 2 3 4 6   
##             â•¯ 
â‰¡âŒŸâ‚‚(âŠ‚âŠ‚) 1_2 3_4 5_6
## â•­â”€            
## â•· 1 3 4 5 6   
##   2 3 4 5 6   
##             â•¯

â¤šâ‰¡â‚‚âŒŸâ‚â–¡â‚ƒ Â°â–³2_2_3 "hi" "there"
### â•­â”€                      
### â•· 0 1 2  6  7  8        
### â•· 3 4 5  9 10 11        
###                  â•¯      
### â”Œâ”€                      
### â•· 0 1 2  â”‚âˆ™@hâ”‚"there"   
###   3 4 5  â”‚   â”‚          
###   â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€   
###   6  7  8â”‚âˆ™@iâ”‚"there"   
###   9 10 11â”‚   â”‚          
###                       â”˜ 
#+end_src

*** ~âŠ~ table {tab}
Applies ~f~ on all combinations of rows from arrays ~a~ and ~b~:
: âŠ<f> <a> <b>
- there seems to be no analog in APL, /outer product/ only works scalar-wise

#+begin_src uiua
âŠ(âŠ‚â‡Œ) [1_2 3_4] [5 6 7]
#=>
â•­â”€              
â•· 2 1 5  4 3 5  
â•· 2 1 6  4 3 6  
  2 1 7  4 3 7  
               â•¯
#+end_src

*** ~â§ˆ~ stencil {st} & ~â¬šâ‚™~
Applies function ~f~ on /shape/-~s~ sized /sliding windows/ of the array:
: â§ˆ<f><s> <arr>
- scalar sizes can also be specified by /subscript/
- if ~f~ is not /monadic/, window size will be determined by its arity

With a window size of ~[[n]]~, stencil can be used to partition an array
into equally-sized chunks:
#+begin_src uiua
â§ˆâ–¡[[2]] "lorem ipsum"
## ["lo"â”‚"re"â”‚"m "â”‚"ip"â”‚"su"] 
â¬š@ â§ˆâ–¡[[3]] "lorem ipsum"
## ["   "â”‚"   "â”‚"lor"â”‚"em "â”‚"ips"â”‚"um "â”‚"   "] 
#+end_src

*** ~âš~ inventory
Applies the function to each /unboxed/ row of an array and re-/boxes/ the
result.
: âš<f>

** Aggregating Modifiers
*** ~/~ reduce {red}
Applies reducing function ~f~ to the array (â€œbetweenâ€ its items):
: /<f> <arr>
- reduces along the /first/ axis (across columns in a matrix)
- like monadic op. ~âŒ¿~ (reduce first) in APL
*** ~\~ scan {sca}
Like /reduce/ ~/~, but keeps intermediate values.
: \<f> <arr>
- scans along the /first/ axis (across columns in a matrix)
- like monadic op. ~â€~ (scan first) in APL
*** ~âˆ§~ fold {fol}
*** ~âŠ•~ group {gro} & ~Â°âœâ¬š~
Splits the array into groups of items matching the same integer in a given
~indices~ list and applies function ~f~ to each group.
: âŠ•<f> <indices> <arr>
- kind-of like dyadic ~âŒ¸~ (key) in APL, but keys would be implicit as
  indices of the matrix rows and there is no nested array
  - maybe together with /classify/ ~âŠ›~ it behaves more like key
- the resulting array is ordered by the indices in the list
- indices/keys less than 0 are omitted

The values returned by the function must all have the same /shape/ to be
properly concatenated in the resulting array. If this is not the case, a
/fill/ ~â¬š~ item can be provided to fix the shapes:
#+begin_src uiua
â¬šâˆâŠ•âˆ˜ [0 1 0 2 1 1] [1 2 3 4 5 6]
## â•­â”€        
## â•· 1 3 âˆ   
##   2 5 6   
##   4 âˆ âˆ   
##         â•¯ 
#+end_src

Or just /box/ ~â–¡~ each group to encapsulate different shapes:
#+begin_src uiua
âŠ•â–¡ [0 1 0 2 1 1] [1 2 3 4 5 6]
## [1 3â”‚2 5 6â”‚4] 
#+end_src

*** ~âŠœ~ partition {par} & ~Â°âœâ¬š~
Groups sequential sections of ~arr~ according to a ~markers~ list of integers
and applies function ~f~ to each group.
: âŠœ<f> <markers> <arr>
- like dyadic ~âŠ†~ (partition) in APL, except ~âŠ†~ doesnâ€™t take a function
- markers donâ€™t imply any ordering, they can be any integer
  - e.g. the list can be a boolean mask ~[1 1 0 0 1 1 0 0]~
- markers less than or equal to 0 are omitted
- both arguments must be the same length

The values returned by the function must all have the same /shape/ to be
properly concatenated in the resulting array. If this is not the case, a
/fill/ ~â¬š~ item can be provided to fix the shapes:
#+begin_src uiua
â¬šâˆâŠœâˆ˜ [0 2 3 3 3 0 1 1] [1 2 3 4 5 6 7 8]
## â•­â”€        
## â•· 2 âˆ âˆ   
##   3 4 5   
##   7 8 âˆ   
##         â•¯ 
#+end_src

Or just /box/ ~â–¡~ each partition to encapsulate different shapes:
#+begin_src uiua
âŠœâ–¡ [0 2 3 3 3 0 1 1] [1 2 3 4 5 6 7 8]
## [2â”‚3 4 5â”‚7 8] 

âŠœâ–¡ âŠ¸â‰ @  $ Hey there friendo
## ["Hey"â”‚"there"â”‚"friendo"] 
#+end_src

The idiom ~âœâŠœâ–¡âš<f>~ can be used to apply an operation to partitions of an
array before restoring the original array structure:
#+begin_src uiua
âœâŠœâ–¡âšâ‡ŒâŠ¸â‰ @  "get in the racecar" ## "teg ni eht racecar" 
#+end_src

** Inversion Modifiers
*** ~Â°~ un
Inverts the behaviour of a function.
- e.g. for /un-boxing/: ~Â°â–¡~
- the inverse must always have the opposite signature of the function
  - e.g. signature ~|2.1~ must become ~|1.2~

/un-by/ ~Â°âŠ¸<f>~ applies the â€œundoâ€ part of a functionâ€™s /under/ ~âœ~ inverse
without the â€œdoâ€ part.
- works only for /monadic/ functions

#+begin_src uiua
âœâŠ¢(Ã—10) [2 3 4] ## [20 3 4] 
Â°âŠ¸âŠ¢ 0 [2 3 4]   ## [0 3 4] 

âœ(âŠ¡2)(â‹…5) [1 2 3 4] ## [1 2 5 4] 
Â°âŠ¸(âŠ¡2) 5 [1 2 3 4]  ## [1 2 5 4] 
#+end_src

*** ~âŒ~ anti
Inverts the behaviour of a function, treating its first argument as a
constant(?)
- similar to /un/ ~Â°~, but allows the use of external arguments
- for dya. func. ~F~ and values ~A~ and ~B~, ~âŒF A B~ is equivalent to ~Â°(F A) B~
- the /anti inverse/ of a function with signature ~|a.b~ is ~|(b+1).(a-1)~
  - e.g. signature ~|2.1~ will stay ~|2.1~

*** ~âœ~ under
Operates (~g~) on a transformed (~f~) array, then reverses the transformation.
: âœ<f><g>
- more powerful version of /un/ ~Â°~

** Other Modifiers
*** ~â¬š~ fill {fil}
Fill missing values of an array that has mismatched shapes with ~fill-value~
so it becomes a valid array:
: â¬š<fill-value> <arr/f>
- partially like monadic ~â†‘~ (mix) in APL, but not with nested arrays and with
  function argument

#+begin_src uiua
â¬š0[1 2_3_4 5_6]
#=>
â•­â”€       
â•· 1 0 0  
  2 3 4  
  5 6 0  
        â•¯

â¬šÏ€â†™ 5 [1 2 3]
#=>
[1 2 3 Ï€ Ï€]
#+end_src
* Pattern Matching
See https://www.uiua.org/tutorial/Pattern%20Matching

The /un/ ~Â°~ modifier can be applied to constants to pattern-match them. If the
constant is not equal to the argument, an error is thrown. Otherwise, the
argument is popped from the stack.

Using /planet notation/, arrays can be destructured to match certain values and
extract others:
#+begin_src uiua
Â°[1âŠ™3] [1 5 3]             ## 5 
Â°[1 2âŠ™âŠ™(5âˆ˜)] [1 2 3 4 5 6] #### 6 
                           #### 4 
                           #### 3 
Â°[1_2 [âŠ™4]] [1_2 3_4]      ## 3 
#+end_src

/un-join/ ~Â°âŠ‚~ with a constant can be used to match arrays with a certain
/prefix/ or /suffix/ (using /backward/ ~Ëœ~):
#+begin_src uiua
Â°(âŠ‚1) [1 2 3] ## [2 3]
Â°(ËœâŠ‚3) [1 2 3] ## [1 2] 
#+end_src

* Idioms/Recipes
Sources:
- https://www.uiua.org/docs/idioms
- https://tankorsmash.unison-services.cloud/s/uiuisms-service/

Duplicate a value on the stack:
: âŸœâˆ˜

Check if all rows in an array are equal:
: â‰âŠ¸â†»1

Create an array of indices with the given ~shape~:
: Â°â–³<shape>

Get prime factors of a number:
: Â°/Ã—
Check if a number is prime:
: =1â§»Â°/Ã—

Partition a string by spaces:
: âŠœâ–¡âŠ¸â‰ @\s

Get the lowercase/uppercase alphabet:
: +â‡¡26@a
: +â‡¡26@A
Get the digits from 0-9 as a string:
: +â‡¡10@0

Linear interpolation (lerp):
: Lerp â† âŒ…(
:   +âŠƒâŠ¢(Ã—/-) # normal <[min max]> <ratio> -> <result>
: | Ã·âŠƒ/-(-âŠ¢) # inverse <[min max]> <result> -> <ratio>
: )

Upscale a 2d matrix or colored image:
: â–½âŸœâ‰¡â–½

Rotate a 2d matrix or colored image 90Â°:
: â¤¸1

Separate an RGB image into its channels:
: Â°âŠŸâ‚ƒâ¬š0â¤¸2_0_1_2 <img-arr>

Create a checkerboard of size N:
: â—¿2âŠ+.â‡¡ 8

Convert RGB array (e.g. ~[150 255 210]~) to hex code:
: âŠ‚@#â™­ËœâŠHexDigitsâ‰¡â‡ŒâŠ¥[16 16]

Check for leap year:
: â†§â†¥âŠƒ(=0â—¿400|â‰ 0â—¿100|=0â—¿4)

* Constants & Easter Eggs
Placeholder Text (445 characters):
: Lorem

Colors:
: Black White
: => [0 0 0] [1 1 1]
: Red Green Blue
: => [1 0 0] [0 1 0] [0 0 1]
: Cyan Magenta Yellow
: => [0 1 1] [1 0 1] [1 1 0]
: Purple Orange
: => [0.5 0 1] [1 0.5 0]

Images:
: Lena Cats Logo

Audio:
: Amen Music

Fun:
: # Boo!

