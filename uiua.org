#+title: Docs/Uiua

- https://www.uiua.org
- https://github.com/uiua-lang/

Online REPL: https://www.uiua.org/pad

Docs: https://www.uiua.org/docs/
- [[https://www.uiua.org/docs/combinators][Combinators]]

/Array-oriented/ programming language with a /stack-based/ execution model and a
/flat array/ model.
- arrays must be rectangular and cannot have mixed types
- mixed or deep arrays can be emulated using [[Boxes]]
- array functions use the /Leading Axis/ model

Subscripts can be added to some functions/modifiers by typing ~,~ followed by the
subscript number.
- e.g. ~?,2~ results in ~?â‚‚~

Editor support:
- Emacs: [[https://github.com/crmsnbleyd/uiua-mode][uiua-mode]]

Install the interpreter from the latest [[https://github.com/uiua-lang/uiua/releases][GitHub release]].

Extensions:
- [[https://github.com/uiua-lang/uiua-modules][Curated list of Uiua Modules]]

* Bindings
/Bindings/ are global names that can be assigned to values:
: x â† <v>
- binding names are /case-sensitive/, they can only contain letters
- no numbers or underscores are allowed, but /subscript/ numbers at the end of
  the name (e.g. ~Foo,123~ / ~Fooâ‚â‚‚â‚ƒ~) are possible
- to indicate related bindings, names can end with multiple ~â€²~ characters
  (typed with apostrophe ~'~)
- it is recommended to use /PascalCase/ for binding names with 2+ characters to
  avoid name clashes with built-in functions and their abbreviations
- ~=~ will be converted to ~â†~ by the formatter

~â†~ pops the first thing off the stack and assigns it to the name on the left,
therefore it can also bind to values on previous lines:
#+begin_src uiua
Ã—2 [2 3 4]
x â†
x  #=> [4 6 8]
#+end_src

Bindings can only bind a single value once for the entire lifetime of the
program. However, a name can be bound to another value/function:
#+begin_src uiua
X â† 42
X ## 42 
X â† @a
X ## @a 
#+end_src

But names cannot refer back to their previous values (which will be
interpreted as a recursive function):
#+begin_src uiua
X â† 12
X ## "3:1: Recursive function `X` must have a signature declared after the â†." 
X â† Ã—2 X
X
#+end_src


Functions can also be bound to names. If the right side of ~â†~ requires more
than 0 values to be on the stack, it doesnâ€™t get evaluated right away but will
instead be bound as a function:
: x â† <f>
- to create a 0-arity function, sorround the right side with ~()~

#+begin_src uiua
F â† +1
F5 ## 6

ğŸ‘‹ â† âŠ‚"Hello, "
ğŸ‘‹"World"
## "Hello, World"

F â† âš‚ # a value, not a function!
F ## 0.8136374781735876 
F ## 0.8136374781735876 

Fâ€² â† (âš‚) # 0-arity function
Fâ€² ## 0.8018080663476463 
Fâ€² ## 0.5432016624161957 
#+end_src

* Inline Functions
/Inline functions/ are defined in parentheses and are evaluated like any other
expression after being applied to their arguments. They can be broken up into
multiple lines, running from top to bottom:
#+begin_src uiua
âŠ¸â‰¡(+âŠ¸â‡Œ) [2_5_3 0_2_1 0_0_2]

X â† (
  Ë™âŠ=â‡¡ # First this line runs
  â†¥âŠ¸â‡Œ  # Then this one
)
#+end_src

* Arrays
An array is a rectangular collection of elements arranged along some number of
axes. Nesting creates arrays of higher rank, not nested arrays (like in APL),
so all nested arrays must be of the same length.
- Uiua supports arrays with an arbitrary number of /axes/

/rows/ are the groups of elements along the /leading axis/ of an array.
- for /lists/, this is just individual elements
- in the /shape/ ~â–³~ of an array, the first element is the number of /rows/, which
  is also the /length/ ~â§»~ of the array

Arrays are /0-indexed/.

/Stack notation/:
: [1 2 3 4]

/Strand notation/:
: 1_2_3_4

#+begin_src uiua
[1_2_3 [4 5 6] 7_8_9]
# =>
â•­â”€       
â•· 1 2 3  
  4 5 6  
  7 8 9  
        â•¯
#+end_src

Arrays can have arbitrary code inside brackets, which is evaluated just like
any other code:
#+begin_src uiua
[Ã—3. 4_5_6]
# =>
â•­â”€          
â•· 12 15 18  
   4  5  6  
           â•¯
#+end_src

For /pervasive functions/, the /shape/ of one array must be the /prefix/ of the
/shape/ of the other. So e.g. ~[2]~ and ~[2 3]~ are prefixes of ~[2 3 4]~, but ~[3 2]~
and ~[3]~ are not.

If shapes donâ€™t match, a /fill item/ can be used with the /fill/ ~â¬š~ modifier to
fill in the given value in missing places.

Example:
#+begin_src uiua
a â† â†¯2_3 â‡¡6
b â† â†¯2_3_4 â‡¡24
a b
### â•­â”€                         
### â•· 0 1  2  3  12 13 14 15   
### â•· 4 5  6  7  16 17 18 19   
###   8 9 10 11  20 21 22 23   
###                          â•¯ 
### â•­â”€                         
### â•· 0 1 2                    
###   3 4 5                    
###         â•¯                  
+
## â•­â”€                           
## â•·  0  1  2  3  15 16 17 18   
## â•·  5  6  7  8  20 21 22 23   
##   10 11 12 13  25 26 27 28   
##                            â•¯ 
#+end_src

Note: in APL, pervasive functions only apply between arrays of the same rank
or if one or both are scalar. For the example above one would have to use the
/rank/ operator: ~a (+â¤0 1) b~

Adding incompatible shapes using 100 as a /fill item/:
#+begin_src uiua
a â† â†¯3_2 â‡¡6
b â† â†¯2_3_4 â‡¡24
a b
### â•­â”€                         
### â•· 0 1  2  3  12 13 14 15   
### â•· 4 5  6  7  16 17 18 19   
###   8 9 10 11  20 21 22 23   
###                          â•¯ 
### â•­â”€                         
### â•· 0 1                      
###   2 3                      
###   4 5                      
###       â•¯                    
â¬š100+
## â•­â”€                                                    
## â•·   0   1   2   3   14  15  16  17  104 104 104 104   
## â•·   5   6   7   8   19  20  21  22  105 105 105 105   
##   108 109 110 111  120 121 122 123  200 200 200 200   
##                                                     â•¯ 
#+end_src

* Array Boxing
Array elements with different shapes can be put into /boxes/ to emulate
nested/deep arrays:
: [â–¡xs â–¡ys â–¡z â€¦]

In the output, the elements of the boxed arrays are separated by ~|~:
: [x1 x2â€¦|y1 y2â€¦|âˆ™z|â€¦]
- scalars are marked with a ~âˆ™~ to be distinguished from single-row lists

Instead of calling ~â–¡~ on each item, the curly brace syntax automatically box
each item in the array:
: {x y â€¦}

To /unbox/ the contents of a boxed array, use /un/ + /boxed/ ~Â°â–¡~:
: Â°â–¡boxed_x

#+begin_src uiua
â–¡42 ## â–¡42 

â–¡[]    ## â–¡[] 
Â°â–¡â–¡[]  ## [] 
â–¡1_2   ## â–¡[1 2] 
Â°â–¡â–¡1_2 ## [1 2] 

[â–¡1 â–¡2_3_4 â–¡5_6] ## [âˆ™1â”‚2 3 4â”‚5 6] 
{1 2_3_4 5_6}    ## [âˆ™1â”‚2 3 4â”‚5 6] 
#+end_src

/Pervasive functions/ work on /boxed/ elements without the need to /unbox/ them.
They preserve the maximum /box depth/ of their arguments:
#+begin_src uiua
+1 4    ## 5 
+1 â–¡4   ## â–¡5 
+1 â–¡â–¡4  ## â–¡â–¡5 
+â–¡â–¡1 â–¡4 ## â–¡â–¡5 

Ã—10 {1_2_3 4_5 6} ## [10 20 30â”‚40 50â”‚âˆ™60]
#+end_src

As an exception, /comparison functions/ lexicographically compare boxed arrays
as a whole:
#+begin_src uiua
= [1 2 3] [1 2 5]   ## [1 1 0] 
= â–¡[1 2 3] â–¡[1 2 5] ## 0 
= â–¡[1 2 3] â–¡[1 2 3] ## 1 
#+end_src

For /non-pervasive/ functions, the arguments often have to be /unboxed/. The
/inventory/ ~âš~ modifier can be used to operate on temporarily /unboxed/ values.

Unboxing each boxed element in an array generally requires a way to homogenize
the elements so that the array can stay rectangular and flat.

The /content/ ~â—‡~ modifier takes a function and calls it on the unboxed arguments.
It can be combined with /reduce/ ~/~ to join all elements into a normal array:
#+begin_src uiua
/â—‡âŠ‚{@a @b @c} ## "abc" 
/â—‡âŠ‚{1 2 3} ## [1 2 3] 
#+end_src

To decompose a list of boxed elements into individual stack items, /un-box/ ~Â°â–¡~
can be /subscripted/ with the exact number of elements in the list, which will
then appear one-by-one on the stack:
#+begin_src uiua
Â°â–¡â‚ƒ {@a @b @c}
#### @c 
#### @b 
#### @a 
#+end_src

* Types
There are four types of arrays:
- Number
  - IEEE-754 double-precision floating-point format
  - can be written as integers, with decimals, as fractions (e.g. ~3Ï€/2~)
  - scientific notation (e.g. ~6e3~ = ~6000~) is supported
  - can contain numeric constants like ~Ï€~, ~Ï„~, ~Î·~, ~e~, and ~âˆ~
- Complex
  - printed like ~5+3i~
  - can be written as literals by suffixing the real part with ~r~ and/or the
    imaginary part with ~i~ (e.g. ~5r3i~)
  - support the same math operations as normal numbers
- Character
  - represented as 32-bit Unicode codepoints
  - character literals marked with ~@~ denote rank-0 (scalar) char arrays
  - string literals delimited by ~"â€¦"~ denote rank-1 char arrays (strings)
  - some chars must be escaped, e.g. newline ~@\r~, null ~@\0~, but not space
  - /raw string literals/ marked with ~$~ (followed by a space) need no escaping
    - the string runs to the end of the line
    - if the next line is another raw string literal, a newline gets inserted
  - chars can also be specified with 2 (e.g. ~@\x41~) or 4 (e.g. ~@\u2665~) hex
    digits by using escape codes
    - longer/shorter sequences must be wrapped in ~{â€¦}~ (e.g. ~@\u{1f600}~)
    - escape sequences do not work in /raw strings/
  - ~&p~ can be used for pretty-printing
- Box

The ~type~ function gets the /type/ of an array on the stack, encoded as an
integer:
- ~0~: real numbers
- ~1~: characters
- ~2~: boxes
- ~3~: complex numbers

#+begin_src uiua
type [1 2]   ## 0 
type "ab"    ## 1 
type {@a @b} ## 2 
type [i 2r1] ## 3 
#+end_src

An empty array always has the /shape/ ~[0].~ It can have different types:
#+begin_src uiua
type [] ## 0 
type "" ## 1 
type {} ## 2 
#+end_src

/Format strings/ are created by prefixing a string with ~$~. It is a special kind
of function that takes an argument for each ~_~ in the string and replaces it
with the stringified version.
- a ~_~ can be inserted by escaping it with ~/_~
- /raw strings/ can be turned into format strings with an additional ~$~.
- being functions, format strings can be used with modifiers like /reduce/

#+begin_src uiua
Oracle â† $"The meaning of _ is _!"
Oracle "life" 42
## "The meaning of life is 42!" 
Oracle @Ï€ Ï€
## "The meaning of Ï€ is 3.141592653589793!"

3 2 1
$$ Explosion in _,
$$ _,
$$ _â€¦
$$ BOOM!
## "Explosion in 3,\n2,\n1â€¦\nBOOM!"

/$"_ _" {"Separated" "by" "spaces"}
## "Separated by spaces" 
#+end_src

Characters and numbers exist in an /affine space/ (like in BQN):
- ~+n c~ / ~+c n~ returns another character
- ~-n c~ returns another character
- ~-c c~ returns a number
- ~Ã—n c~ / ~Ã—c n~ or ~Ã·n c~ toggles the case of some characters, if ~n~ is negative
  - see /sign/ ~Â±~ to /get the case/ of a character as a number
  - see /negate/ ~Â¯~ to /toggle the case/ of a character
  - see /absolute value/ ~âŒµ~ to /uppercase/ (/lowercase/ with  ~Â¯âŒµ~) a character
- no other dyadic arithmetic operations are possible with characters

* Signatures
[[Bindings]] and [[Inline Functions]] can have a /signature/ declared like:
: â€¦ = |<input #>.<output #> â€¦  <- for bindings
: (|<input #>.<output #> â€¦)    <- for inline functions
- e.g. ~|2.1~ means the function takes 2 arguments and returns one
- the second number is optional and defaults to 1 if not given

A /declared/ signature always overrides the /inferred/ signature. If they donâ€™t
match, there will be a warning.

* Modules

Import a function from a local module:
: ~ "<filename>" ~ <fn-name>
and call it like this:
: <fn-name> â€¦

Import the local module as a namespace, using an alias:
: <alias> ~ "<filename>"
and call a function from it like this:
: <alias>~<fn-name>

* Comments
A comment ~#~ with additional ~#~'s is an /output comment/. Each additional ~#~ prints
the next item from the top of the stack on /format/. This is useful for
debugging.

#+begin_src uiua
# Normal comments

1 2 # inline

# Output comments

1 2 3
####

+ 3 4 ##

# the formatter turns it into:
1 2 3
#### 3
#### 2
#### 1

+ 3 4 ## 12
#+end_src

Output comments inside [[Inline Functions][inline functions]] will show the values for each time the
function is called.
#+begin_src uiua
F â† (
  ## 5 6
  + 1 ## 6 7 
)
F 5
F 6

#+end_src

* Constants
- ~Î·~ eta (pi/2; tau/4)
- ~Ï€~ pi (2 eta; tau/2)
- ~Ï„~ tau (2 pi; 4 eta)
- ~âˆ~ infinity
- ~i~ imaginary number

* Functions
** Stack Functions
*** ~?~ stack [noa., 0-out] & ~â‚™~
Prints all stack values at insertion, without popping them.

With a /subscript/, will print only that number of values from the stack.

*** ~âˆ˜~ identity [mon.] {id / i(â†’planet)}
Does nothing with one value (monadic).

#+begin_src uiua
âˆ˜ 5
# =>
5
#+end_src

*** ~â—Œ~ pop [mon., 0-out] {po / p(â†’planet)} & ~Â°~
Discards the top stack value.

** Monadic Pervasive
*** ~Â¬~ not
Logical /not/ operation.
- equivalent to ~-âŠ™1~ â†’ subtracts the number from 1

*** ~Â¯~ negate {neg}
Negates a number.
- like monadic ~-~ (negate) in APL
- backtick ~`~ will be converted to a /negate/ ~Â¯~ by the formatter
*** ~Â±~ sign {sig}
Returns the numeric sign (~1~, ~Â¯1~ or ~0~).

On a *complex number*, /normalizes/ it to magnitude 1.

On a *character*, gets its case:
- ~Â¯1~ for /lowercase/
- ~1~ for /uppercase/
- ~0~ for /caseless/

#+begin_src uiua
Â± "A new WORLD" ## [1 0 Â¯1 Â¯1 Â¯1 0 1 1 1 1 1] 
#+end_src
*** ~âŒµ~ absolute value {abs}
Returns the /absolute value/ of the number.

With *complex numbers*, converts them to their /magnitude/.

With *characters*, /capitalizes/ them.
*** ~âˆš~ sqrt {sqr}
Returns the /square root/ of the number.
- with a /subscript n/, returns the *nth root*
- ~âˆšÂ¯1~ = ~NaN~, but ~âˆšâ„‚0Â¯1~ = ~i~
*** ~â‚‘~ exponential {exp} & ~Â°~ logarithm {log} & ~â‚™~
Returns the exponential /e^x/ for the number /x/:
: â‚‘ x
- set the base /b/ per /subscript/ to get /b^x/
  - same as ~â¿ x b~

The /un/ ~Â°~ modifier returns the /natural logarithm/ instead:
: Â°â‚‘ x
- set the base /b/ per /subscript/ to get /log_b(x)/

*** ~âˆ¿~ sine {sin} & ~Â°~
Returns the /sine/ of the number.

~âˆ¿+Î·~ gets the /cosine/ instead.

~Â°âˆ¿~ gets the /arcsine/, ~Ëœ-Î·Â°âˆ¿~ gets the /arccosine/.

Also see /un-atangent/ ~Â°âˆ ~ to get both /sine/ and /cosine/ together. Note that
for ~Î·~, there are tiny differences between the two methods that may lead to
inconsistent results:
#+begin_src uiua
TrigA â† âŠ‚âŠƒâˆ¿ (âˆ¿+Î·) # sin cos
TrigA Î· ## [1 0.00â€¦012246467991473532] 
TrigA Ï€ ## [0.00â€¦012246467991473532 Â¯1] 
TrigA Ï„ ## [Â¯0.00â€¦024492935982947064 1] 

TrigB â† âŠ‚Â°âˆ 
TrigB Î· ## [1 0.00â€¦06123233995736766] 
TrigB Ï€ ## [0.00â€¦012246467991473532 Â¯1] 
TrigB Ï„ ## [Â¯0.00â€¦024492935982947064 1] 

â‰ âŠƒTrigA TrigB Î· ## 0 
â‰ âŠƒTrigA TrigB Ï€ ## 1 
â‰ âŠƒTrigA TrigB Ï„ ## 1 
#+end_src
*** ~âŒŠ~ ~âŒˆ~ ~â…~ floor {flr}, ceil {cei}, round {rou} & ~â‚™~
Rounds to the nearest integer /(round)/: towards ~Â¯âˆ~ /(floor)/ or towards ~âˆ~
/(ceil)/.

/round/ with fraction ~0.5~ will round away from 0
- e.g. ~â…2.5 = 3~ and ~â…Â¯2.5 = Â¯3~

/round/ with a /subscript/ rounds to that many decimal places.

** Dyadic Pervasive
*** ~+~ ~-~ add, subtract {sub}
*** ~Ã—~ ~Ã·~ multiply {mul, ~*~} & ~Â°~, divide {div} & ~Â°~

Division by 0 results in infinity ~âˆ~.

*** ~â¿~ power {pow}
Raises the second value to the /power/ of the first.

/anti-backward-power/ (~âŒËœâ¿)~ or /un-exponential/ (~Â°â‚‘~) can be used to get the
*logarithm* of a number.

*** ~â—¿~ modulo {mod}
Returns the remainder of dividing the second by the first argument.

Use ~âœâŠ™âŒµâ—¿~ to get /negative modulo/ instead of /remainder/:
#+begin_src uiua
x â† Ëœ-â†»1âŠ‚âŸœâ‡¡Ã—2 .5
x
â—¿ 3 x
âœâŠ™âŒµâ—¿ 3 x
# =>
[Â¯5 Â¯4 Â¯3 Â¯2 Â¯1 0 1 2 3 4 5]
[1 2 0 1 2 0 1 2 0 1 2]
[Â¯2 Â¯1 Â¯0 Â¯2 Â¯1 0 1 2 0 1 2]
#+end_src
*** ~âˆ ~ atangent {ata} & ~Â°~
Returns the /arctangent/ of two numbers.

The /inverse/ ~Â°âˆ ~ puts both, the /cosine/ and /sine/ (in that order) of the input
angle onto the stack. Therefore, ~ËœÃ·Â°âˆ ~ gets the /tangent/ of the angle.

#+begin_src uiua
a â† âŠËœâˆ  â‡Œ.[Â¯ 1 0 1]
a # angle
## â•­â”€
## â•·  3Ï„/8  Î·  Ï„/8
##       Ï€  0    0
##   Â¯3Ï„/8 Â¯Î· Â¯Ï„/8
##                 â•¯
âˆ©â…â‚‚ Â°âˆ  a # cos(a) | sin(a)
### â•­â”€
### â•· Â¯0.71 0 0.71
###   Â¯1    1 1
###   Â¯0.71 0 0.71
###                â•¯
### â•­â”€
### â•·  0.71  1  0.71
###    0     0  0
###   Â¯0.71 Â¯1 Â¯0.71
###                  â•¯
â…â‚‚ ËœÃ·Â°âˆ  a # tan(a)
## â•­â”€
## â•· Â¯1  16331239353195368  1
##   Â¯0                  0  0
##    1 Â¯16331239353195368 Â¯1
##                            â•¯
#+end_src
*** ~=~ ~â‰ ~ equals {eq}, not equals {~!=~ / ne / neq}
Compare for equality/inequality.
- Uiua has no boolean type. Comparison operators return ~0~ for /false/ and ~1~
  for /true/.

*** ~<~ ~>~ less than {lt}, greater than {gt}
Compares for less/greater than.
- ~< x y~ means ~y < x~
- ~> x y~ means ~y > x~

*** ~â‰¤~ ~â‰¥~ less or equal {~<=~ / le / leq}, greater or equal {~>=~ / ge / geq}
Compares for less/greater than or equal.
- ~â‰¤ x y~ means ~y â‰¤ x~
- ~â‰¥ x y~ means ~y â‰¥ x~

*** ~â†¥ â†§~ maximum {max}, minimum {min}
Takes the max./min. of two arrays.
- like dyadic ~âŒˆ~ (maximum) / ~âŒŠ~ (minimum) in APL
*** ~â„‚~ complex {com} & ~Â°~
Creates a complex number from an /imaginary/ and a /real/ part on the stack.
- stack order: 1. /imaginary/ 2. /real/
- equivalent to ~+Ã—i~

/un-complex/ ~Â°â„‚~ pushes the /imaginary/ and /real/ parts back on the stack (in
the same order as the input to /complex/).

#+begin_src uiua
â„‚ 3 5 ## 5+3i
[Â°â„‚] i ## [1 0]
= 5 â„‚0 5 ## 1
#+end_src

See also:
- /absolute value/ ~âŒµ~ â†’ get the magnitude
- /sign/ ~Â±~ â†’ normalize to magnitude 1

** Monadic Array
*** ~â§»~ length {len} & ~(Â°âŠ¸)â‚™~
Returns the number of items along the first axis of the array.
- like monadic ~â‰¢~ (tally) in APL

*** ~â–³~ shape {sha} & ~Â°â‚™âœ~
Returns the dimensions of the array.
- like monadic ~â´~ (shape) in APL

#+begin_src uiua
â–³5               #=> []
â–³[]              #=> [0]
â–³[9 1 6]         #=> [3]
â–³[4_Ï€_9 1_5_âˆ]   #=> [2 3]
â–³[[1_2_3 3_4_5]] #=> [1 2 3]
#+end_src

/un-shape/ ~Â°â–³~ takes a /shape/ as input and returns an array of that shape.

#+begin_src uiua
Â°â–³ 2_3_4
## â•­â”€                         
## â•· 0 1  2  3  12 13 14 15   
## â•· 4 5  6  7  16 17 18 19   
##   8 9 10 11  20 21 22 23   
##                          â•¯ 
#+end_src

*** ~â™­~ deshape {flat / des}
Flattens the array to /rank 1/.
- like monadic ~,~ (ravel) in APL

With a /subscript/, flattens it to /rank n/.
- /negative subscripts/ flatten to rank /m-n/ (relative to rank /m/ of the arr.)
- if the subscript rank is greater than the rank of the array, /length-1/
  axes are added to the front of the shape
- if the subscript is 0, returns the first scalar in the array

#+begin_src uiua
â–³ â™­ Â°â–³2_3_4_5  ## [120] 
â–³ â™­â‚‚ Â°â–³2_3_4_5 ## [24 5] 
â–³ â™­â‚ƒ Â°â–³2_3_4_5 ## [6 4 5]

â–³ â™­â‚‹â‚ Â°â–³2_3_4_5 ## [6 4 5] 
â–³ â™­â‚‹â‚‚ Â°â–³2_3_4_5 ## [24 5] 
â–³ â™­â‚‹â‚ƒ Â°â–³2_3_4_5 ## [120] 
#+end_src

*** ~âŠ¢~ ~âŠ£~ first {fir} & ~âœâ‚™~, last {las} & ~âœâ‚™~
Returns the first/last /row/ (first axis) of an array.
- like dyadic ~1â†‘~ / ~Â¯1â†‘~ (take) in APL

*** ~â‡¡~ range {ran} & ~â‚™~
Creates an array of all natural numbers less than /n/.
- like monadic /iota/ ~â³~ in APL

/range/ with /subscript/ changes the /offset/ of the range:
#+begin_src uiua
â‡¡â‚ 5 ## [1 2 3 4 5] 
â‡¡â‚‚ 5 ## [2 3 4 5 6] 
#+end_src

*** ~â‡Œ~ reverse {rev}
Reverses the array along the first axis.
- like monadic ~âŠ–~ (reverse first) in APL
- ~â‰¡â‡Œ~ behaves like monadic ~âŒ½~ (reverse) in APL
  
*** ~â‰~ transpose {tra} & ~Â°~
Transposes/rotates the axes/shape of the array so that the /leading axis/
will become the /last axis/ of the shape.
- like ~â‰~ in APL
- e.g. the shape of ~â‰Â°â–³5_4_3_2_1~ will become ~[4 3 2 1 5]~

/un-transpose/ ~Â°â‰~ instead rotates the /last axis/ to become the /leading axis/
of the shape.
- e.g. the shape of ~Â°â‰Â°â–³5_4_3_2_1~ will become ~[1 5 4 3 2]~

#+begin_src uiua
â‰ . [1_2_3 4_5_6]
## â•­â”€      
## â•· 1 4   
##   2 5   
##   3 6   
##       â•¯ 
#+end_src

*** ~â–¡~ box & ~Â°(âœÂ°)â‚™~
See [[Array Boxing]].

*** ~â‹¯~ bits & ~Â°âœâ‚™~
Encode a number/array as bits (LSB-first).
- â€œLBSâ€ means /least significant bit/
- always results in an array 1 rank higher than the input
- with /subscript/, forces the number of bits to be used (extends or
  truncates the bits)

/un-bits/ ~Â°â‹¯~ decodes bits back to numbers.

*Warning:* conversion (~â‹¯~ / ~Â°â‹¯~) on large numbers (> 53 bits long) may give
incorrect results due to floating point imprecision.

/under-bits/ ~âœâ‹¯~ performs /bit-wise operations/.

** Dyadic Array
*** ~â†¯~ reshape {res} & ~â¬š~
Reshape the array to fit the given shape.
- like ~â´~ (reshape) in APL
- repeats elements when overcounting the input array (like in APL)

*** ~â†™~ ~â†˜~ take {tak} & ~â¬š(Â°â¬š)~, drop {dro} & ~â¬šâŒ~
Takes/drops /n/ elements along the first axis of the array.
- like dyadic ~â†‘~ (take) / ~â†“~ (drop) in APL

/antidrop/ pads an array with fill elements.

*** ~âŠ¡~ pick {pic} & ~Â°âœâŒ~
Picks a /row/ or /element/ of the array, given a single index or a list of
indices (to reach into higher-ranked arrays).

*** ~âŠ~ select {sel} & ~â¬šÂ°âœâŒ~
Selects /rows/ from an array according to an index vector.

#+begin_src uiua
âŠ [1 2 5] "abcdef" #=> "bcf"
â¬š@-âŒâŠ [1 2 5] "bcf" #=> "-bc--f"
#+end_src

*** ~â–½~ keep {kee} & ~âŠ¸â¬šÂ°â‚™âœâŒ~
Discards or copies items in an array:
: â–½ <mask> <arr>
- like dyadic /replicate first/ ~âŒ¿~ in APL

Example:
#+begin_src uiua
â–½ [0 1 0 1] [1_2 3_4 5_6 7_8]
#=>
â•­â”€     
â•· 3 4  
  7 8  
      â•¯
#+end_src

~âœâ–½~ modifies part of an array according to a mask:
: âœâ–½<f> <mask> <arr>

Example:
#+begin_src uiua
âœâ–½(Ã—.) [0 1 1 0 1] [1 2 3 4 5]
#=>
[1 4 9 4 25]
#+end_src

*** ~âŠ‚~ join {joi} & ~â¬šÂ°â‚™~
Concatenates two arrays or appends a new /row/ in case of a scalar.
- like dyadic ~âª~ (catenate first) in APL
- ~â‰¡âŠ‚~ behaves like dyadic ~,~ (catenate) in APL

*** ~âŠŸ~ couple {cou} & ~â¬šÂ°â‚™~
Combine two arrays as /rows/ of a new array (increases the rank).

The *inverse* ~Â°âŠŸ~ separates combined arrays.

Use /fill/ ~â¬š~ if shapes donâ€™t match:
#+begin_src uiua
â¬š@ âŠŸ "Apple" "Pie"
## â•­â”€          
## â•· "Apple"   
##   "Pie  "   
##           â•¯ 
#+end_src

** Misc
*** ~&ims~ image - show
Shows an image, depending on the system backend.

*Note:* In the (Ghostty) terminal, the image does not always shows up with
lower row/column lengths (bug?).
- better use /window mode/ ~-w~ for graphic output
*** ~&gifs~ gif - show
*** ~&ap~ audio - play
*** ~&s~ show
Prints a nicely formatted representation of a value to stdout.

Array axes are layed out in an alternating horizontalâ†’verticalâ†’â€¦ pattern.
The elements of the last axis are always layed out horizontally
(column-wise), the ones on the next axis vertically (row-wise), for the
next axis it is horizontally again, etc.
- this is different to APL, where every axis before the last one is layed
  out vertically in rows

*** ~&p~ print with newline
Print a value to stdout followed by a newline.
* Modifiers (â†’Operators)
** Stack Modifiers
*** ~Ëœ~ backward [mon.] {bac}
Swaps the arguments of a dyadic function.
- like monadic operator ~â¨~ (commute) in APL

: Ëœ -3 10  =  -10 3  =  -7

*** ~Ë™~ self [mon.] {slf}
Calls a function with the same array as all arguments.

#+begin_src uiua
Ë™+ 5
# =>
10

Ë™âŠ+ 1_2_3
# =>
â•­â”€       
â•· 2 3 4  
  3 4 5  
  4 5 6  
        â•¯
#+end_src

*** ~âŠ™~ dip [mon.] {d(â†’planet)}
Temporarily pops the top value off the stack and calls the function.
- stacking multiple /dips/ enables operating on lower stack values without
  touching the top ones

#+begin_src uiua
âŠ™+ 1 2 3 4
# =>
4
5
1

[âŠ™âŠ™+ 1 2 3 4]
# =>
[1 2 7]

âŠ™(/â†¥) 1_2_3 4_5_6
# =>
6
[1 2 3]
#+end_src

Combines well with /fork/ ~âŠƒ~ to keep values on the stack after/before
operating on them:
- use /gap/ ~â‹…~ to drop subsequent stack values
#+begin_src uiua
[âŠƒâŠ™âŠ™âˆ˜(++) 3 5 10]
# =>
[3 5 10 18]

[âŠƒâŠ™â‹…âˆ˜(++) 3 5 10]
# =>
[3 10 18]
#+end_src

*** ~â‹…~ gap [mon.] {g(â†’planet)}
Discards the top stack value before calling the function.
- also see the function /pop/ ~â—Œ~

#+begin_src uiua
â‹…+ 3 5 10
# =>
15
#+end_src

*** ~âŠƒ~ fork [dya.] {for / f(â†’planet)}
Calls two functions on the same value(s) and puts both outputs on the
stack.
- the functions can be of any arity; if one function takes fewer
  arguments, it just uses that many arguments from the top of the stack
- important for threading data through a program and for /planet notation/

#+begin_src uiua
âŠƒâ‡Œâ§» 1_2_3_4
# =>
4
[4 3 2 1]

âŠƒâ†§â†¥ â‡¡4 â‡Œâ‡¡4
# =>
[3 2 2 3]
[0 1 1 0]
#+end_src

With a /function pack/, /fork/ can take any number of functions instead of
just two:
#+begin_src uiua
[âŠƒ(+|-|Ã—|Ã·) 2 5]
## [7 3 10 2.5] 
#+end_src

*** ~âˆ©~ both [mon.] {bot} & ~â‚™âŒâŒŸ~
Calls the /n/-ary function on two sequences of the next top /n/ values on the
stack.
- just the top 2 values in case of a unary function
- for a dyadic function ~f~ on ~a b c d~, calls ~f a b~ and ~f c d~

#+begin_src uiua
âˆ©â‡¡ 4 6
### [0 1 2 3 4 5]
### [0 1 2 3]
[âˆ©+ 1 2 3 4] ## [3 7] 
#+end_src

With /numbered subscripts/, /both/ calls its function on /n/ sets of arguments:
#+begin_src uiua
[âˆ©â‚ƒâŠŸ 1 2 3 4 5 6]
## â•­â”€      
## â•· 1 2   
##   3 4   
##   5 6   
##       â•¯ 
#+end_src

/both/ can be used with /sided subscripts/ to apply the /left-most/ ~âŒ~ or
/right-most/ ~âŒŸ~ argument twice:
#+begin_src uiua
[âˆ©âŠŸ @a @b @c @d]
## â•­â”€       
## â•· "ab"   
##   "cd"   
##        â•¯ 
[âˆ©âŒâŠŸ @a @b @c]
## â•­â”€       
## â•· "ab"   
##   "ac"   
##        â•¯ 
[âˆ©âŒŸâŠŸ @a @b @c]
## â•­â”€       
## â•· "ac"   
##   "bc"   
##        â•¯ 
#+end_src

/sided/ and /numeric subscripts/ can also be mixed.

*** ~âŠ“~ bracket [dya.] {bra} & ~âŒâŒŸ~
Calls two /n/-ary functions on two sequences of the next top /n/ values on the
stack.
- just the top 2 values in case of a unary function
- for dyadic functions ~f~ and ~g~ on ~a b c d~, calls ~f a b~ and ~g c d~

Like /fork/, /bracket/ can take any number of functions instead of just two
when using a /function pack/:
#+begin_src uiua
[âŠ“(+|-|Ã—|Ã·) 10 20 5 8 3 7 2 5]
## [30 3 21 2.5] 
#+end_src

/bracket/ (like /both/) can be used with /sided subscripts/ to apply the
/left-most/ ~âŒ~ or /right-most/ ~âŒŸ~ argument twice:
#+begin_src uiua
{âŠ“âŠŸâ–¡â‚‚ @a @b @c @d}
## ["ab"â”‚[@câ”‚@d]] 
{âŠ“âŒâŠŸâ–¡â‚‚ @a @b @c}
## ["ab"â”‚[@aâ”‚@c]] 
{âŠ“âŒŸâŠŸâ–¡â‚‚ @a @b @c}
## ["ac"â”‚[@bâ”‚@c]] 

âŠ“âŒŸâ‰¥â‰¤5 8 [6 2 5 9 6 5 0 4]
### [1 1 1 0 1 1 1 1] 
### [1 0 1 1 1 1 0 0] 
#+end_src

** Iterating Modifiers
*** ~â‰¡~ rows {row}
Applies the function to /each row/ of the array(s).
: â‰¡<f> <arr â€¦>

*** ~âŠ~ table {tab}
Applies ~f~ on all combinations of rows from arrays ~a~ and ~b~:
: âŠ<f> <a> <b>
- there seems to be no analog in APL, /outer product/ only works scalar-wise

#+begin_src uiua
âŠ(âŠ‚â‡Œ) [1_2 3_4] [5 6 7]
#=>
â•­â”€              
â•· 2 1 5  4 3 5  
â•· 2 1 6  4 3 6  
  2 1 7  4 3 7  
               â•¯
#+end_src
*** ~âš~ inventory
Applies the function to each /unboxed/ row of an array and re-/boxes/ the
result.
: âš<f>

** Aggregating Modifiers
*** ~/~ reduce {red}
Applies reducing function ~f~ to the array (â€œbetweenâ€ its items):
: /<f> <arr>
- reduces along the /first/ axis (across columns in a matrix)
- like monadic op. ~âŒ¿~ (reduce first) in APL

** Inversion Modifiers
*** ~Â°~ un
Inverts the behaviour of a function.
- e.g. for unboxing: ~Â°â–¡~

*** ~âŒ~ anti
Inverts the behaviour of a function, treating its first argument as a
constant(?)

*** ~âœ~ under
Operates (~g~) on a transformed (~f~) array, then reverses the transformation.
: âœ<f><g>
- more powerful version of /un/ ~Â°~

** Other Modifiers
*** ~â¬š~ fill {fil}
Fill missing values of an array that has mismatched shapes with ~fill-value~
so it becomes a valid array:
: â¬š<fill-value> <arr/f>
- partially like monadic ~â†‘~ (mix) in APL, but not with nested arrays and with
  function argument

#+begin_src uiua
â¬š0[1 2_3_4 5_6]
#=>
â•­â”€       
â•· 1 0 0  
  2 3 4  
  5 6 0  
        â•¯

â¬šÏ€â†™ 5 [1 2 3]
#=>
[1 2 3 Ï€ Ï€]
#+end_src
* Idioms
Sources:
- https://tankorsmash.unison-services.cloud/s/uiuisms-service/

Upscale a 2d matrix or colored image:
: â–½âŸœâ‰¡â–½

Create a checkerboard of size N:
: â—¿2âŠ+.â‡¡ 8
