#+title: Docs/Uiua

- https://www.uiua.org
- https://github.com/uiua-lang/

Online REPL: https://www.uiua.org/pad

Docs: https://www.uiua.org/docs/
- [[https://www.uiua.org/docs/combinators][Combinators]]

/Array-oriented/ programming language with a /stack-based/ execution model and a
/flat array/ model.
- arrays must be rectangular and cannot have mixed types
- mixed or deep arrays can be emulated using [[Boxes]]

Editor support:
- Emacs: [[https://github.com/crmsnbleyd/uiua-mode][uiua-mode]]

Install the interpreter from the latest [[https://github.com/uiua-lang/uiua/releases][GitHub release]].

* Definitions
To assign a name to a value:
: x â† <v>
- names are case-sensitive, can only contain letters
- ~=~ will be converted to ~â†~ by the formatter

~â†~ pops the first thing off the stack and assigns it to the name on the left:
#+begin_src uiua
Ã—2 [2 3 4]
x â†
x  #=> [4 6 8]
#+end_src

To assign a name to a function:
: x â† <f>
where ~f~ does not have enough arguments to run.

#+begin_src uiua
F â† +1
F5
#=> 6

ğŸ‘‹ â† âŠ‚"Hello, "
ğŸ‘‹"World"
#=> "Hello, World"
#+end_src

* Arrays
An array is a rectangular collection of elements arranged along some number of
axes. Nesting creates arrays of higher rank, not nested arrays (like in APL),
so all nested arrays must be of the same length.

Arrays are /0-indexed/.

Notations:
: [1 2 3 4]
: 1_2_3_4

#+begin_src uiua
[1_2_3 [4 5 6] 7_8_9]
# =>
â•­â”€       
â•· 1 2 3  
  4 5 6  
  7 8 9  
        â•¯
#+end_src

Arrays can have arbitrary code inside brackets, which is evaluated just like
any other code:
#+begin_src uiua
[Ã—3. 4_5_6]
# =>
â•­â”€          
â•· 12 15 18  
   4  5  6  
           â•¯
#+end_src

* Boxes
Array elements with different shapes can be put into /boxes/ to emulate
nested/deep arrays:
: [â–¡x â–¡y â€¦]

Instead of calling ~â–¡~ on each item, the curly brace syntax automatically box
each item in the array:
: {x y â€¦}

To /unbox/ the contents of a boxed array, use /un/ + /boxed/ ~Â°â–¡~:
: Â°â–¡boxed_x

/Pervasive functions/ work on /boxed/ elements without the need to /unbox/ them.

For other functions, the /inventory/ ~âš~ modifier can be used to operate on
temporarily /unboxed/ values in /boxed/ arrays.

#+begin_src uiua
â–¡42    # => â–¡42

â–¡[]     # => â–¡[]
Â°â–¡â–¡[]  # => []
â–¡1_2    # => â–¡[1 2]
Â°â–¡â–¡1_2 # => [1 2]

[â–¡1 â–¡2_3_4 â–¡5_6] # => [âˆ™1â”‚2 3 4â”‚5 6]
{1 2_3_4 5_6}    # => [âˆ™1â”‚2 3 4â”‚5 6]
#+end_src

Unbox

* Functions
** Stack Functions
*** ~?~ stack [noa., 0-out] & ~â‚™~

Prints all stack values at insertion, without popping them.

*** ~.~ duplicate [mon., 2-out]

Duplicates top value on the stack.

*** ~âˆ˜~ identity [mon.] {id}
Does nothing with one value (monadic).

#+begin_src uiua
âˆ˜ 5
# =>
5
#+end_src

** Monadic Pervasive
*** ~Â¯~ negate {neg}
Negates a number.
- like monadic ~-~ (negate) in APL
- backtick ~`~ will be converted to a /negate/ ~Â¯~ by the formatter

** Dyadic Pervasive
*** ~+~ ~-~ add, subtract {sub}
*** ~Ã—~ ~Ã·~ multiply {mul, ~*~} & ~Â°~, divide {div} & ~Â°~
*** ~â†¥ â†§~ maximum {max}, minimum {min}
Takes the max./min. of two arrays.
- like dyadic ~âŒˆ~ (maximum) / ~âŒŠ~ (minimum) in APL

** Monadic Array
*** ~â§»~ length {len} & ~(Â°âŠ¸)â‚™~
Returns the number of items along the first axis of the array.
- like monadic ~â‰¢~ (tally) in APL

*** ~â–³~ shape {sha} & ~Â°â‚™âœ~
Returns the dimensions of the array.
- like monadic ~â´~ (shape) in APL

#+begin_src uiua
â–³5               #=> []
â–³[]              #=> [0]
â–³[9 1 6]         #=> [3]
â–³[4_Ï€_9 1_5_âˆ]   #=> [2 3]
â–³[[1_2_3 3_4_5]] #=> [1 2 3]
#+end_src

*** ~âŠ¢~ ~âŠ£~ first {fir} & ~âœâ‚™~, last {las} & ~âœâ‚™~
Returns the first/last element of the first axis of an array.
- like dyadic ~1â†‘~ / ~Â¯1â†‘~ (take) in APL

*** ~â‡Œ~ reverse {rev}
Reverses the array along the first axis.
- like monadic ~âŠ–~ (reverse first) in APL
- ~â‰¡â‡Œ~ behaves like monadic ~âŒ½~ (reverse) in APL
  
*** ~â‰~ transpose {tra} & ~Â°~
Transposes/rotates the axes of the array.
- like ~â‰~ in APL

*** ~â–¡~ box & ~Â°(âœÂ°)â‚™~
See [[Boxes]].

** Dyadic Array
*** ~â†¯~ reshape {res} & ~â¬š~
Reshape the array to fit the given shape.
- like ~â´~ (reshape) in APL
- repeats elements when overcounting the input array (like in APL)

*** ~â†™~ ~â†˜~ take {tak} & ~â¬š(Â°â¬š)~, drop {dro} & ~â¬šâŒ~
Takes/drops /n/ elements along the first axis of the array.
- like dyadic ~â†‘~ (take) / ~â†“~ (drop) in APL

/antidrop/ pads an array with fill elements.

*** ~âŠ~ select {sel} & ~â¬šÂ°âœâŒ~
Selects items from an array using an index vector.

#+begin_src uiua
âŠ [1 2 5] "abcdef" #=> "bcf"
â¬š@-âŒâŠ [1 2 5] "bcf" #=> "-bc--f"
#+end_src

*** ~â–½~ keep {kee} & ~âŠ¸â¬šÂ°â‚™âœâŒ~
Discards or copies items in an array:
: â–½ <mask> <arr>
- like dyadic /replicate first/ ~âŒ¿~ in APL

Example:
#+begin_src uiua
â–½ [0 1 0 1] [1_2 3_4 5_6 7_8]
#=>
â•­â”€     
â•· 3 4  
  7 8  
      â•¯
#+end_src

~âœâ–½~ modifies part of an array according to a mask:
: âœâ–½<f> <mask> <arr>

Example:
#+begin_src uiua
âœâ–½(Ã—.) [0 1 1 0 1] [1 2 3 4 5]
#=>
[1 4 9 4 25]
#+end_src

*** ~âŠ‚~ join {joi} & ~â¬šÂ°â‚™~
Concatenates two arrays/scalars.
- like dyadic ~âª~ (catenate first) in APL
- ~â‰¡âŠ‚~ behaves like dyadic ~,~ (catenate) in APL

*** ~âŠŸ~ couple {cou} & ~â¬šÂ°â‚™~
Combine two arrays as items of a new array (increases the rank).

The *inverse* ~Â°âŠŸ~ separates combined arrays.

** Misc
*** ~&ims~ image - show
Shows an image, depending on the system backend.

*Note:* In the (Ghostty) terminal, the image does not always shows up with
lower row/column lengths (bug?).
- better use /window mode/ ~-w~ for graphic output
*** ~&gifs~ gif - show
*** ~&ap~ audio - play
*** ~&s~ show
Prints a nicely formatted representation of a value to stdout.
*** ~&p~ print with newline
Print a value to stdout followed by a newline.
* Modifiers (â†’Operators)
** Stack Modifiers
*** ~Ëœ~ backward [mon.] {bac}
Swaps arguments in function call.
- like monadic operator ~â¨~ (commute) in APL

: Ëœ -3 10  =  -10 3  =  -7

*** ~âŠƒ~ fork [dya.] {for}
Calls two functions on the same values and puts both outputs on the stack.
- the functions can be of any arity

#+begin_src uiua
âŠƒâ‡Œâ§» 1_2_3_4
# =>
4
[4 3 2 1]

âŠƒâ†§â†¥ â‡¡4 â‡Œâ‡¡4
# =>
[3 2 2 3]
[0 1 1 0]
#+end_src

*** ~âˆ©~ both [mon.] {bot} & ~â‚™~
Calls the /n/-ary function on two sequences of the next top /n/ values on the
stack.
- just the top 2 values in case of a unary function
- for a dyadic function ~f~ on ~a b c d~, calls ~f a b~ and ~f c d~

#+begin_src uiua
âˆ©â‡¡ 4 6
# =>
[0 1 2 3 4 5]
[0 1 2 3]

âˆ©+ 1 2 3 4
# =>
7
3
#+end_src

*** ~âŠ™~ dip [mon.]
Temporarily pops the top value off the stack and calls the function.
- stacking multiple /dips/ enables operating on lower stack values without
  touching the top ones

#+begin_src uiua
âŠ™+ 1 2 3 4
# =>
4
5
1

[âŠ™âŠ™+ 1 2 3 4]
# =>
[1 2 7]

âŠ™(/â†¥) 1_2_3 4_5_6
# =>
6
[1 2 3]
#+end_src

Combines well with /fork/ ~âŠƒ~ to keep values on the stack after/before
operating on them:
- use /gap/ ~â‹…~ to drop subsequent stack values
#+begin_src uiua
[âŠƒâŠ™âŠ™âˆ˜(++) 3 5 10]
# =>
[3 5 10 18]

[âŠƒâŠ™â‹…âˆ˜(++) 3 5 10]
# =>
[3 10 18]
#+end_src

*** ~â‹…~ gap [mon.]
Discards the top stack value before calling the function.
- also see the function /pop/ ~â—Œ~

#+begin_src uiua
â‹…+ 3 5 10
# =>
15
#+end_src

*** ~Ë™~ self [mon.] {slf}
Calls a function with the same array as all arguments.

#+begin_src uiua
Ë™+ 5
# =>
10

Ë™âŠ+ 1_2_3
# =>
â•­â”€       
â•· 2 3 4  
  3 4 5  
  4 5 6  
        â•¯
#+end_src

** Iterating Modifiers
*** ~â‰¡~ rows {row}
Applies the function to each /row/ of the array(s).
: â‰¡<f> <arr â€¦>

*** ~âŠ~ table {tab}
Applies ~f~ on all combinations of rows from arrays ~a~ and ~b~:
: âŠ<f> <a> <b>
- there seems to be no analog in APL, /outer product/ only works scalar-wise

#+begin_src uiua
âŠ(âŠ‚â‡Œ) [1_2 3_4] [5 6 7]
#=>
â•­â”€              
â•· 2 1 5  4 3 5  
â•· 2 1 6  4 3 6  
  2 1 7  4 3 7  
               â•¯
#+end_src
*** ~âš~ inventory
Applies the function to each /unboxed/ row of an array and re-/boxes/ the
result.
: âš<f>

** Aggregating Modifiers
*** ~/~ reduce {red}
Applies reducing function ~f~ to the array (â€œbetweenâ€ its items):
: /<f> <arr>
- reduces along the /first/ axis (across columns in a matrix)
- like monadic op. ~âŒ¿~ (reduce first) in APL

** Inversion Modifiers
*** ~Â°~ un
Inverts the behaviour of a function.
- e.g. for unboxing: ~Â°â–¡~

*** ~âŒ~ anti
Inverts the behaviour of a function, treating its first argument as a
constant(?)

*** ~âœ~ under
Operates (~g~) on a transformed (~f~) array, then reverses the transformation.
: âœ<f><g>
- more powerful version of /un/ ~Â°~

** Other Modifiers
*** ~â¬š~ fill {fil}
Fill missing values of an array that has mismatched shapes with ~fill-value~
so it becomes a valid array:
: â¬š<fill-value> <arr/f>
- partially like monadic ~â†‘~ (mix) in APL, but not with nested arrays and with
  function argument

#+begin_src uiua
â¬š0[1 2_3_4 5_6]
#=>
â•­â”€       
â•· 1 0 0  
  2 3 4  
  5 6 0  
        â•¯

â¬šÏ€â†™ 5 [1 2 3]
#=>
[1 2 3 Ï€ Ï€]
#+end_src
